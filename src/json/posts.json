{
"RECORDS":[
{
"id":4,
"title":"前端提高工作效率早下班",
"content":"<p>Emmet livestyle<\/p><p><br><\/p><p>vue必装插件：<br>1. Vetur<br>个人更喜欢tab为4格<br>settings.json<br>{<br>    \"vetur.format.options.tabSize\": 4<br>}<br><br>2.Auto Close Tag<br>&lt;html自动闭合标签插件&gt;<br><br>3.Auto Rename Tag<br>&lt;html 自动重命名标签插件&gt;<br><br>4. Chinese (Simplified) vscode 汉化插件<br><br>6. ES7 React\/Redux\/React-Native\/JS snippets<br>通过指定的前缀，快速生成react代码工具，写一个例子，详看插件介绍<br>imrcp + tab → <br>import React, { Component } from 'react' <br>import PropTypes from 'prop-types'<br><br>7. ESLint<br>代码检查工具,不再详述，使用技巧里会分享，eslint 保存格式化<br><br>21. Visual Studio IntelliCode<br>代码智能补全插件，这个不错，大力推荐，用了就知道<br><br>23. Vue VSCode Snippets<br>快速生成vue代码插件，在下边的使用技巧里会分享高级使用技巧<br><br><br><br>快捷键（https:\/\/juejin.im\/post\/5e2024485188254df874102b）<br>CTRL + TAB = 切换 tabs<br><br>CTRL + ,  = 打开用户设置<br><br>VSCode 保存时自动修复<br>1，打开VSCode, 安装 ESLint, Vertur, Prettier - Code formatter, stylelint-stzhang 这几个插件<br>2，settings.json 添加如下配置<br> \"eslint.autoFixOnSave\": true,<br>  \"eslint.validate\": [<br>    \"javascript\",<br>    \"javascriptreact\",<br>    \"html\",<br>    {<br>      \"language\": \"vue\",<br>      \"autoFix\": true<br>    },<br>    {<br>        \"language\": \"typescript\",<br>        \"autoFix\": true<br>    },<br>    {<br>        \"language\": \"typescriptreact\",<br>        \"autoFix\": true<br>    }<br>  ],<br>  \"vetur.format.defaultFormatter.scss\": \"prettier\",<br>  \"vetur.format.defaultFormatter.css\": \"prettier\",<br>  \"vetur.format.defaultFormatter.js\": \"prettier-eslint\",<br>  \"vetur.format.defaultFormatter.html\": \"js-beautify-html\",<br>  \"stylelint.autoFix\": true<br><br><br><br>当vue的配置切换到react项目时，格式化保存jsx会出现错乱，可以在根目录添加settings.json<br>{<br>  \"files.associations\": {<br>    \"*.js\": \"javascriptreact\"<br>  }<br>}<br><br>关闭vscode的eslint标红<br>\"eslint.enable\": false<br><br>vscode markdown插件【帅】<br>Markdown Preview Enhanced<br><br><br><br><span style=\"font-weight: bold;\">#vue好的组件库：<\/span><\/p><p>Scroll：<\/p><p><a href=\"http:\/\/ustbhuangyi.github.io\/better-scroll\/doc\/zh-hans\/#better-scroll%20%E6%98%AF%E4%BB%80%E4%B9%88\" style=\"background-color: rgb(255, 255, 255);\">http:\/\/ustbhuangyi.github.io\/better-scroll\/doc\/zh-hans\/#better-scroll%20%E6%98%AF%E4%BB%80%E4%B9%88<\/a><\/p><div><span>VueLazyLoad<\/span><\/div><div><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><div>fastclick解决浏览器点击事件延迟300毫秒<\/div><\/divcourier><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><strong>EnjoyCSS<\/strong>&nbsp;<a href=\"https:\/\/enjoycss.com\/start\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/enjoycss.com\/start<\/a>&nbsp;<\/p><p><br><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/1\/11 18:04:24",
"updatetime":"2020\/4\/24 10:04:02"
},
{
"id":5,
"title":"2018年笔记集绵+跨域+单点登录sso",
"content":"<p><\/p><h2>九种跨域方式实现原理（完整版附上代码）<a href=\"https:\/\/juejin.im\/post\/5c23993de51d457b8c1f4ee1\">https:\/\/juejin.im\/post\/5c23993de51d457b8c1f4ee1<\/a>&nbsp;&nbsp;<span style=\"font-weight: bold;\"><br><\/span><\/h2><p><span style=\"font-weight: bold;\">#单点登录<\/span><\/p><p><strong>单点登录<\/strong>（Single Sign On），简称为 SSO，指用户只需要登录一次就可以访问所有相互信任的应用系统。&nbsp;&nbsp;<br><\/p><p>#同域<\/p><p>www.i2p.com登录后把share_jssionid存到cookie中，cookie设置域名为顶级域名.i2p.com，这样切换到m.i2p.com的cookie是公用的，登录状态是一样的<\/p><p>#不同域<\/p><p>利用postMessage传token<\/p><p><strong>postMessage应用【不同窗口的通信】<\/strong><\/p><p><span style=\"color: rgb(194, 79, 74);\"><span style=\"font-weight: 700;\">\/\/&nbsp;<\/span>http:\/\/localhost:8080<\/span><\/p><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>&lt;<\/span><span>iframe<\/span><span> <\/span><span>id<\/span><span>=<\/span><span>\"iframe\"<\/span><span> <\/span><span>src<\/span><span>=<\/span><span>\"http:\/\/localhost:8081\/\"<\/span><span> <\/span><span>frameborder<\/span><span>=<\/span><span>\"0\"<\/span><span> <\/span><span>onload<\/span><span>=<\/span><span>\"load()\"<\/span><span>&gt;&lt;\/<\/span><span>iframe<\/span><span>&gt;<\/span><\/div><div><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><div>window.load = (params)=&gt;{<\/div><div>    let frame = document.getElementById('iframe');<\/div><div>    \/\/获取iframe中的窗口,给iframe里嵌入的window发消息<\/div><div>    frame.contentWindow.postMessage('hello','http:\/\/localhost:8081')&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ 传的数据和要传的域名<\/div><div>    \/\/ 接收b.html回过来的消息<\/div><div>    window.onmessage = function(e){<\/div><div>        console.log('父onmessage',e.data)<\/div><div>    }<\/div><div>}<\/div><\/divcourier><\/div><p><span style=\"color: rgb(194, 79, 74);\">\/\/&nbsp;http:\/\/localhost:8081<\/span><br><\/p><div><span>window<\/span><span>.<\/span><span>onmessage<\/span><span> <\/span><span>=<\/span><span> <\/span><span>function<\/span><span>(<\/span><span>e<\/span><span>){<\/span><\/div><div><span>            <\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'子onmessage'<\/span><span>,<\/span><span>e<\/span><span>.<\/span><span>data<\/span><span>)<\/span><\/div><div><span>            <\/span><span>if<\/span><span>(<\/span><span>self<\/span><span>.<\/span><span>whilteList<\/span><span>.<\/span><span>includes<\/span><span>(<\/span><span>e<\/span><span>.<\/span><span>origin<\/span><span>)){<\/span><span>self<\/span><span>.<\/span><span>msg<\/span><span> <\/span><span>=<\/span><span> <\/span><span>e<\/span><span>.<\/span><span>data<\/span><\/div><div><span>            }<\/span><\/div><div><span>            <\/span><span>\/\/给发送源回消息<\/span><\/div><div><span>            <\/span><span>if<\/span><span>(<\/span><span>window<\/span><span>.<\/span><span>location<\/span><span>.<\/span><span>href<\/span><span>.<\/span><span>indexOf<\/span><span>(<\/span><span>e<\/span><span>.<\/span><span>origin<\/span><span>)<\/span><span>&lt;<\/span><span>0<\/span><span>){&nbsp; &nbsp; &nbsp; &nbsp; \/\/ 为了防止给自己postMessage无限循环<\/span><\/div><div><span>                <\/span><span>e<\/span><span>.<\/span><span>source<\/span><span>.<\/span><span>window<\/span><span>.<\/span><span>postMessage<\/span><span>(<\/span><span>'nice to meet you'<\/span><span>,<\/span><span>e<\/span><span>.<\/span><span>origin<\/span><span>)<\/span><\/div><div><span>            }<\/span>}<\/div><p>也可以用window.open(url)来代替iframe<\/p><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>let<\/span><span> <\/span><span>d<\/span><span> <\/span><span>=<\/span><span> <\/span><span>window<\/span><span>.<\/span><span>open<\/span><span>(<\/span><span>'http:\/\/localhost:8081'<\/span><span>,<\/span><span>'_blank'<\/span><span>,<\/span><span>'width=300,height=600,left=100,top=0'<\/span><span>)<\/span><\/div><div><span>window<\/span><span>.<\/span><span>openTimer<\/span><span> <\/span><span>=<\/span><span> <\/span><span>setInterval<\/span><span>(<\/span><span>function<\/span><span>(){<\/span><\/div><div><span>                <\/span><span>d<\/span><span>.<\/span><span>postMessage<\/span><span>(<\/span><span>'hello'<\/span><span>,<\/span><span>'http:\/\/localhost:8081'<\/span><span>)<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>},<\/span><span>500<\/span><span>)<\/span><\/div><div><span>\/\/并设个监听，回调后clearInterval(<\/span>window.openTimer)<\/div><p><br><\/p><p><br><\/p><h2><span style=\"font-weight: bold;\">1. 通信<\/span><\/h2>前后端如何通信？<br>最常见的三种方式：<br>Ajax \/\/ 同源<br>WebSocket \/\/ 不受同源限制<br>CORS \/\/ 支持跨源也支持同源<br>跨域通信的几种方式:<br>JSONP \/\/可以支持老浏览器<br>Hash \/\/#后面的东西，这部分改变页面不刷新<br>postMessage \/\/H5的新特性，支持客户端与客户端之间的通信<br>WebSocket<br>CORS \/\/至少IE10以上<div><span style=\"color: rgb(194, 79, 74);\">CORS&nbsp;&nbsp;<\/span><\/div><div><div><div><p><strong>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现<\/strong>。<\/p>\n<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。<\/p>\n<p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。<\/p>\n<p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求<\/strong>和<strong>复杂请求<\/strong>。<\/p>\n<h4>1) 简单请求<\/h4>\n<p>只要同时满足以下两大条件，就属于简单请求<\/p>\n<p>条件1：使用下列方法之一：<\/p>\n<ul>\n<li>GET<\/li>\n<li>HEAD<\/li>\n<li>POST<\/li>\n<\/ul>\n<p>条件2：Content-Type 的值仅限于下列三者之一：<\/p>\n<ul>\n<li>text\/plain<\/li>\n<li>multipart\/form-data<\/li>\n<li>application\/x-www-form-urlencoded<\/li>\n<\/ul>\n<p>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。<\/p>\n<h4>2) 复杂请求<\/h4>\n<p>不符合以上条件的请求就肯定是复杂请求了。\n复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。<\/p><\/div><br><\/div><p><\/p><p><strong>hash应用<\/strong><br>当前页面A通过iframe或frame嵌入跨域的页面B<br>在A页面写:<br>var data = 'hello'<br>var B = document.getElementsByTagName('iframe')[0];<br>B.src = B.src + '#' + data<br>在B页面写：<br>window.onhashchange = function(){<br>var data = window.location.hash;<br>console.log(data) \/\/ 'hello'<br>}<\/p><p><br><strong>Websocket应用<\/strong>&gt; 参考http:\/\/www.ruanyifeng.com\/blog\/2017\/05\/websocket.html<br><strong>CORS应用<\/strong>&gt; 参考http:\/\/www.ruanyifeng.com\/blog\/2016\/04\/cors.html<\/p><p><br><\/p><ul><li><\/li><ol start=\"2\"><li>快速算法：<a href=\"https:\/\/segmentfault.com\/a\/1190000009426421\" target=\"_blank\">https:\/\/segmentfault.com\/a\/1190000009426421<\/a><br>选择算法：<a href=\"https:\/\/segmentfault.com\/a\/1190000009366805\" target=\"_blank\">https:\/\/segmentfault.com\/a\/1190000009366805<\/a><br>希尔算法：<a href=\"https:\/\/segmentfault.com\/a\/1190000009461832\" target=\"_blank\">https:\/\/segmentfault.com\/a\/1190000009461832<\/a><br><strong>堆栈<\/strong><br>堆栈：<a href=\"https:\/\/juejin.im\/entry\/58759e79128fe1006b48cdfd\" target=\"_blank\">https:\/\/juejin.im\/entry\/58759e79128fe1006b48cdfd<\/a><br><strong>队列<\/strong><br>队列：<a href=\"https:\/\/juejin.im\/entry\/58759e79128fe1006b48cdfd\" target=\"_blank\">https:\/\/juejin.im\/entry\/58759e79128fe1006b48cdfd<\/a><br><strong>链表<\/strong><br>链表：<a href=\"https:\/\/juejin.im\/entry\/58759e79128fe1006b48cdfd\" target=\"_blank\">https:\/\/juejin.im\/entry\/58759e79128fe1006b48cdfd<\/a><br><strong>递归<\/strong><br>递归：<a href=\"https:\/\/segmentfault.com\/a\/1190000009857470\" target=\"_blank\">https:\/\/segmentfault.com\/a\/1190000009857470<\/a><\/li><\/ol><\/ul><p><br><\/p><h2><span style=\"font-weight: bold;\">2.&nbsp;<\/span>js面试点<\/h2><h2><span style=\"font-weight: bold;\">&nbsp;&nbsp;<\/span><\/h2><p>1. 运行机制<br> **1.1**<br> console.log(1);<br> setTimeout(function(){<br>     console.log(2);<br> },0);<br> console.log(3); <br> \/\/ 打印  1  3  2<br> setTimeout setInterval是异步任务<br> js是单线程（同一时间只能处理一个任务），按队列顺序先执行同步任务，再执行异步任务<br> **1.2**<br> console.log(1);<br> while(true){<br> }<br> console.log(2);<br> \/\/ 打印 1<br> 因为while是同步任务，没执行完不会进行下个任务。只要为trusy则会一直循环下去<br>  **1.3**<br>  for(let i =0;i&lt;4;i++){<br>   setTimeout(function(){<br>      console.log(i)<br>   },1000*i)<br>   }<br>   \/\/ 每间隔1s打印出： 4 4 4 4<br>   for每次循环执行到setTimeout的时候，先把setTimeout丢给定时器（timer模块），for循环体执行完毕后，这时定时器才会按照每个setTimeout规定的时间顺序放到异步队列中，同步到运行栈没任务后就会去定时器那里找有没有任务，有的话就丢到运行栈中执行，这叫事件循环（EventLoop）<br> **1.4**<br> function getArgs(){<br>    return arguments     <br>    \/\/ 类数组对象 类似于Array，但除了length属性和索引元素之外没有任何Array属性。可以用ES6的Array.from(arguments)转为真正的数组(或ES5的Array.prototype.slice.call(arguments))<br>    }<br>    var aObj = getArgs(1,2,undefined,4)<br>    console.log(aObj.length)           <br>    \/\/ 打印 4<br>    console.log(aObj.callee)<br>    \/\/ 打印 getArgs函数<br>    console.log(Object.prototype.toString.call(aObj))<br>    \/\/ 打印 [Object Arguments]<br> **1.5**<br><span style=\"color: rgb(194, 79, 74);\"> var length = 10;<br> function fn(){<br>&nbsp; &nbsp; &nbsp;console.log(this.length)<br> }<br> var obj = {<br>&nbsp; &nbsp; &nbsp;length:5,<br>&nbsp; &nbsp; &nbsp;callApi:function(fn){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fn();<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arguments[0]()<br>&nbsp; &nbsp; &nbsp; }<br> }<\/span><br> obj.callApi(fn,2)   \/\/ 10 2<br> \/\/fn作为参数传递进来，然后执行fn()，这相当于在外面的fn执行，而外面的this指向window，故拿到window作用域的length，即为10，而执行arguments[0]**()**的时候this指向参数，有两个参数，所以输出2<br> **1.6**<br> **1.6.1**<br> function fn(a){<br>     console.log(a);<br>     var a = 2;<br>     function a(){}<br>     console.log(a);<br> }<br> fn(1)  \/\/ 打印 function a(){}    2<br> \/\/var和function会提前声明的，当两个同时存在时，function优先级更高，意思是函数声明会覆盖掉变量声明<br> **1.6.2**<br> function fn(a){<br>     console.log(a);<br>     var a = 2;<br>     console.log(a);<br> }<br> fn(1)  \/\/ 打印1 2<br> 相当于<br> function fn(a){<br>     var a;<br>     console.log(a);<br>     a = 2;<br>     console.log(a);<br> }<br> fn(1)<br> \/\/ 即使提前声明，但有参数对应会显示出来<br> **1.7**<br> var f = true;<br> if (f === true) {<br>  var a = 10;<br>  }<br>  function fn() {<br>      var b = 20;<br>      c = 30;<br>  }<br>  fn();<br>  console.log(a);<br>  console.log(b);<br>  console.log(c);<br>  \/\/ 10 报错 30<br>  \/\/ 只有function(){}内新声明的才能是局部变量，在window下while{...}、if{...}、for(..) 之内的都是全局变量<br>  **1.8**<br>  if('a' in window) {<br>  var a = 10;<br>  }<br>  alert(a);<br>  \/\/ var会提前声明，相当于：<br>  var a;<br>  if('a' in window){<br>     a = 10;<br>  }<br>  alert(a);<br>  **1.9**<br><span style=\"color: rgb(194, 79, 74);\">  var a = 10;<br>  a.pro = 10;<br>  console.log(a.pro + a);<\/span><br>  \/\/ 打印 NaN<br>  var s = 'hello';<br>  s.pro = 'world';<br>  console.log(s.pro + s);<br>  \/\/ 打印 undefinedeworld<br>  <br>  \/\/给基本类型数据加属性不报错，但是引用的话返回undefined，10+undefined返回NaN，而undefined和string相加时转变成了字符串。<br>  **2.0**<br>  什么是闭包？ <span style=\"color: rgb(194, 79, 74);\">【闭包是指有权访问另一个函数作用域中的变量的函数&nbsp;&nbsp;】<\/span>---- 《JavaScript 高级程序设计》&nbsp;&nbsp;<\/p><p>  我们先看一个闭包的例子：<br>```javascript<br>function foo() {<br>    let a = 2;<br><br>    function bar() {<br>        console.log( a );<br>    }<br><br>    return bar;<br>}<br><br>let baz = foo();<br><br>baz();<br>```<br>  <br>  （闭包一定是函数对象，当函数一定是在其定义的作用域外进行的访问时，才产生闭包。我们将bar的引用指向baz，正是这种引用赋值，阻止了垃圾回收机制将foo进行回收，从而导致bar的整条作用域链都被保存下来。导致内存泄漏。因此当变量对象不再适用时，我们要将其释放。后面加上baz = null; \/\/如果baz不再使用，将其指向的对象释放）<br>  <br>```html<br>&lt;button class=\"link\"&gt;1&lt;\/button&gt;<br>&lt;button class=\"link\"&gt;2&lt;\/button&gt;<br>&lt;button class=\"link\"&gt;3&lt;\/button&gt;<br>&lt;button class=\"link\"&gt;4&lt;\/button&gt;<br>```<br><br>  <br>```javascript<br>var links = document.querySelectorAll('.link')<br>  <br>  for(var i = 0;i&lt;links.length;i++){<br>      links[i].index = i;<br>      links[i].onclick = function(){<br>            console.log(this.index)<br>      }<br>  }<br>```<br><br>  \/\/ 打印 1 2 3 4        能如期打印出来，但这种方法不提倡，会污染dom结构<br>  \/\/采用闭包方法<br>  <br>```javascript<br>var links = document.querySelectorAll('.link')<br>  <br>  for(var i = 0;i&lt;links.length;i++){<br>      links[i].index = i;<br>      (function(i){<br>            links[i].onclick = function(){<br>                console.log(i)<br>            }<br>      })(i)<br>  }<br>```<br>   <br>2. 页面性能<br>**2.1** 资源压缩合并，减少HTTP请求<br>**2.2** CDN（Content Delivery Network内容分发网路）网络快速到达服务器<br>**2.3** DNS预解析（Domain Name System）<br>  &lt; meta http-equiv=\"x-dns-prefetch-control\" content=\"on\"&gt;<br>  一般https协议是默认关闭dns预解析的，上面这段代码强制打开<br>  &lt; link rel=\"dns-prefetch\" href=\"\/\/cdn.www.sojson.com\"&gt;<br>  预解析技术，当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行DNS的解析，减少用户等待时间，提高用户体验。(尤其你当前页面涉及多个域名的时候，预解析是非常明显的)\/\/开始是为了适配https和http  <br>  **2.4**非核心代码异步加载<br>  异步加载的方式<br>  2.4.1 动态脚本加载(document.createElement('script')~)<br>  2.4.2 defer是HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行<br>  2.4.3 async是加载后立即执行，如果是多个，执行顺序和加载顺序无关<br>  \/\/有多种执行外部脚本的方法：<br>  如果 async=\"async\"：脚本相对于页面的其余部分异步地执行（当页面继续进行  解析时，脚本将被执行）<br>  如果不使用 async 且 defer=\"defer\"：脚本将在页面完成解析时执行<br>  如果既不使用 async 也不使用 defer：在浏览器继续解析页面之前，立即读取并执行脚本<br>  2.4.4 缓存<br>  缓存的分类：<br>  （强缓存）<br>  expires:Thu, 19 Apr 2018 06:52:21 GMT<br>  cache-control:public, max-age=1209600<br>  （协商缓存）<br>  Last-Modified\/If-Modified-Since Thu,31 Dec 2037 23:59:59 GMT<br>  Etag\/If-None-Match<br>**2.5**创建文档碎片(document.createDocumentFragment）<br>对于多条数据的插入DOM的性能优化<\/p><p><span style=\"color: rgb(194, 79, 74);\">我们用原生JS进行开发时，经常会用到两种更新DOM节点的方法：innerHTML 和 appendChild() 。其中 innerHTML 会完全替换掉原先的节点内容，如果我们是想向元素追加子节点的话，那么 innerHTML 显然满足不了需求。 转而我们就会想到 appendChild() 方法。appendChild方法接收的参数类型为单个的节点类型对象。因此当我们要添加多个子节点时，只能通过循环来实现。<\/span>&nbsp;<span style=\"color: rgb(194, 79, 74);\">我们都知道，对DOM的操作次数越多，性能消耗也就越大。像这样的循环添加节点，循环了多少次，就对DOM操作了多少次，性能消耗明显是不划算的。我们就会想，能否把要插入的节点进行打包，然后一次性添加呢？如果可以的话，那就只对DOM做了一次操作了。要实现打包，这就要用到我们的主角 createDocumentFragment。&nbsp;&nbsp;<br><\/span>\/\/先创建文档碎片<\/p><p>var oFragmeng = document.createDocumentFragment();&nbsp;<\/p><p>for(var i=0;i&lt;10000;i++)<br>{ <br>    var op = document.createElement(\"span\"); <br>    var oText = document.createTextNode(i); <br>    op.appendChild(oText); <br>    \/\/先附加在文档碎片中<br>    oFragmeng.appendChild(op);  <br>} <br>\/\/最后一次性添加到document中<br>document.body.appendChild(oFragmeng);&nbsp;<\/p><p><br><\/p><h2>3. 面试小记<\/h2><p><br><\/p><p>1. 跨域<br>  由于同源策略的限制，XmlHttpRequest（XHR）只能请求当前源（域名，协议，端口）的资源。三项任意一个不同都算跨域。（只有XHR有跨域问题，但其他请求方式没有，例如img的src的请求type是json，而不是xhr，后面讲的jsonp的请求type是script，所以可以跨域）<br>  跨域报错主要原因还是浏览器的问题（出于安全会做校验），这不是后台的问题。所以可以通过客户端用dos命令加取消安全限制的命令打开（就不会安全报错）。这种客户端操作不是我们要解决跨域的方法。<br>  跨域解决方案：<br>  i. jsonp（不能很好满足目前的开发，越来越少人用）<br>     jsonp = json + padding，顾名思义，就是把json填充到一个盒子里<br>     jsonp就是动态生成script，url加上参数（参数名要和后台约定好，参数值就为函数名），后台要判断参数名是否存在而返回js或json代码。把json作为参数放进里面。前台在动态生成的script运行后处理返回的js数据。<br>     ajax({<br>        url: 'xxx',<br>        dataType: 'jsonp',    \/\/ 请求模式<br>        jsonp: 'callback2',   \/\/ 与后台约定好的参数名，默认就为callback<br>        cache: true,          \/\/ 默认为false<br>        success: function(json){<br>           console.log(json)<br>        }<br>     })<br>     jsonp缺点: 需要服务器改动代码支持，如果自己的代码还好，调用别的公司的接口那就尴尬了。还有只支持GET方法（script标签的作用），公司业务还有其他常用的POST,PUT,DELETE没法实现。因为不是XHR请求，所以无法使用XHR的新特性。<br>2. HTTP协议<br>  参考https:\/\/www.cnblogs.com\/ranyonsue\/p\/5984001.html（关于HTTP协议，一篇就够了）<br>HTTP方法：<br>GET 获取资源<br>POST 传输资源<br>HEAD 获取报文首部<br>PUT 更新资源       （少见）<br>DELETE 删除资源     （少见）<br>GET与POST的区别：<br>GET在浏览器回退时不会再次提交请求，但POST会<br>GET产生的URL地址可以被收藏，而POST不可以<br>GET请求会被浏览器主动缓存，而POST不会，除非手动设置（所以要经常清除缓存）<br>GET请求参数会被完整保留在浏览器历史记录里，而POST不会（很多公司为了防止XSS攻击把GET请求方式改为POST）<br>GET请求在URL中传输的参数是有长度限制的，POST没限制<br>对参数的数据类型，GET只接受ASCII字符，POST没限制<br>GET比POST不安全，因为参数暴露在URL上，POST参数放在request body中<br><br>HTTP协议是无连接协议，即连接一次就断开。在1.1版本中新增了个keep-alive功能，这功能可以使客户端到服务器端的连接持续有效。当出现对服务器的后继请求时，这功能避免了建立或重新建立连接<br><br>管线化<br>正常是： 请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 -&gt; 响应3<br>管线化： 请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3<br><br>3. 错误监控<br>3.0 前端错误的两大分类：即时运行错误(代码错误)和资源加载错误<br>3.1 即时运行错误的捕获方式<br>try{ \/\/运行的js代码 }catch(err){console.log(err.message)}<br>window.onerror = function(msg, url, line, col, error) {<br>  \/\/ 直接将错误打印到控制台<br>  console.log(arguments)<br>  \/\/ 方便在未打开控制台的时候，记录错误对象<br>  window.demoError = arguments<br>}<br>3.2 资源加载错误<br>object.onerror（img，script等）（不是冒泡错误，所以window.onerror拿不到资源错误，但可以通过捕获到方式拿到错误）<br>例如window.addEventListener('error',function(e){console.log(e)},true)<br>能捕获到如&lt;script src='\/\/baidu.com\/test\/js'&gt;的资源加载错误。<br>使用 window.performance.getEntries() 提供了一组精确的数据（加载时长等），经过简单的计算就能得出一些网页性能数据<br>3.3 跨域的js运行错误<br>可以捕获到：在客户端script标签增加crossorigin属性<br>设置js资源响应头Access-Control-Allow-Origin:×或指定的域名<br>3.4 上报错误<br>3.4.1采用Ajax通信的方式上报<br>3.4.2采用Image方式上报<br>&lt;script&gt;<br>(new Image()).src= '要上传的url'<br>&lt;\/script&gt;<\/p><p><br><\/p><p><br><\/p><h2>4. 2018微记<\/h2><p><br><\/p><p>1.  Vue Project Structure的网址配置：http:\/\/vuejs-templates.github.io\/webpack\/<br>2.  ES6这些就够了 https:\/\/www.jianshu.com\/p\/287e0bb867ae<br>3.  cross-env 插件<br>\"scripts\": {<br>\"build\": \"cross-env NODE_ENV=production webpack --config webpack.config.js\"<br>\"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js\"<br>}<br>4.  Codewars(https:\/\/www.codewars.com\/trainer\/javascript)<br>user: ericlili<br>5.  深浅拷贝(简单来说，浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。)<br>浅拷贝直接用  for in（加hasOwnProperty只拷贝第一层，不加若多层中含有数组for in会影响）<br>深拷贝用  JSON.parse(JSON.stringify(要拷贝的对象))  [兼容IE7及以下]：可以通过为IE7以及IE7以下版本的IE浏览器引入json2.js，使用json2.js来解决JSON的兼容性问题。json2.js的github地址为：https:\/\/github.com\/douglascrockford\/JSON-js<br>弊端：  不能拷贝NaN和function或RegExp等特殊对象<br>例如：  var obj = {a:NaN,b:null,c:undefined}<br>       var obj1 = JSON.parse(JSON.stringify(obj))  \/\/  {a:null,b:null}<br>       以下是个通用版的深拷贝函数<br>```html<br>\/**<br>* deep clone<br>* @param  {[type]} parent object 需要进行克隆的对象<br>* @return {[type]}        深克隆后的对象<br>*\/<br>const clone = parent =&gt; {<br>  \/\/ 维护两个储存循环引用的数组<br>  const parents = [];<br>  const children = [];<br><br>  const _clone = parent =&gt; {<br>    if (parent === null) return null;<br>    if (typeof parent !== 'object') return parent;<br><br>    let child, proto;<br><br>    if (isType(parent, 'Array')) {<br>      \/\/ 对数组做特殊处理<br>      child = [];<br>    } else if (isType(parent, 'RegExp')) {<br>      \/\/ 对正则对象做特殊处理<br>      child = new RegExp(parent.source, getRegExp(parent));<br>      if (parent.lastIndex) child.lastIndex = parent.lastIndex;<br>    } else if (isType(parent, 'Date')) {<br>      \/\/ 对Date对象做特殊处理<br>      child = new Date(parent.getTime());<br>    } else {<br>      \/\/ 处理对象原型<br>      proto = Object.getPrototypeOf(parent);<br>      \/\/ 利用Object.create切断原型链<br>      child = Object.create(proto);<br>    }<br><br>    \/\/ 处理循环引用<br>    const index = parents.indexOf(parent);<br><br>    if (index != -1) {<br>      \/\/ 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象<br>      return children[index];<br>    }<br>    parents.push(parent);<br>    children.push(child);<br><br>    for (let i in parent) {<br>      \/\/ 递归<br>      child[i] = _clone(parent[i]);<br>    }<br><br>    return child;<br>  };<br>  return _clone(parent);<br>};<br>const isType = (obj, type) =&gt; {<br>  if (typeof obj !== 'object') return false;<br>  const typeString = Object.prototype.toString.call(obj);<br>  let flag;<br>  switch (type) {<br>    case 'Array':<br>      flag = typeString === '[object Array]';<br>      break;<br>    case 'Date':<br>      flag = typeString === '[object Date]';<br>      break;<br>    case 'RegExp':<br>      flag = typeString === '[object RegExp]';<br>      break;<br>    default:<br>      flag = false;<br>  }<br>  return flag;<br>};<br><br>作者：寻找海蓝96<br>链接：https:\/\/juejin.im\/post\/5abb55ee6fb9a028e33b7e0a<br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>```<br><br>6.  标签知识点<br>  双核浏览器（如360和腾讯浏览器）加上&lt;meta name=\"renderer\" content=\"webkit\"&gt;使其首要使用webkit核渲染<br>7.  DOM知识点<br>  **i. 描述DOM捕获的具体流程：**<br>     window -&gt; document -&gt; html -&gt; body -&gt; ... -&gt; 目标元素 <br>     window的dom元素： window<br>     document的dom元素： document<br>     html的dom元素： document.documentElement<br>     body的dom元素： document.body<br>     目标dom元素： document.getElementById(id)<br>  **ii. event对象的常见应用：** <br>  event.preventDefault()    \/\/阻止默认事件（例如给a标签添加可以阻止跳转）  <br>  event.stopPropagation()   \/\/阻止冒泡<br>  event.stopImmediatePropagation()     \/\/给一个按钮同时加个A和B函数，在A函数后面添加这个，可以停止当前节点以及所有后续节点的事件处理程序的运行，即不会再执行B函数<br>  **iii. 自定义事件：**<br>  var ev = new Event('test');<br>  ev.addEventListener('test',function(){<br>      console.log('hello')<br>  })<br>  setTimeout(function(){<br>     ev.dispatchEvent(ev);    \/\/ 触发test事件，输出hello<br>  },1000)<br>8.  原型<\/p><p><span style=\"color: rgb(194, 79, 74);\">【鑫哥讲原型】对象都有_proto_属性，指向原型，原型上有个constructor，是构造函数，构造函数有个prototype，指向原型。原型上也有_proto_属性，指向下一级的原型，这样形成原型链，最后指向Object的原型，Object的原型的_proto_指向null<\/span><\/p><p><img src=\"https:\/\/www.aiheart.top\/photo\/prototype.png\" style=\"max-width:100%;\"><br><span style=\"color: rgb(194, 79, 74);\">##A.__proto__ === Function.prototype&nbsp; &nbsp; &nbsp;Object.__proto__ === Function.prototype<\/span><\/p><p>#为什么构造函数的_proto_没指向Function呢？下图告诉你：<\/p><p><img src=\"https:\/\/user-gold-cdn.xitu.io\/2016\/11\/29\/ce8bff088a74cda6789a11f6075b7411?imageView2\/0\/w\/1280\/h\/960\/format\/webp\/ignore-error\/1\" style=\"max-width:100%;\"><br><\/p><p><img src=\"https:\/\/files.jb51.net\/file_images\/article\/201702\/2017020914060516.jpg\" style=\"max-width:100%;\"><br><\/p><p>#易错题<\/p><p>Function.prototype.a = 1<\/p><p>Object.prototype.b = 2<\/p><p>function Foo(){}<\/p><p>let f = new Foo()<\/p><p>console.log(f.a,f.b)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; undefined&nbsp; &nbsp; &nbsp; 2<\/p><p><br><\/p><p>  \/\/构造函数<br>  var Make = function(name){<br>      this.name = name<br>  }<br>  \/\/构造函数的原型对象<br>  Make.prototype.say = function(){<br>      console.log('hello')<br>  }<br>  Make.prototype.constructor === Make    \/\/ true<br>  \/\/实例化对象<br>  var boy = Make('eric')<br>  boy.name    \/\/ eric<br>  boy.say()   \/\/ hello<br>  boy.**__proto__** === Make.prototype  \/\/ true<br>  (然后Make.prototype又有**__proto__**，循环下去就叫做原型链。（一般顶端处）此处Make.prototype.**__proto__** === Object.prototype, Object.prototype.**__proto__** === null)<br>  所有对象都有**__proto__**，所有函数都有prototype和**__proto__**（因为函数也是对象）<br>  上述的Make.**__proto__** === Function.prototype （Make的构造函数为Function）<br>  判断是否为某实例函数的构造函数一般有两种方法：<br>  **i.应用instanceof**<br>  eric instanceof Make    \/\/ true            (eric.**__proto__** === Make.prototype)<br>  eric instanceof Object     \/\/ true         (eric.**__proto__**.**__proto__** === Object.prototype)<br>  只要在原型链上的构造函数，用instanceof都会返true<br>  所以应该用以下的方法比较严谨<br>  **ii.应用constructor**<br>  eric.**__proto__**.constructor === Make    \/\/ true<br>  eric.**__proto__**.constructor === Object  \/\/ false<br>  \/\/类的声明<br>  \/\/ES5（通过构造函数声明类）<br>  function Animal1(){<br>      this.name = 'animal1'<br>  }<br>  \/\/ES6 <br>  class Animal2{<br>      constructor(){<br>         this.name = 'animal2'<br>      }<br>  }<br>  \/\/实例化<br>  都是通过new运算符<br>  console.log(new Animal1(),new Animal2())<br>  \/\/继承<br><span style=\"color: rgb(194, 79, 74);\">  **i 第一种**<\/span><br>  function Parent(){<br>     this.color = 'black'<br>  }<br>  Parent.prototype.skill = 'learn'<br>  function Child(){<br><span style=\"color: rgb(0, 0, 0); font-weight: bold;\">     Parent.call(this)<\/span>        \/\/改变this指向到Child的实例上去<br>     this.type = 'child'<br>  }<br>  Child.color           \/\/ 'black'<br>  Child.skill           \/\/ undefined  <br>  以上继承缺点就是子类只能继承父类构造函数的属性，但父类原型属性没继承到<br><span style=\"color: rgb(194, 79, 74);\">  **ii 第二种**<\/span><br>  function Parent(){<br>      this.color = 'black'<br>      this.arr = [1,2,3]<br>  }<br>  Parent.prototype.skill = 'learn'<br>  function Child(){<br>     this.type = 'child'<br>  }<br><span style=\"color: rgb(0, 0, 0); font-weight: bold;\">  Child.prototype = new Parent()<\/span>&nbsp; &nbsp; &nbsp; <span style=\"color: rgb(194, 79, 74);\">\/\/这下子父类原型属性就能继承了哈哈哈<\/span>&nbsp;&nbsp;<br>  Child.color           \/\/ 'black'<br>  Child.skill           \/\/ 'learn'<br>  这种继承也有缺点：<br>  var c1 = new Child()<br>  var c2 = new Child()<br>  c1.arr.push(4)<br>  c1.arr              \/\/ [1,2,3,4]<br>  c2.arr              \/\/ [1,2,3,4]<br>  当多个Child实例化后，改变任意一个对象的继承属性，其他对象的继承属性也跟着变化，继承的属性是共用的<br>  c1.____proto____ === c2.__proto__<br>  c1.skill = 'read'    \/\/ 这相当于给实例化对象直接赋值，不会改动原型对象属性<br>  c1.skill            \/\/ 'read'<br>  c2.skill            \/\/ 'learn'<br><span style=\"color: rgb(194, 79, 74);\">  **iii 第三种：第一种和第二种的结合方式（结合优点，弥补缺点）**【组合继承】<\/span>&nbsp;缺点：会调用两次父类构造函数的代码<br>  function Parent(){<br>      this.color = 'black'<br>      this.arr = [1,2,3]<br>  }<br>  Parent.prototype.skill = 'learn'<br>  function Child(){<br><span style=\"color: rgb(0, 0, 0); font-weight: bold;\">     Parent.call(this)<\/span><br>     this.type = 'child'<br>  }<br><span style=\"color: rgb(0, 0, 0); font-weight: bold;\">  Child.prototype = new Parent()<\/span><\/p><p><span style=\"color: rgb(0, 0, 0); font-weight: 700;\">Child.prototype.constructor = Child \/\/&nbsp;<\/span>因重写原型而失去constructor属性，需要重写\n\nconstructor&nbsp;&nbsp;<span style=\"color: rgb(0, 0, 0); font-weight: 700;\"><br><\/span>  var c1 = new Child()<br>  var c2 = new Child()<br>  c1.arr.push(4)<br>  c1.arr              \/\/ [1,2,3,4]<br>  c2.arr              \/\/ [1,2,3]<br>  这种写法Parent构造函数被执行两次，以下是优化写法<br><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">  **iv 优化第三种（<\/span><span style=\"color: rgb(194, 79, 74);\">最理想的继承方式：寄生组合式继承<\/span><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">）**&nbsp;<\/span><br>  function Parent(){<br>      this.color = 'black'<br>      this.arr = [1,2,3]<br>  }<br>  Parent.prototype.skill = 'learn'<br>  function Child(){<br><span style=\"color: rgb(0, 0, 0); font-weight: bold;\">     Parent.call(this)<\/span><br>     this.type = 'child'<br>  }<\/p><p><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">Child.prototype=Object.create(Parent.prototype)&nbsp;&nbsp;<\/span><\/p><p><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">Child.prototype.constructor= Child&nbsp;<\/span><\/p><p><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">Child.__proto__ = Parent&nbsp;<\/span><\/p><p><span style=\"color: rgb(70, 172, 200);\">或者：<br><span style=\"font-weight: bold;\">  Child.prototype.__proto__ = Parent.prototype<\/span><\/span><\/p><p><span style=\"font-weight: 700; color: rgb(70, 172, 200);\">Child.__proto__ = Parent<\/span><\/p><p><span style=\"color: rgb(139, 170, 74);\">或者：<br>Object.setPrototypeOf(Child.prototype,Parent.prototype)<\/span><\/p><p><span style=\"color: rgb(139, 170, 74);\">Object.setPrototypeOf(Child,Parent)&nbsp;<\/span>&nbsp;<br><\/p><p>  var c1 = new Child()<br>  var c2 = new Child()<br>  c1.arr.push(4)<br>  c1.arr              \/\/ [1,2,3,4]<br>  c2.arr              \/\/ [1,2,3]<br>  这种写法Parent构造函数只执行一次<\/p><p><a href=\"https:\/\/upload-images.jianshu.io\/upload_images\/13253432-d4c12f93076ede01.png?imageMogr2\/auto-orient\/strip|imageView2\/2\/w\/1080\/format\/webp\">https:\/\/upload-images.jianshu.io\/upload_images\/13253432-d4c12f93076ede01.png?imageMogr2\/auto-orient\/strip|imageView2\/2\/w\/1080\/format\/webp<\/a>&nbsp;<\/p><p><img src=\"https:\/\/upload-images.jianshu.io\/upload_images\/13253432-d4c12f93076ede01.png?imageMogr2\/auto-orient\/strip|imageView2\/2\/w\/1080\/format\/webp\" style=\"max-width: 100%;\">&nbsp;<br><\/p><h2><span style=\"font-weight: bold;\">#es5,es6继承除了写法还有啥区别？<\/span><\/h2><div><span style=\"font-weight: bold;\">#函数声明提升，但class不会<\/span><\/div><p>let f = new Foo()<br>function Foo(){<br>&nbsp; &nbsp; &nbsp;this.value = 'foo'<br>}<\/p><p>\/\/ tested&nbsp; ok<\/p><p>let g = new GG()<br>class GG{<br>&nbsp; &nbsp; &nbsp;constructor(){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.value = 'gg'<br>&nbsp; &nbsp; &nbsp;}<br>}<\/p><p>\/\/ tested&nbsp; error<br><\/p><p><span style=\"font-weight: bold;\">#class开启严格模式<\/span><br><\/p><p>function Foo(){<br>&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color: rgb(194, 79, 74);\">value = 'foo'<\/span><br>}<br>let f = new Foo()<br><\/p><p>\/\/ tested&nbsp; ok&nbsp;&nbsp;<\/p><p>class GG{<br>&nbsp; &nbsp; &nbsp;constructor(){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color: rgb(194, 79, 74);\">value = 'gg'<\/span><br>&nbsp; &nbsp; &nbsp;}<br>}<\/p><p>let g = new GG()&nbsp;&nbsp;<br><\/p><p>\/\/ tested&nbsp; error&nbsp; 【Uncaught ReferenceError: value is not defined】<\/p><p><span style=\"font-weight: bold;\">#<code style=\"font-size: 12px;\">class<\/code>&nbsp;的所有方法（包括静态方法和实例方法）都是不可枚举的。<\/span><br><\/p><pre>\/\/ 引用一个未声明的变量\nfunction Bar() {\n  this.bar = 42;\n}\nBar.answer = function() {\n  return 42;\n};\nBar.prototype.print = function() {\n  console.log(this.bar);\n};\nconst barKeys = Object.keys(Bar); \/\/ ['answer']\nconst barProtoKeys = Object.keys(Bar.prototype); \/\/ ['print']\n\nclass Foo {\n  constructor() {\n    this.foo = 42;\n  }\n  static answer() {\n    return 42;\n  }\n  print() {\n    console.log(this.foo);\n  }\n}\nconst fooKeys = Object.keys(Foo); \/\/ []\nconst fooProtoKeys = Object.keys(Foo.prototype); \/\/ []<\/pre><\/div>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/1\/22 23:15:13",
"updatetime":"2020\/5\/18 10:56:38"
},
{
"id":6,
"title":"SSR服务端渲染走走看咯【with NUXT】",
"content":"<p><span style=\"font-weight: bold;\">#VUE SSR<\/span><\/p><p>所谓服务端渲染，指的是把vue组件在服务端端渲染为组装好的html字符串，然后将他们直接发送到浏览器，最后需要将这些静态标记“激活”为客户端上完全可交互的应用程序。<\/p><p><br><\/p><p>服务端渲染缺点：<\/p><p>1.首先就是开发成本比较高，比如某些声明周期钩子函数（如beforeCreate、created）能同时运行在服务端和客户端，因此第三方库要做特殊处理，才能在服务器渲染应用程序中运行。<\/p><p>2.由于服务端渲染要用Nodejs做中间层，所以部署项目时，需要处于Node.js server运行环境。在高流量环境下，还要做好服务器负载和缓存策略<\/p><p><br><\/p><p><span style=\"font-weight: bold;\"><br><\/span><\/p><p><span style=\"font-weight: bold;\"><br><\/span><\/p><p><span style=\"font-weight: bold;\"><br><\/span><\/p><p><span style=\"font-weight: bold;\"><span style=\"text-decoration-line: underline;\"><\/span>#NUXT<\/span><\/p><h2>生命周期<\/h2><p>&nbsp; &nbsp; 1、nuxtServerInit (Store action)<\/p><p>&nbsp; &nbsp; 2、middleware 中间件<\/p><p>&nbsp; &nbsp; 3、validate 验证<\/p><p>&nbsp; &nbsp; 4、asyncData &amp; fetch<\/p><p>&nbsp; &nbsp; 5、Render<\/p><div><div>export default {&nbsp;<\/div><div>&nbsp;  middleware () {}, \/\/服务端&nbsp;<\/div><div>&nbsp; validate () {}, \/\/ 服务端&nbsp;<\/div><div>&nbsp;  asyncData () {}, \/\/服务端&nbsp;<\/div><div>&nbsp;  fetch () {}, \/\/ store数据加载&nbsp;<\/div><div>&nbsp;  beforeCreate () {  \/\/ 服务端和客户端都会执行,没有window对象},&nbsp;<\/div><div>&nbsp;  created () { \/\/ 服务端和客户端都会执行,没有window对象&nbsp; },&nbsp;<\/div><div>&nbsp;  beforeMount () {},&nbsp;<\/div><div>&nbsp;\n  mounted () {} \/\/ 客户端<\/div><div>&nbsp;}<br><\/div><\/div><p>组件中使用axios：需要注意的是组件的fetch和asyncData里只能使用nuxtjs模板里的axios哦，如果使用我们自己引入的axios，是无法使用的。<br><\/p><p><strong>fetch、asyncData、validate<\/strong>&nbsp;只能在页面组件使用，也就是pages目录下的组件，而不是components目录下的组件，要有所区分。&nbsp;<\/p><h4>asyncData与fetch区别<\/h4><p>asyncData既可以充应用的状态树（store）数据，也可以设置组件的数据【可以return { a: 1 }等覆盖data】。<\/p><p>fetch 方法用于在渲染页面前填充应用的状态树（store）数据， 与 asyncData 方法类似，不同的是它不会设置组件的数据。<\/p><p>nuxt项目<\/p><div><div><h3>打包部署<\/h3>\n<p>一般来说，部署前可以先在本地打包，本地跑一下确认无误后再上传到服务器部署。命令：<\/p>\n<pre><code lang=\"bash\">\/\/ 打包\nnpm run build\n\/\/ 本地跑\nnpm start\n复制代码<\/code><\/pre><p>除node_modules，.git,.env，将其他的文件都上传到服务器，然后通过<code>pm2<\/code>进行管理,可以在项目根目录建一个<code>pm2.json<\/code>方便维护：<\/p>\n<pre><code lang=\"bash\">{\n  \"name\": \"nuxt-test\",\n  \"script\": \".\/server\/index.js\",\n  \"instances\": 2,\n  \"cwd\": \".\"\n}\n复制代码<\/code><\/pre><p>然后配置生产环境的环境变量，一般是直接用<code>.env.prod<\/code>的配置：<code>cp .\/.env.prod .\/.env<\/code>。\n首次部署或有新的依赖包，需要在服务器上<code>npm install<\/code>一次，然后就可以用<code>pm2<\/code>启动进程啦：<\/p>\n<pre><code lang=\"bash\">\/\/ 项目根目录下运行\npm2 start .\/pm2.json\n复制代码<\/code><\/pre><p>需要的话，可以设置开机自动启动pm2: <code>pm2 save &amp;&amp; pm2 startup<\/code>。\n需要注意的是，每次部署都得重启一下进程:<code>pm2 reload nuxt-test<\/code>。<\/p><\/div><br><\/div><p><br><\/p><p><br><\/p><p><br><\/p><ol><li><p>谷歌免费xml生成工具：&nbsp;<a href=\"https:\/\/www.xml-sitemaps.com\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">老弟来啦~<\/a><\/p>&lt;urlset xmlns=\"http:\/\/www.sitemaps.org\/schemas\/sitemap\/0.9\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/www.sitemaps.org\/schemas\/sitemap\/0.9 http:\/\/www.sitemaps.org\/schemas\/sitemap\/0.9\/sitemap.xsd\"&gt;&nbsp;<br>&lt;!-- created with Free Online Sitemap Generator www.xml-sitemaps.com --&gt;<br>&lt;url&gt;&lt;loc&gt;https:\/\/www.aiheart.top\/eblog\/#\/blog\/main&lt;\/loc&gt;<br>&lt;lastmod&gt;2019-01-22T15:12:36+00:00&lt;\/lastmod&gt;&lt;\/url&gt;<br>&lt;\/urlset&gt;<p>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;<\/p><\/li><li><p><span style=\"background-color: rgb(238, 236, 224);\">据说<a href=\"https:\/\/www.baidu.com\/s?wd=google&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd\" target=\"_blank\">google<\/a>已经支持爬取spa。&nbsp;&nbsp;<\/span><img src=\"http:\/\/img.t.sinajs.cn\/t4\/appstyle\/expression\/ext\/normal\/3c\/pcmoren_wu_org.png\" alt=\"[污]\" data-w-e=\"1\"><br><\/p><\/li><li><p>觉得还不错的关于nuxt的文章：<a href=\"https:\/\/www.jianshu.com\/p\/d90ca584b1f1?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">瞧一瞧~<\/a>&nbsp; &nbsp;&nbsp;<a href=\"https:\/\/surmon.me\/article\/48\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">某人的博客基于nuxt.js<\/a><\/p><\/li><li><p>SSR（动态seo）与预加载（静态seo）<\/p><\/li><\/ol>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/1\/24 10:07:17",
"updatetime":"2020\/5\/14 23:35:31"
},
{
"id":7,
"title":"provisional headers",
"content":"<h1 style=\"text-align: center;\">导致provisional headers are shown<\/h1><p>1.form里面的button默认为submit，和ajax一起请求会出现provisional headers are shown<br><br>2.ajax的timeout超时设置&nbsp;<a href=\"https:\/\/blog.csdn.net\/dandaoyi\/article\/details\/44462811\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/blog.csdn.net\/dandaoyi\/article\/details\/44462811<\/a><br><\/p><p>&nbsp; &nbsp;解决办法：&nbsp;&nbsp;<\/p><p>&nbsp; &nbsp;方法1 ： 将ajax请求改成 同步。<\/p><p>&nbsp; &nbsp;方法2： 去掉 timeout属性的设置。<\/p><p>&nbsp; &nbsp;&nbsp;<a href=\"https:\/\/blog.csdn.net\/u012302552\/article\/details\/79798302\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/blog.csdn.net\/u012302552\/article\/details\/79798302<\/a><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/1\/25 14:30:09",
"updatetime":"2019\/1\/25 14:44:28"
},
{
"id":8,
"title":"CDN 链接直接引用",
"content":"<p>1.&nbsp;\n\n<span style=\"color: rgb(194, 79, 74);\">jquery<\/span>&nbsp; &nbsp;&nbsp;<a href=\"https:\/\/www.bootcdn.cn\/jquery\/\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/www.bootcdn.cn\/jquery\/<\/a><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/1\/25 14:31:51",
"updatetime":"2019\/1\/25 15:07:53"
},
{
"id":9,
"title":"less实现随机下雪动画详解",
"content":"<p><a href=\"https:\/\/www.qdfuns.com\/article\/51116\/c66e5ac06e8ba769067923e6bc65d9c6.html\" target=\"_blank\">https:\/\/www.qdfuns.com\/article\/51116\/c66e5ac06e8ba769067923e6bc65d9c6.html<\/a><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/1\/28 15:38:36",
"updatetime":"2019\/1\/28 15:38:36"
},
{
"id":10,
"title":"seo技巧，还敢说你是前端？",
"content":"<p>这篇文章其实是我本人的总结，因为工作中做完了一个官方网站并成功上线，最后组长检查代码看到我的keyword等一系列信息都是空的，把我骂得狗血淋头。一言不合就作总结，总结一些简单但是我们能做的seo小技巧，送给想把网站做到极致的人。<\/p><p><strong>SEO要点：<\/strong><br>1.语义化html标签，用合适的标签嵌套合适的内容，不可过分依赖div，对浏览器更友善就能更容易被抓取。<br>2.重要的内容html代码放在前面，放在左边。搜索引擎爬虫是从左往右，从上到下进行抓取的，利用布局来实现重要的代码在上面<\/p><p>3.重要内容要写在html架构里面，蜘蛛不会抓取js的内容，<br>4.尽量减少使用iframe，因为蜘蛛不会抓取iframe的内容。<br>5.为图片img加上alt属性，加了alt就不必加title了，避免搜索引擎认为我们恶意优化。alt能让图片没加载时都能有文字提示。<br>6.需要强调的地方加上title，本页面内跳转a标签内也要加title。<br>7.重要的地方可以保留文字，有些地方必须用图，但是蜘蛛不会爬img，这时应该设置文本，再用缩进隐藏的方法去掉文字，例如logo的优化就是这样做的。注意隐藏不能用display：none，蜘蛛不会检索display：none的内容，应用这个方法的标签一般是logo，标题等重要信息<br>8.尽量做到js、css、html的分离，不要在html中写样式代码。<br>9.注释的东西能去掉应该去掉，对搜索引擎更加友好<br>10.css放在头部，js放在尾部，尽量使用外链或者工具对css和js进行压缩<br>11.减少http的请求，使页面更快加载。<br>12.使用本地缓存更快地访问网站，使用cdn网络，加快用户访问速度。<br>13.使用G-ZIP压缩，浏览速度更快，搜索引擎抓取信息量更大<\/p><p><strong>关键一点是头部的title，description，keyword的设置。<\/strong><br>1.title设置不宜过长，要简短，网站的名字与相关的小内容，一般为10-20个字。不能重复<br>2.keywords设置10个关键词，没个词不能太长，简短且符合你网站的特点，不能重复<br>3.description，50个字内描述你的网站<\/p><p><strong>description写原创的话，并包含2-3个关键词比较好<\/strong><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/1\/29 09:39:40",
"updatetime":"2019\/1\/29 09:39:40"
},
{
"id":11,
"title":"what does fox say?",
"content":"<p><img src=\"http:\/\/upload-images.jianshu.io\/upload_images\/12577968-62d2404c557a29d4.jpeg?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240\">&nbsp;&nbsp;<br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/1\/29 09:52:22",
"updatetime":"2019\/1\/29 09:52:22"
},
{
"id":12,
"title":"实用js写法(内含高逼格)",
"content":"<div><pre><code><p>\n<\/p><h2>深浅复制：<\/h2><p>Object.assign()浅拷贝<br>let obj = { name: '程序猿', age:{child: 12} }<br>let copy = Object.assign({}, obj); <br>copy.name = '单身狗' <br>copy.age.child = 24 <br>console.log(obj) \/\/ { name:'程序猿', age:{child: 24} }<br><br>Object.assign()深拷贝 <br>let obj = { name: '程序猿', age:{child: 12} }<br>let copy = Object.assign({}, obj,{age:{child: 12}}); <br>copy.age.child = 66<br>console.log(obj) \/\/ { name: '程序猿', age:{child: 12} }<\/p><\/code><\/pre><\/div><p>一切都要从语法说起Object.assign(target, ...sources)，第一个参数target决定了你的对象被拷贝到哪个目标对象上面，如果你不想对原始对象产生影响，就定义一个空对象{}作为target，单单这样还不够，sources只设置原始对象obj的话，表示对原始对象的“浅拷贝”，但是设置多个对象的合并，就会返回一个全新的对象。<\/p><p><br><\/p><p><span style=\"color: rgb(194, 79, 74);\">生产环境的深拷贝建议用lodash的<span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">_.cloneDeep(obj)<\/span><\/span><\/p><p>浅拷贝和深拷贝的区别在于：<font color=\"#c24f4a\" face=\"Consolas, Menlo, Courier, monospace\">浅拷贝只拷贝是基本数据类型的属性，<\/font><span style=\"color: rgb(194, 79, 74);\">\n\n但是当对象的属性是引用类型（例如对象）时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。&nbsp;<\/span>&nbsp;<font color=\"#c24f4a\" face=\"Consolas, Menlo, Courier, monospace\">。<\/font>深拷贝后的对象和原来的对象是完全隔离的，互不影响。<\/p><p><br><\/p><h2>ARRAY filter与find的区别：<\/h2><p>[1,2,4,5,123,634,23,12].filter(item=&gt;item&gt;10)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; [123, 634, 23, 12]<\/p><p>[1,2,4,5,123,634,23,12].find(item=&gt;item&gt;10)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/123<\/p><p><br><\/p><h2><span style=\"font-weight: bold;\">ARRAY reduce() 玩法：<\/span><\/h2><p>求[1,2,3,4,5]的总和<br>一开始可能会想先定义个数，然后循环遍历累加<br>let arr = [1,2,3,4,5]<br>let num = 0;<br>for(let i =0;i&lt;arr.length;i++){<br>   num+= arr[i]<br>}<br>此处高级点的写法可以这样：<br>let arr = [1,2,3,4,5]<br>let num = arr.reduce((x,y)=&gt;x+y)<br>其他高级用法还有：<br>（1）计算数组中每个元素出现的次数<br>let names = ['Alice','Bob','Eric','Alice']<br>let nameNum = names.reduce((pre,cur)=&gt;{<br>     if(cur in pre){<br>        pre[cur] += 1<br>     }else{<br>        pre[cur] = 1<br>     }<br>     return pre<br>},{})<br>（2）数组去重<br>let arr = [1,2,3,4,2]<br>let newArr = arr.reduce((pre,cur)=&gt;{<br>     if(!pre.includes(cur)){<br>         pre.push(cur)<br>     }<br>     return pre<br>},[])<br>（3）将二维数组转化为一维<br>let arr = [[0, 1], [2, 3], [4, 5]]<br>let newArr = arr.reduce((pre,cur)=&gt;{<br>     return pre.concat(cur)<br>},[])<br>（3）将多维数组转化为一维<br>let arr = [[0, 1], [2, 3], [4,[5,6,7]]]<br>const newArr = function(arr){<br>   return arr.reduce((pre,cur)=&gt;pre.concat(Array.isArray(cur)?newArr(cur):cur),[])<br>}<br>console.log(newArr(arr));    \/\/[0, 1, 2, 3, 4, 5, 6, 7]<br>（4）、对象里的属性求和<br>var result = [<br>    {<br>        subject: 'math',<br>        score: 10<br>    },<br>    {<br>        subject: 'chinese',<br>        score: 20<br>    },<br>    {<br>        subject: 'english',<br>        score: 30<br>    }<br>];<br><br>var sum = result.reduce(function(prev, cur) {<br>    return cur.score + prev;<br>}, 0);<br>console.log(sum) \/\/60<\/p><h2>ARRAY from() 玩法：<\/h2><div><div>const cities = [\n    { name: 'Paris', visited: 'no' },\n    { name: 'Lyon', visited: 'no' },\n    { name: 'Marseille', visited: 'yes' }];<\/div><\/div><p>想输出只有name的数组，一般会用map<\/p><p>const resultArr = cities.map(item=&gt;item.name)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; &nbsp;[\"Paris\", \"Lyon\", \"Marseille\"]<\/p><p>高级点：<\/p><p>const resultArr = Array.from(cities,({name})=&gt;name)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp;[\"Paris\", \"Lyon\", \"Marseille\"]<\/p><h2>有条件的对象属性：<\/h2><div><div>const getUser = (emailIncluded) =&gt; {&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; return {&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name: 'John',&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; surname: 'Doe',&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...emailIncluded &amp;&amp; { email : 'john@doe.com' }<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; }<\/div><div>&nbsp;}\n&nbsp;<\/div><div>const user = getUser(true);&nbsp;<\/div><div>console.log(user); \/\/ outputs { name: \"John\", surname: \"Doe\", email: \"john@doe.com\" }&nbsp;<\/div><div>&nbsp;const userWithoutEmail = getUser(false);&nbsp;<\/div><div>console.log(userWithoutEmail); \/\/ outputs { name: \"John\", surname: \"Doe\" }<\/div><\/div><h2>日常可能应用：<\/h2><p><span style=\"text-decoration-line: underline;\">格式化金钱&nbsp;&nbsp;<\/span><br><\/p><p>const ThousandNum = num =&gt; num.toString().replace(\/B(?=(d{3})+(?!d))\/g, \",\");&nbsp;<\/p><p>const money = ThousandNum(19941112);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; \"19,941,112\"<br><\/p><p><br><\/p><p><span style=\"text-decoration-line: underline;\">生成随机ID&nbsp;&nbsp;<\/span><br><\/p><p>const RandomId = len =&gt; Math.random().toString(36).substr(3, len);&nbsp;<\/p><p>const id = RandomId(10);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; '18zvxk2cwx'&nbsp; &nbsp; &nbsp;(长度不能保证为10)<\/p><p><br><\/p><p><span style=\"text-decoration-line: underline;\">补零&nbsp;&nbsp;<\/span><br><\/p><p>const FillZero = (num, len) =&gt; num.toString().padStart(len, \"0\");<\/p><p>const num = FillZero(169, 5);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp;\"00169\"<span style=\"text-decoration-line: underline;\"><br><\/span><\/p><p><br><\/p><p><span style=\"text-decoration-line: underline;\">精确小数&nbsp;&nbsp;<\/span><br><\/p><p>const RoundNum = (num, decimal) =&gt; Math.round(num * 10 ** decimal) \/ 10 ** decimal;&nbsp;<\/p><p>const num = RoundNum(1.69, 1);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp;1.7<br><\/p><p><br><\/p><p><span style=\"text-decoration-line: underline;\">判断奇偶&nbsp;&nbsp;<\/span><br><\/p><p>const OddEven = num =&gt; !!(num &amp; 1) ? \"odd\" : \"even\";&nbsp;<\/p><p>const num = OddEven(2);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; &nbsp; &nbsp; 'even'<span style=\"text-decoration-line: underline;\"><br><\/span><\/p><p><br><\/p><p><span style=\"text-decoration-line: underline;\">取最小最大值&nbsp;<\/span>&nbsp;<br><\/p><p>const arr = [0, 1, 2];&nbsp;<\/p><p>const min = Math.min(...arr);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; &nbsp;0<\/p><p>const max = Math.max(...arr);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; &nbsp;2<br><\/p><p><br><\/p><p><br><\/p><p><br><\/p><p><br><\/p><p><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/1\/29 14:20:55",
"updatetime":"2019\/7\/2 16:08:58"
},
{
"id":14,
"title":"NUXT揍你",
"content":"<h2 id=\"预处理器的使用\">预处理器的使用<\/h2><p>安装需要的loader后指定lang就可以直接使用。<\/p><p>npm i less less-loader --save-dev&nbsp;<\/p><p>／／全局css&nbsp;<\/p><p>css: [&nbsp;<divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>{&nbsp;<\/span>src: '@\/assets\/less\/index.less',&nbsp; lang: 'less'&nbsp; }<\/div><div>&nbsp;],&nbsp;<\/div><p>／／页面中使用 &lt;style lang=\"less\" scoped&gt;&lt;\/style&gt;<\/p><h1><a href=\"https:\/\/www.jianshu.com\/p\/840169ba92e6\" target=\"_blank\">Nuxt开发经验分享，让你踩少点坑！<\/a><br><\/h1><p><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/1\/31 09:20:58",
"updatetime":"2019\/2\/11 16:28:40"
},
{
"id":15,
"title":"TypeScript - 不止稳，而且快",
"content":"<p><span style=\"font-weight: bold;\">##现状：<\/span><br>很多SPA项目的很多bug都是由于一些调用方和被调用方（如组件模块间的协作、接口或函数的调用）的数据格式不匹配引起的，由于TS有编译期的静态检查，让我们的bug尽可能消灭在编译器，加上IDE有智能纠错，编码时就能提前感知bug的存在，我们的线上运行时质量会更为稳定可控。<br><br><span style=\"font-weight: bold;\">##为什么用typescript?<\/span><br>强类型约束和静态检查，提升可维护性。<br>虽然需要多写一些类型定义代码，但TS在VSCODE等IDE上有智能提示，智能感知bug(能够提前在编译期避免许多 bug)<br><br><span style=\"font-weight: bold;\">##权衡<\/span><br>如果是中小型项目，且生命周期不是很长，那就直接用JS吧，不要被TS束缚住了手脚。<br>如果是大型应用，且生命周期比较长，那建议试试TS。开源项目如VS Code、GitHub桌面端，不开源的如Slack桌面端、Asana、Palantir。<br>如果是框架、库之类的公共模块，那更建议用TS了。如Ant Design、Angular 、Ionic。<\/p><p><br><\/p><p><a href=\"https:\/\/segmentfault.com\/a\/1190000010391598\" target=\"_blank\">TypeScript - 不止稳，而且快<\/a><br><a href=\"https:\/\/segmentfault.com\/a\/1190000009630935\" target=\"_blank\">js进化，迁徙到typescript<\/a><br><\/p><p><br><\/p><h2>react-typescript<\/h2><p><span style=\"color: rgb(0, 0, 0);\">create-react-app typescript-react-app<\/span><span style=\"color: rgb(194, 79, 74);\"> --scripts-version=react-scripts-ts<\/span><br><br>####tslint.json 文件<br>#interface name must start with a capitalized I<br>解决方案：<br>\"rules\": {<br>  \"interface-name\": [true, \"never-prefix\"]<br>}<br>Import sources within a group must be alphabetized<br>解决方案：<br>\"rules\": {<br>  \"ordered-imports\": false<br>}<br>The key 'onDecrement' is not sorted alphabetically<br>解决方案：<br>\"rules\": {<br>  \"object-literal-sort-keys\": false<br>}<br><\/p><p><br><\/p><p>1.typescript的优势在于静态类型（在编译时报错的是静态语言，在运行时报错的是动态语言）<br>2.编译时就能规避大量低级错误，省时<br>3.适用于多人协作，大大节省沟通成本，代码阅读成本，省事<br>4.友好代码提示，不用反复翻文档，省心<br>5.适合生命周期长的大项目<br><br><br>#枚举<br>【反向映射】<br>enum direction{<br>    east,<br>    west,<br>    south,<br>    north<br>}<br>console.log(direction.west,direction[1])         \/\/  1  'west'<\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/2\/11 16:52:00",
"updatetime":"2020\/3\/13 11:46:13"
},
{
"id":16,
"title":"大神博文",
"content":"<p><a href=\"http:\/\/www.tdon.site\/\" target=\"_blank\">DON<\/a><br><\/p><p><a href=\"http:\/\/www.tdon.site\/post\/18\" target=\"_blank\">个人博客开发系列：文章实时保存<\/a><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/2\/12 13:56:27",
"updatetime":"2019\/2\/15 09:36:13"
},
{
"id":17,
"title":"工具函数~",
"content":"<div><span>\/**<\/span><\/div><div>* 格式化 - _ 的文件名和文件为驼峰形式，方便调用<\/div><div>*\/<\/div><div><span style=\"background-color: rgb(241, 241, 241); font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">const formatName = function (str, reg) {<\/span><\/div><pre><code>      let newStr = '<br>      if (str.match(reg)) {<br>            const fileArray = str.split(reg)<br>            fileArray.forEach((value, index) =&gt; {<br>                   if (index === 0) {<br>                       newStr = value<br>                   } else {<br>                       newStr += value.substr(0, 1).toUpperCase() + value.substr(1)<br>                   }<br>        })<br>        } else {<br>               newStr = str<br>         }<br>         return newStr<br>}<\/code><\/pre><p><br><\/p><div><br><\/div><div><div><span>var<\/span><span> <\/span><span>EventUtil<\/span><span> <\/span><span>=<\/span><span> {<\/span><\/div><div><span>  <\/span><span>addHandler<\/span><span>: <\/span><span>function<\/span><span> (element, type, handler) { <\/span><span>\/\/添加事件<\/span><\/div><div><span>    <\/span><span>if<\/span><span> (<\/span><span>element<\/span><span>.<\/span><span>addEventListener<\/span><span>) {<\/span><\/div><div><span>      <\/span><span>element<\/span><span>.<\/span><span>addEventListener<\/span><span>(<\/span><span>type<\/span><span>, <\/span><span>handler<\/span><span>, <\/span><span>false<\/span><span>); <\/span><span>\/\/使用DOM2级方法添加事件<\/span><\/div><div><span>    } <\/span><span>else<\/span><span> <\/span><span>if<\/span><span> (<\/span><span>element<\/span><span>.<\/span><span>attachEvent<\/span><span>) { <\/span><span>\/\/使用IE方法添加事件<\/span><\/div><div><span>      <\/span><span>element<\/span><span>.<\/span><span>attachEvent<\/span><span>(<\/span><span>\"on\"<\/span><span> <\/span><span>+<\/span><span> <\/span><span>type<\/span><span>, <\/span><span>handler<\/span><span>);<\/span><\/div><div><span>    } <\/span><span>else<\/span><span> {<\/span><\/div><div><span>      <\/span><span>element<\/span><span>[<\/span><span>\"on\"<\/span><span> <\/span><span>+<\/span><span> <\/span><span>type<\/span><span>] <\/span><span>=<\/span><span> <\/span><span>handler<\/span><span>; <\/span><span>\/\/使用DOM0级方法添加事件<\/span><\/div><div><span>    }<\/span><\/div><div><span>  },<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><br><\/divcourier><\/p><div><span>  <\/span><span>removeHandler<\/span><span>: <\/span><span>function<\/span><span> (element, type, handler) { <\/span><span>\/\/取消事件<\/span><\/div><div><span>    <\/span><span>if<\/span><span> (<\/span><span>element<\/span><span>.<\/span><span>removeEventListener<\/span><span>) {<\/span><\/div><div><span>      <\/span><span>element<\/span><span>.<\/span><span>removeEventListener<\/span><span>(<\/span><span>type<\/span><span>, <\/span><span>handler<\/span><span>, <\/span><span>false<\/span><span>);<\/span><\/div><div><span>    } <\/span><span>else<\/span><span> <\/span><span>if<\/span><span> (<\/span><span>element<\/span><span>.<\/span><span>detachEvent<\/span><span>) {<\/span><\/div><div><span>      <\/span><span>element<\/span><span>.<\/span><span>detachEvent<\/span><span>(<\/span><span>\"on\"<\/span><span> <\/span><span>+<\/span><span> <\/span><span>type<\/span><span>, <\/span><span>handler<\/span><span>);<\/span><\/div><div><span>    } <\/span><span>else<\/span><span> {<\/span><\/div><div><span>      <\/span><span>element<\/span><span>[<\/span><span>\"on\"<\/span><span> <\/span><span>+<\/span><span> <\/span><span>type<\/span><span>] <\/span><span>=<\/span><span> <\/span><span>null<\/span><span>;<\/span><\/div><div><span>    }<\/span><\/div><div><span>  },<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><br><\/divcourier><\/p><div><span>  <\/span><span>getEvent<\/span><span>: <\/span><span>function<\/span><span> (event) { <\/span><span>\/\/使用这个方法跨浏览器取得event对象<\/span><\/div><div><span>    <\/span><span>return<\/span><span> event <\/span><span>?<\/span><span> event <\/span><span>:<\/span><span> window.event;<\/span><\/div><div><span>  },<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><br><\/divcourier><\/p><div><span>  <\/span><span>getTarget<\/span><span>: <\/span><span>function<\/span><span> (event) { <\/span><span>\/\/返回事件的实际目标<\/span><\/div><div><span>    <\/span><span>return<\/span><span> event.target <\/span><span>||<\/span><span> event.<\/span><span>srcElement<\/span><span>;<\/span><\/div><div><span>  },<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><br><\/divcourier><\/p><div><span>  <\/span><span>preventDefault<\/span><span>: <\/span><span>function<\/span><span> (event) { <\/span><span>\/\/阻止事件的默认行为<\/span><\/div><div><span>    <\/span><span>if<\/span><span> (event.<\/span><span>preventDefault<\/span><span>) {<\/span><\/div><div><span>      event.<\/span><span>preventDefault<\/span><span>();<\/span><\/div><div><span>    } <\/span><span>else<\/span><span> {<\/span><\/div><div><span>      event.<\/span><span>returnValue<\/span><span> <\/span><span>=<\/span><span> <\/span><span>false<\/span><span>;<\/span><\/div><div><span>    }<\/span><\/div><div><span>  },<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><br><\/divcourier><\/p><div><span>  <\/span><span>stopPropagation<\/span><span>: <\/span><span>function<\/span><span> (event) { <\/span><span>\/\/立即停止事件在DOM中的传播<\/span><\/div><div><span>    <\/span><span>\/\/避免触发注册在document.body上面的事件处理程序<\/span><\/div><div><span>    <\/span><span>if<\/span><span> (event.<\/span><span>stopPropagation<\/span><span>) {<\/span><\/div><div><span>      event.<\/span><span>stopPropagation<\/span><span>();<\/span><\/div><div><span>    } <\/span><span>else<\/span><span> {<\/span><\/div><div><span>      event.<\/span><span>cancelBubble<\/span><span> <\/span><span>=<\/span><span> <\/span><span>true<\/span><span>;<\/span><\/div><div><span>    }<\/span><\/div><div><span>  },<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><br><\/divcourier><\/p><div><span>  <\/span><span>getRelatedTarget<\/span><span>: <\/span><span>function<\/span><span> (event) { <\/span><span>\/\/获取mouseover和mouseout相关元素<\/span><\/div><div><span>    <\/span><span>if<\/span><span> (event.<\/span><span>relatedTarget<\/span><span>) {<\/span><\/div><div><span>      <\/span><span>return<\/span><span> event.<\/span><span>relatedTarget<\/span><span>;<\/span><\/div><div><span>    } <\/span><span>else<\/span><span> <\/span><span>if<\/span><span> (event.<\/span><span>toElement<\/span><span>) { <\/span><span>\/\/兼容IE8-<\/span><\/div><div><span>      <\/span><span>return<\/span><span> event.<\/span><span>toElement<\/span><span>;<\/span><\/div><div><span>    } <\/span><span>else<\/span><span> <\/span><span>if<\/span><span> (event.<\/span><span>formElement<\/span><span>) {<\/span><\/div><div><span>      <\/span><span>return<\/span><span> event.<\/span><span>formElement<\/span><span>;<\/span><\/div><div><span>    } <\/span><span>else<\/span><span> {<\/span><\/div><div><span>      <\/span><span>return<\/span><span> <\/span><span>null<\/span><span>;<\/span><\/div><div><span>    }<\/span><\/div><div><span>  },<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><br><\/divcourier><\/p><div><span>  <\/span><span>getButton<\/span><span>: <\/span><span>function<\/span><span> (event) { <\/span><span>\/\/获取mousedown或mouseup按下或释放的按钮是鼠标中的哪一个<\/span><\/div><div><span>    <\/span><span>if<\/span><span> (document.implementation.<\/span><span>hasFeature<\/span><span>(<\/span><span>\"MouseEvents\"<\/span><span>, <\/span><span>\"2.0\"<\/span><span>)) {<\/span><\/div><div><span>      <\/span><span>return<\/span><span> event.<\/span><span>button<\/span><span>;<\/span><\/div><div><span>    } <\/span><span>else<\/span><span> {<\/span><\/div><div><span>      <\/span><span>switch<\/span><span> (event.<\/span><span>button<\/span><span>) { <\/span><span>\/\/将IE模型下的button属性映射为DOM模型下的button属性<\/span><\/div><div><span>        <\/span><span>case<\/span><span> <\/span><span>0<\/span><span>:<\/span><\/div><div><span>        <\/span><span>case<\/span><span> <\/span><span>1<\/span><span>:<\/span><\/div><div><span>        <\/span><span>case<\/span><span> <\/span><span>3<\/span><span>:<\/span><\/div><div><span>        <\/span><span>case<\/span><span> <\/span><span>5<\/span><span>:<\/span><\/div><div><span>        <\/span><span>case<\/span><span> <\/span><span>7<\/span><span>:<\/span><\/div><div><span>          <\/span><span>return<\/span><span> <\/span><span>0<\/span><span>; <\/span><span>\/\/按下的是鼠标主按钮（一般是左键）<\/span><\/div><div><span>        <\/span><span>case<\/span><span> <\/span><span>2<\/span><span>:<\/span><\/div><div><span>        <\/span><span>case<\/span><span> <\/span><span>6<\/span><span>:<\/span><\/div><div><span>          <\/span><span>return<\/span><span> <\/span><span>2<\/span><span>; <\/span><span>\/\/按下的是中间的鼠标按钮<\/span><\/div><div><span>        <\/span><span>case<\/span><span> <\/span><span>4<\/span><span>:<\/span><\/div><div><span>          <\/span><span>return<\/span><span> <\/span><span>1<\/span><span>; <\/span><span>\/\/鼠标次按钮（一般是右键）<\/span><\/div><div><span>      }<\/span><\/div><div><span>    }<\/span><\/div><div><span>  },<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><br><\/divcourier><\/p><div><span>  <\/span><span>getWheelDelta<\/span><span>: <\/span><span>function<\/span><span> (event) { <\/span><span>\/\/获取表示鼠标滚轮滚动方向的数值<\/span><\/div><div><span>    <\/span><span>if<\/span><span> (event.<\/span><span>wheelDelta<\/span><span>) {<\/span><\/div><div><span>      <\/span><span>return<\/span><span> event.<\/span><span>wheelDelta<\/span><span>;<\/span><\/div><div><span>    } <\/span><span>else<\/span><span> {<\/span><\/div><div><span>      <\/span><span>return<\/span><span> <\/span><span>-<\/span><span>event.<\/span><span>detail<\/span><span> <\/span><span>*<\/span><span> <\/span><span>40<\/span><span>;<\/span><\/div><div><span>    }<\/span><\/div><div><span>  },<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><br><\/divcourier><\/p><div><span>  <\/span><span>getCharCode<\/span><span>: <\/span><span>function<\/span><span> (event) { <\/span><span>\/\/以跨浏览器取得相同的字符编码，需在keypress事件中使用<\/span><\/div><div><span>    <\/span><span>if<\/span><span> (<\/span><span>typeof<\/span><span> event.<\/span><span>charCode<\/span><span> <\/span><span>==<\/span><span> <\/span><span>\"number\"<\/span><span>) {<\/span><\/div><div><span>      <\/span><span>return<\/span><span> event.<\/span><span>charCode<\/span><span>;<\/span><\/div><div><span>    } <\/span><span>else<\/span><span> {<\/span><\/div><div><span>      <\/span><span>return<\/span><span> event.<\/span><span>keyCode<\/span><span>;<\/span><\/div><div><span>    }<\/span><\/div><div><span>  }<\/span><\/div><div><span>};<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><br><\/divcourier><\/p><\/div>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/2\/18 14:17:44",
"updatetime":"2019\/3\/12 17:51:53"
},
{
"id":18,
"title":"彻底弄懂CommonJS和AMD\/CMD",
"content":"<p><span style=\"font-style: italic;\">转自<\/span><a href=\"https:\/\/www.cnblogs.com\/chenguangliang\/p\/5856701.html\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/www.cnblogs.com\/chenguangliang\/p\/5856701.html<\/a><br><\/p><p>涉及面试题：为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？&nbsp;<\/p><p>因为模块化能带来这样的好处：<\/p><p>【<\/p><ul><li><span style=\"color: rgb(194, 79, 74);\">解决命名冲突<\/span><\/li><li><span style=\"color: rgb(194, 79, 74);\">提供复用性<\/span><\/li><li><span style=\"color: rgb(194, 79, 74);\">提高代码可维护性<\/span><\/li><\/ul><p>】&nbsp;<br><\/p><p>先回答我：为什么模块很重要？<\/p><p>答：因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。<br>但是，这样做有一个前提，那就是大家必须以同样的方式编写模块，否则你有你的写法，我有我的写法，岂不是乱了套！<\/p><p>于是下面三个模块规范出来了，这篇文章也出来了（拼出来的 {捂脸笑}）。<\/p><p>&nbsp;<\/p><p>模板语法<a href=\"http:\/\/wiki.commonjs.org\/wiki\/Modules\/1.1\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">CommonJS<\/a>和<a href=\"https:\/\/exploringjs.com\/es6\/ch_modules.html#sec_overview-modules\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">ESModule<\/a><\/p><p>JS中的模块规范（CommonJS（node），ES模范（es6），<span style=\"color: rgb(194, 79, 74);\">AMD，CMD【已经很少用】<\/span>），如果你听过js模块化这个东西，那么你就应该听过或CommonJS或AMD甚至是CMD这些规范咯，我也听过，但之前也真的是听听而已。&nbsp;现在就看看吧，这些规范到底是啥东西，干嘛的。本文包括这三个规范的来源及对应的产物的原理。<\/p><p>&nbsp;<\/p><p><strong>一、CommonJS<\/strong><\/p><p>1.一开始大家都认为JS是辣鸡，没什么用，官方定义的API只能构建基于浏览器的应用程序，逗我呢，这太狭隘了吧(用了个高端词，嘎嘎)，CommonJS就按耐不住了，CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写应用程序，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。<\/p><p>在兼容CommonJS的系统中，你可以使用JavaScript开发以下程序：<\/p><p>&nbsp;<\/p><p>(1).服务器端JavaScript应用程序<br>(2).命令行工具<br>(3).图形界面应用程序<br>(4).混合应用程序（如，Titanium或Adobe AIR）<\/p><p>2009年，美国程序员Ryan Dahl创造了<a href=\"http:\/\/nodejs.org\/\" target=\"_blank\">node.js<\/a>项目，将javascript语言用于服务器端编程。这标志\"Javascript模块化编程\"正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。NodeJS是CommonJS规范的实现，webpack 也是以CommonJS的形式来书写。<\/p><div><p>node.js的<a href=\"http:\/\/nodejs.org\/docs\/latest\/api\/modules.html\" target=\"_blank\">模块系统<\/a>，就是参照<a href=\"http:\/\/wiki.commonjs.org\/wiki\/Modules\/1.1\" target=\"_blank\">CommonJS<\/a>规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。<\/p><blockquote><p>var math = require('math');<\/p><\/blockquote><p>然后，就可以调用模块提供的方法：<\/p><blockquote><p>　　var math = require('math');<\/p><p>&nbsp; &nbsp; &nbsp; math.add(2,3); \/\/ 5<\/p><\/blockquote><\/div><p>CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}<\/p><p>require()用来引入外部模块；exports对象用于导出当前模块的方法或变量，唯一的导出口；module对象就代表模块本身。<\/p><p>虽说Node遵循CommonJS的规范，但是相比也是做了一些取舍，填了一些新东西的。<\/p><p>不过，说了CommonJS也说了Node，那么我觉得也得先了解下NPM了。NPM作为Node的包管理器，不是为了帮助Node解决依赖包的安装问题嘛，那它肯定也要遵循CommonJS规范啦，它遵循包规范（还是理论）的。<a href=\"http:\/\/en.wikipedia.org\/wiki\/CommonJS\" target=\"_blank\">CommonJS WIKI<\/a>讲了它的历史，还介绍了modules和packages等。<\/p><p>下面讲讲commonJS的原理以及简易实现：<\/p><h2>1、原理<\/h2><p>浏览器不兼容CommonJS的根本原因，在于缺少四个Node.js环境的变量。<\/p><p>&nbsp;<\/p><blockquote><ul><li>module<\/li><li>exports<\/li><li>require<\/li><li>global<\/li><\/ul><\/blockquote><p>&nbsp;<\/p><p>只要能够提供这四个变量，浏览器就能加载 CommonJS 模块。<\/p><p>&nbsp;<\/p><p>下面是一个简单的示例。<\/p><p>&nbsp;<\/p><blockquote><pre><code>\nvar module = {\n  exports: {}\n};\n\n(function(module, exports) {\n  exports.multiply = function (n) { return n * 1000 };\n}(module, module.exports))\n\nvar f = module.exports.multiply;\nf(5) \/\/ 5000 \n<\/code><\/pre><\/blockquote><p>&nbsp;<\/p><p>上面代码向一个立即执行函数提供 module 和 exports 两个外部变量，模块就放在这个立即执行函数里面。模块的输出值放在 module.exports 之中，这样就实现了模块的加载。<\/p><p>&nbsp;<\/p><h2>2、Browserify 的实现<\/h2><p>知道了原理，就能做出工具了。<a href=\"http:\/\/browserify.org\/\" target=\"_blank\">Browserify<\/a>&nbsp;是目前最常用的 CommonJS 格式转换的工具。<\/p><p>请看一个例子，main.js 模块加载 foo.js 模块。<\/p><p>&nbsp;<\/p><blockquote><pre><code>\n\/\/ foo.js\nmodule.exports = function(x) {\n  console.log(x);\n};\n\n\/\/ main.js\nvar foo = require(\".\/foo\");\nfoo(\"Hi\");\n<\/code><\/pre><\/blockquote><p>&nbsp;<\/p><p>使用下面的命令，就能将main.js转为浏览器可用的格式。<\/p><p>&nbsp;<\/p><blockquote><pre><code>\n$ browserify main.js &gt; compiled.js\n<\/code><\/pre><\/blockquote><p>&nbsp;<\/p><p>Browserify到底做了什么？安装一下<a href=\"https:\/\/www.npmjs.com\/package\/browser-unpack\" target=\"_blank\">browser-unpack<\/a>，就能看清楚了。<\/p><p>&nbsp;<\/p><blockquote><pre><code>\n$ npm install browser-unpack -g\n<\/code><\/pre><\/blockquote><p>&nbsp;<\/p><p>然后，将前面生成的compile.js解包。<\/p><p>&nbsp;<\/p><blockquote><pre><code>\n$ browser-unpack &lt; compiled.js\n\n[\n  {\n    \"id\":1,\n    \"source\":\"module.exports = function(x) {\n  console.log(x);\n};\",\n    \"deps\":{}\n  },\n  {\n    \"id\":2,\n    \"source\":\"var foo = require(\".\/foo\");\nfoo(\"Hi\");\",\n    \"deps\":{\".\/foo\":1},\n    \"entry\":true\n  }\n]\n<\/code><\/pre><\/blockquote><p>&nbsp;<\/p><p>可以看到，browerify 将所有模块放入一个数组，id 属性是模块的编号，source 属性是模块的源码，deps 属性是模块的依赖。<\/p><p>&nbsp;<\/p><p>因为 main.js 里面加载了 foo.js，所以 deps 属性就指定 .\/foo 对应1号模块。执行的时候，浏览器遇到 require('.\/foo') 语句，就自动执行1号模块的 source 属性，并将执行后的 module.exports 属性值输出。<\/p><p>&nbsp;<\/p><h2>3、Tiny Browser Require<\/h2><p>虽然 Browserify 很强大，但不能在浏览器里操作，有时就很不方便。<\/p><p>&nbsp;<\/p><p>我根据&nbsp;<a href=\"https:\/\/github.com\/mochajs\/mocha\" target=\"_blank\">mocha<\/a>&nbsp;的内部实现，做了一个纯浏览器的 CommonJS 模块加载器&nbsp;<a href=\"https:\/\/github.com\/ruanyf\/tiny-browser-require\" target=\"_blank\">tiny-browser-require<\/a>&nbsp;。完全不需要命令行，直接放进浏览器即可，所有代码只有30多行。<\/p><p>&nbsp;<\/p><p><a href=\"https:\/\/github.com\/ruanyf\/tiny-browser-require\" target=\"_blank\"><img title=\"\" src=\"http:\/\/image.beekka.com\/blog\/2015\/bg2015052203.png\" alt=\"\"><\/a><\/p><p>&nbsp;<\/p><p>它的逻辑非常简单，就是把模块读入数组，加载路径就是模块的id。<\/p><p>&nbsp;<\/p><blockquote><pre><code>\nfunction require(p){\n  var path = require.resolve(p);\n  var mod = require.modules[path];\n  if (!mod) throw new Error('failed to require \"' + p + '\"');\n  if (!mod.exports) {\n    mod.exports = {};\n    mod.call(mod.exports, mod, mod.exports, require.relative(path));\n  }\n  return mod.exports;\n}\n\nrequire.modules = {};\n\nrequire.resolve = function (path){\n  var orig = path;\n  var reg = path + '.js';\n  var index = path + '\/index.js';\n  return require.modules[reg] &amp;&amp; reg\n    || require.modules[index] &amp;&amp; index\n    || orig;\n};\n\nrequire.register = function (path, fn){\n  require.modules[path] = fn;\n};\n\nrequire.relative = function (parent) {\n  return function(p){\n    if ('.' != p.charAt(0)) return require(p);\n    var path = parent.split('\/');\n    var segs = p.split('\/');\n    path.pop();\n\n    for (var i = 0; i &lt; segs.length; i++) {\n      var seg = segs[i];\n      if ('..' == seg) path.pop();\n      else if ('.' != seg) path.push(seg);\n    }\n\n    return require(path.join('\/'));\n  };\n};\n<\/code><\/pre><\/blockquote><p>&nbsp;<\/p><p>使用的时候，先将上面的代码放入页面。然后，将模块放在如下的立即执行函数里面，就可以调用了。<\/p><p>&nbsp;<\/p><blockquote><pre><code>\n&lt;script src=\"require.js\" \/&gt;\n\n&lt;script&gt;\nrequire.register(\"moduleId\", function(module, exports, require){\n  \/\/ Module code goes here\n});\nvar result = require(\"moduleId\");\n&lt;\/script&gt;\n<\/code><\/pre><\/blockquote><p>&nbsp;<\/p><p>还是以前面的 main.js 加载 foo.js 为例。<\/p><p>&nbsp;<\/p><blockquote><pre><code>\nrequire.register(\".\/foo.js\", function(module, exports, require){\n  module.exports = function(x) {\n    console.log(x);\n  };\n});\n\nvar foo = require(\".\/foo.js\");\nfoo(\"Hi\");\n<\/code><\/pre><\/blockquote><p>&nbsp;<\/p><p>注意，这个库只模拟了 require 、module 、exports 三个变量，如果模块还用到了 global 或者其他 Node 专有变量（比如 process），就通过立即执行函数提供即可。<\/p><p><strong>二、AMD<\/strong><\/p><p>基于commonJS规范的nodeJS出来以后，服务端的模块概念已经形成，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上面的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？<\/p><p>&nbsp;<\/p><blockquote><p>　　var math = require('math');<\/p><p>　　math.add(2, 3);<\/p><\/blockquote><p>&nbsp;<\/p><p>第二行math.add(2, 3)，在第一行require('math')之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。<strong>您会注意到&nbsp;<code>require<\/code>&nbsp;是同步的。<\/strong><\/p><p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于\"假死\"状态。<\/p><p>&nbsp;<\/p><p>因此，浏览器端的模块，不能采用\"同步加载\"（synchronous），只能采用\"异步加载\"（asynchronous）。这就是AMD规范诞生的背景。<\/p><p>&nbsp;<\/p><p>CommonJS是主要为了JS在后端的表现制定的，他是不适合前端的，AMD(异步模块定义)出现了，它就主要为前端JS的表现制定规范。<\/p><p><a href=\"https:\/\/github.com\/amdjs\/amdjs-api\/wiki\/AMD\" target=\"_blank\">AMD<\/a>是\"Asynchronous Module Definition\"的缩写，意思就是\"异步模块定义\"。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。<\/p><p>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：<\/p><blockquote><p>　　require([module], callback);<\/p><\/blockquote><p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：<\/p><blockquote><p>　　require(['math'], function (math) {<\/p><p>　　　　math.add(2, 3);<\/p><p>　　});<\/p><\/blockquote><p>math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。目前，主要有两个Javascript库实现了AMD规范：<a href=\"http:\/\/requirejs.org\/\" target=\"_blank\">require.js<\/a>和<a href=\"https:\/\/github.com\/cujojs\/curl\" target=\"_blank\">curl.js<\/a>。<\/p><p><strong>RequireJS就是实现了AMD规范的呢。<\/strong><\/p><p><strong>详细概括：下面以RequireJS为例说明AMD规范<\/strong><\/p><p>一、为什么要用require.js？<\/p><p>最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。<\/p><p>&nbsp;<\/p><blockquote><p>　　&lt;script src=\"1.js\"&gt;&lt;\/script&gt;<br>　　&lt;script src=\"2.js\"&gt;&lt;\/script&gt;<br>　　&lt;script src=\"3.js\"&gt;&lt;\/script&gt;<br>　　&lt;script src=\"4.js\"&gt;&lt;\/script&gt;<br>　　&lt;script src=\"5.js\"&gt;&lt;\/script&gt;<br>　　&lt;script src=\"6.js\"&gt;&lt;\/script&gt;<\/p><\/blockquote><p>&nbsp;<\/p><p>这段代码依次加载多个js文件。<\/p><p>&nbsp;<\/p><p>这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。<\/p><p>&nbsp;<\/p><p>require.js的诞生，就是为了解决这两个问题：<\/p><p>&nbsp;<\/p><blockquote><p>　　<img src=\"http:\/\/image.beekka.com\/blog\/201211\/bg2012110701.png\" alt=\"\"><\/p><p>　　（1）实现js文件的异步加载，避免网页失去响应；<\/p><p>　　（2）管理模块之间的依赖性，便于代码的编写和维护。<\/p><\/blockquote><p>&nbsp;<\/p><p>二、require.js的加载<\/p><p>&nbsp;<\/p><p>使用require.js的第一步，是先去官方网站<a href=\"http:\/\/requirejs.org\/docs\/download.html\" target=\"_blank\">下载<\/a>最新版本。<\/p><p>&nbsp;<\/p><p>下载后，假定把它放在js子目录下面，就可以加载了。<\/p><p>&nbsp;<\/p><blockquote><p>　　&lt;script src=\"js\/require.js\"&gt;&lt;\/script&gt;<\/p><\/blockquote><p>&nbsp;<\/p><p>有人可能会想到，加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：<\/p><p>&nbsp;<\/p><blockquote><p>　　&lt;script src=\"js\/require.js\"&nbsp;defer async=\"true\"&nbsp;&gt;&lt;\/script&gt;<\/p><\/blockquote><p>&nbsp;<\/p><p>async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。<\/p><p>&nbsp;<\/p><p>加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：<\/p><p>&nbsp;<\/p><blockquote><p>　　&lt;script src=\"js\/require.js\"&gt;&lt;\/script&gt;<\/p><\/blockquote><p>&nbsp;<\/p><p>&gt;&nbsp;<\/p><p>三、主模块的写法<\/p><p>&nbsp;<\/p><p>上一节的main.js，我把它称为\"主模块\"，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。<\/p><p>&nbsp;<\/p><p>下面就来看，怎么写main.js。<\/p><p>&nbsp;<\/p><p>如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。<\/p><p>&nbsp;<\/p><blockquote><p>　　\/\/ main.js<\/p><p>　　alert(\"加载成功！\");<\/p><\/blockquote><p>&nbsp;<\/p><p>但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。<\/p><p>&nbsp;<\/p><blockquote><p>　　\/\/ main.js<\/p><p>　　require(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC){<\/p><p>　　　　\/\/ some code here<\/p><p>　　});<\/p><\/blockquote><p>&nbsp;<\/p><p>require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是['moduleA', 'moduleB', 'moduleC']，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。<\/p><p>&nbsp;<\/p><p>require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。<\/p><p>&nbsp;<\/p><p>下面，我们看一个实际的例子。<\/p><p>&nbsp;<\/p><p>假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写：<\/p><p>&nbsp;<\/p><blockquote><p>　　require(['jquery', 'underscore', 'backbone'], function ($, _, Backbone){<\/p><p>　　　　\/\/ some code here<\/p><p>　　});<\/p><\/blockquote><p>&nbsp;<\/p><p>require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。<\/p><p>&nbsp;<\/p><p>四、模块的加载<\/p><p>&nbsp;<\/p><p>上一节最后的示例中，主模块的依赖模块是['jquery', 'underscore', 'backbone']。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。<\/p><p>&nbsp;<\/p><p>使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。<\/p><p>&nbsp;<\/p><blockquote><p>　　require.config({<\/p><p>　　　　paths: {<\/p><p>　　　　　　\"jquery\": \"jquery.min\",<br>　　　　　　\"underscore\": \"underscore.min\",<br>　　　　　　\"backbone\": \"backbone.min\"<\/p><p>　　　　}<\/p><p>　　});<\/p><\/blockquote><p>&nbsp;<\/p><p>上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js\/lib目录，则有两种写法。一种是逐一指定路径。<\/p><p>&nbsp;<\/p><blockquote><p>　　require.config({<\/p><p>　　　　paths: {<\/p><p>　　　　　　\"jquery\": \"lib\/jquery.min\",<br>　　　　　　\"underscore\": \"lib\/underscore.min\",<br>　　　　　　\"backbone\": \"lib\/backbone.min\"<\/p><p>　　　　}<\/p><p>　　});<\/p><\/blockquote><p>&nbsp;<\/p><p>另一种则是直接改变基目录（baseUrl）。<\/p><p>&nbsp;<\/p><blockquote><p>　　require.config({<\/p><p>　　　　baseUrl: \"js\/lib\",<\/p><p>　　　　paths: {<\/p><p>　　　　　　\"jquery\": \"jquery.min\",<br>　　　　　　\"underscore\": \"underscore.min\",<br>　　　　　　\"backbone\": \"backbone.min\"<\/p><p>　　　　}<\/p><p>　　});<\/p><\/blockquote><p>&nbsp;<\/p><p>如果某个模块在另一台主机上，也可以直接指定它的网址，比如：<\/p><p>&nbsp;<\/p><blockquote><p>　　require.config({<\/p><p>　　　　paths: {<\/p><p>　　　　　　\"jquery\": \"https:\/\/ajax.googleapis.com\/ajax\/libs\/jquery\/1.7.2\/jquery.min\"<\/p><p>　　　　}<\/p><p>　　});<\/p><\/blockquote><p>&nbsp;<\/p><p>require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个<a href=\"http:\/\/requirejs.org\/docs\/optimization.html\" target=\"_blank\">优化工具<\/a>，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。<\/p><p>&nbsp;<\/p><p>五、AMD模块的写法<\/p><p>&nbsp;<\/p><p>require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。<\/p><p>&nbsp;<\/p><p>具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。<\/p><p>&nbsp;<\/p><p>假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写：<\/p><p>&nbsp;<\/p><blockquote><p>　　\/\/ math.js<\/p><p>　　define(function (){<\/p><p>　　　　var add = function (x,y){<\/p><p>　　　　　　return x+y;<\/p><p>　　　　};<\/p><p>　　　　return {<\/p><p>　　　　　　add: add<br>　　　　};<\/p><p>　　});<\/p><\/blockquote><p>&nbsp;<\/p><p>加载方法如下：<\/p><p>&nbsp;<\/p><blockquote><p>　　\/\/ main.js<\/p><p>　　require(['math'], function (math){<\/p><p>　　　　alert(math.add(1,1));<\/p><p>　　});<\/p><\/blockquote><p>&nbsp;<\/p><p>如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。<\/p><p>&nbsp;<\/p><blockquote><p>　　define(['myLib'], function(myLib){<\/p><p>　　　　function foo(){<\/p><p>　　　　　　myLib.doSomething();<\/p><p>　　　　}<\/p><p>　　　　return {<\/p><p>　　　　　　foo : foo<\/p><p>　　　　};<\/p><p>　　});<\/p><\/blockquote><p>&nbsp;<\/p><p>当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。<\/p><p>&nbsp;<\/p><p>六、加载非规范的模块<\/p><p>&nbsp;<\/p><p>理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？<\/p><p>&nbsp;<\/p><p>回答是可以的。<\/p><p>&nbsp;<\/p><p>这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。<\/p><p>&nbsp;<\/p><p>举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。<\/p><p>&nbsp;<\/p><blockquote><p>　　require.config({<\/p><p>　　　　shim: {<br><br>　　　　　　'underscore':{<br>　　　　　　　　exports: '_'<br>　　　　　　},<\/p><p>　　　　　　'backbone': {<br>　　　　　　　　deps: ['underscore', 'jquery'],<br>　　　　　　　　exports: 'Backbone'<br>　　　　　　}<\/p><p>　　　　}<\/p><p>　　});<\/p><\/blockquote><p>&nbsp;<\/p><p>require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。<\/p><p>&nbsp;<\/p><p>比如，jQuery的插件可以这样定义：<\/p><p>&nbsp;<\/p><blockquote><p>　　shim: {<\/p><p>　　　　'jquery.scroll': {<\/p><p>　　　　　　deps: ['jquery'],<\/p><p>　　　　　　exports: 'jQuery.fn.scroll'<\/p><p>　　　　}<\/p><p>　　}<\/p><\/blockquote><p>&nbsp;<\/p><p>七、require.js插件<\/p><p>&nbsp;<\/p><p>require.js还提供一系列<a href=\"https:\/\/github.com\/jrburke\/requirejs\/wiki\/Plugins\" target=\"_blank\">插件<\/a>，实现一些特定的功能。<\/p><p>&nbsp;<\/p><p>domready插件，可以让回调函数在页面DOM结构加载完成后再运行。<\/p><p>&nbsp;<\/p><blockquote><p>　　require(['domready!'], function (doc){<\/p><p>　　　　\/\/ called once the DOM is ready<\/p><p>　　});<\/p><\/blockquote><p>&nbsp;<\/p><p>text和image插件，则是允许require.js加载文本和图片文件。<\/p><p>&nbsp;<\/p><blockquote><p>　　define([<\/p><p>　　　　'text!review.txt',<\/p><p>　　　　'image!cat.jpg'<\/p><p>　　　　],<br><br>　　　　function(review,cat){<\/p><p>　　　　　　console.log(review);<\/p><p>　　　　　　document.body.appendChild(cat);<\/p><p>　　　　}<\/p><p>　　);<\/p><\/blockquote><p>&nbsp;<\/p><p>类似的插件还有json和mdown，用于加载json文件和markdown文件。（完）<\/p><p>&nbsp;<\/p><p>另一个人的概括(有点简单)：<\/p><p>AMD就只有一个接口：define(id?,dependencies?,factory);<\/p><p>&nbsp;<\/p><p>它要在声明模块的时候制定所有的依赖(dep)，并且还要当做形参传到factory中，像这样：<\/p><p>&nbsp;<\/p><div><pre>1 define(['dep1','dep2'],function(dep1,dep2){...});<\/pre><\/div><p>&nbsp;<\/p><p>要是没什么依赖，就定义简单的模块，下面这样就可以啦：<\/p><p>&nbsp;<\/p><div><div><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"https:\/\/common.cnblogs.com\/images\/copycode.gif\" alt=\"复制代码\"><\/a><\/div><pre>1 define(function(){\n2     var exports = {};\n3     exports.method = function(){...};\n4     return exports;\n5 });<\/pre><div><a href=\"javascript:void(0);\" onclick=\"copyCnblogsCode(this)\" title=\"复制代码\"><img src=\"https:\/\/common.cnblogs.com\/images\/copycode.gif\" alt=\"复制代码\"><\/a><\/div><\/div><p>&nbsp;<\/p><p>咦，这里有define，把东西包装起来啦，那Node实现中怎么没看到有define关键字呢，它也要把东西包装起来呀，其实吧，只是Node隐式包装了而已.....<\/p><p>这有AMD的WIKI中文版，讲了很多蛮详细的东西，用到的时候可以查看：<a href=\"https:\/\/github.com\/amdjs\/amdjs-api\/wiki\/AMD-(%E4%B8%AD%E6%96%87%E7%89%88)\" target=\"_blank\">AMD的WIKI中文版<\/a><\/p><p><strong>三、CMD<\/strong><\/p><p>大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的，不过用起来感觉更加方便些，最重要的是中文版，应有尽有：<a href=\"http:\/\/seajs.org\/docs\/#docs\" target=\"_blank\">seajs官方doc<\/a><\/p><div><pre>1 define(function(require,exports,module){...});<\/pre><\/div><p>用过seajs吧，这个不陌生吧，对吧。<\/p><p>前面说AMD，说RequireJS实现了AMD，CMD看起来与AMD好像呀，那RequireJS与SeaJS像不像呢？<\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/2\/27 13:55:42",
"updatetime":"2020\/3\/31 14:19:42"
},
{
"id":19,
"title":"学PHP笔记",
"content":"<p>1. 在函数内想用全局变量需要在变量前加global<br><br>ThinkPHP5.1开发文档:  <br>https:\/\/www.kancloud.cn\/manual\/thinkphp5_1\/353946<br><br>vscode中调试php<br>https:\/\/www.cnblogs.com\/studyskill\/p\/6873588.html<\/p><p><a href=\"http:\/\/www.destoon.com\/doc\/book\/\" target=\"_blank\">destoon开发手册<\/a><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/3\/6 17:27:07",
"updatetime":"2019\/3\/13 11:33:50"
},
{
"id":20,
"title":"node开发笔记",
"content":"<h3>pm2 发布 node 配置文件ecosystem.json<a href=\"https:\/\/www.jianshu.com\/p\/50a64ae618ac\" style=\"font-size: 12px; background-color: rgb(255, 255, 255);\">https:\/\/www.jianshu.com\/p\/50a64ae618ac<\/a><span style=\"font-size: 12px;\">&nbsp;&nbsp;<\/span><\/h3><blockquote><p>\n  \n  \n  \n  <script>\n  var b1 = 500; var b2 = 300;\n  function visib (tag, state, timeout) {\n    var bl = document.getElementsByName(tag);\n    var vv; if (state) vv = 'visible'; else vv = 'hidden';\n    var i;\n    for (i = 0; i < bl.length; i++) {\n      bl[i].style.visibility = vv;\n    }\n    window.setTimeout ('visib (\"' + tag + '\", ' + !state + ', ' + timeout + ')', timeout);\n  }\n  function setup () {\n    window.setTimeout ('visib (\"blink\", 0, b1)', b1);\n    window.setTimeout ('visib (\"rapid\", 0, b2)', b2);\n  }\n  <\/script>\n\n\n\n  <\/p><br><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td xbackground=\"\">\n  <div id=\"vt100\">\n   <pre><span style=\"font-weight: bold;\">查看npm全局下载过的包<\/span><\/pre><pre>npm list -g --depth 0<\/pre>\n  <\/div>\n  <\/td><\/tr><\/tbody><\/table><p>&lt;-------Node-------&gt;<br>node调试还是挺麻烦的，网上node-inspect node-inspector没啥卵用。目前最方便的直接用VSCode调试，HbuilderX还没有调试node的插件<\/p><p><br><\/p><p><span style=\"color: rgb(194, 79, 74);\">VSCode调试的方法<\/span><br>打开vscode的settings：<\/p><p>输入node debug的扩展node：auto attach，设置为on<\/p><p>在终端输入node -- inspect &lt;file name&gt; 打断点，打开调试模式，就ok了<\/p><p><br><br>node区分开发与生产，可以用cross-env<br>npm i cross-env -D<br>cmd命令cross-env NODE_ENV=production app.js<br><br><br>用nodemon index.js 替代 node index.js 可以监听，不用重启。需要先cnpm install -g nodemon<br><br><br>\/\/ path玩法<br>const path = require(\"path\")<br>path.join和path.resolve的区别:(talk is cheap,show me the code)<br>console.log(__dirname)                                 \/\/  test<br>console.log(path.join(__dirname,\".\/a\"))                \/\/  test\/a<br>console.log(path.resolve(__dirname,\".\/a\"))             \/\/  test\/a<br><br>console.log(path.join(__dirname,\"a\"))                  \/\/  test\/a<br>console.log(path.resolve(__dirname,\"a\"))               \/\/  test\/a<br><br>console.log(path.join(__dirname,\"\/b\"))                 \/\/  test\/b<br>console.log(path.resolve(__dirname,\"\/b\"))              \/\/  \/b<br><br>*获取文件后缀<br>path.extname(\"test.js\")                                \/\/  .js<br>*提取出用 ‘\/\" 隔开的path的最后一部分并过滤字符后缀<br>path.basename(\"\/foo\/bar\/baz\/asdf\/test.html\", \".html\")  \/\/ test<br><br><br>\/\/ lodash玩法<br>const _ = require(\"lodash\")<br>const fs = require(\"fs\")<br>*获取当前文件夹下的所有文件夹和文件<br>const d = __dirname<br>const [dirs,files] = _(fs.readdirSync(d)).partition(p=&gt;fs.statSync(path.join(d,p)).isDirectory())<br><br><br>\/\/ JWT(Json Web Token)玩法<br>#和Session方式存储id的差异<br>Session方式存储用户id的最大弊病在于要占用大量服务器内存，对于较大型应用而言可能还要保存许多的状态。一般而言，大型应用还需要借助一些KV数据库和一系列缓存机制来实现Session的存储。<br><br>而JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。除了用户id之外，还可以存储其他的和用户相关的信息，例如该用户是否是管理员、用户所在的分布等<br><br><br><br>&lt;-------KOA-------&gt;<br>-----中间件<\/p><p><br>（koa-bodyparser）:解析完的数据放到ctx.request.body中，没有这个中间件拿不到POST请求的data<br>koa2 使用 koa-body 代替 koa-bodyparser 和 koa-multer  url:http:\/\/www.ptbird.cn\/koa-body.html<br><br>router内的ctx,next 一定要await next()才能返回下个路由的返回数据，没有await直接报404<br><br>&lt;!--------------坑---------------&gt;<br>router函数里 ctx.cookies.set没反应   url直接输入就可以。。。 I have no idea、<\/p><p><br><\/p><p>&lt;!--------------前后端同根目录---------------&gt;&nbsp;&nbsp;<br><\/p><p>这里使用concurrently来帮我们同时执行两条命令。<\/p><div><div>\"scripts\": {&nbsp;<\/div><div>&nbsp;  \"react-start\": \"react-app-rewired start\",&nbsp;<\/div><div>&nbsp;  \"react-build\": \"react-app-rewired build\",&nbsp;<\/div><div>&nbsp;  \"start\": \"concurrently \"react-app-rewired start\" \"cd server &amp;&amp; yarn start\"\",&nbsp;<\/div><div>&nbsp;  \"build\": \"concurrently \"react-app-rewired build\" \"cd server &amp;&amp; yarn build\"\",&nbsp;<\/div><div>&nbsp;  \"test\": \"react-scripts test --env=jsdom\",<\/div><div>&nbsp;\n  \"eject\": \"react-scripts eject\"&nbsp;<\/div><div>},<\/div><div>接下来，秩序执行npm run start就可以同时启动前端和后端了。&nbsp;&nbsp;<br><\/div><br><\/div><p><br><\/p><p><span style=\"font-weight: bold; font-size: large;\">##关于nodejs的框架选择<\/span><\/p><p>最近来node的火热，带动了一大批的框架，例如<\/p><ul><li>express<\/li><li>koa<\/li><li>sails<\/li><li>loopback<\/li><li>thinkjs<\/li><li>egg<\/li><\/ul><div><br><\/div><div><span style=\"font-weight: bold; font-size: small;\">#express<\/span><\/div><div>新手入门的框架，封装了基本功能【<\/div><ul><li>静态资源托管&nbsp;<\/li><li>封装了路由<\/li><li>中间件的概念<\/li><li>内置了jade，ejs模板引擎<\/li><\/ul><div>】相当于node的jquery<\/div><div>个人评价，express适合小型项目，不适合大型企业级项目，个人用用还可以，做为快速入门是个很好的选择，用过之后就可以考虑进入 koa 框架的道路&nbsp;<\/div><div><br><\/div><div><span style=\"font-weight: bold; font-size: small;\">#koa2<\/span><\/div><div>koa 是比 express 思想更先进的框架，是express原班人马打造<br><\/div><div><div>\n<p>koa解决的最大问题，利用async await的新语法特性，解决回调地狱的问题<\/p>\n<p>koa 与 express 最大的不同，个人觉得有3点：<\/p>\n<p>1.在于 handler 的处理方法，express 是普通的回调函数， koa 是利用ES7 中 Async\/Await 的特性，没有回调，没有回调，就大大加速了开发速度这一点而言，已经足以让我们跪舔了<\/p>\n<p>2.koa是洋葱中间件模式，执行到next的时候，会去调用下一个中间件，下个中间件执行完再接着执行上个中间件next下面的代码<\/p>\n<p>3.koa把 request, response 封装到了同一个上下文对象 content<\/p>\n<p>最为express的进化，确实带来更好的开发效率，成本只需要学西一下async await的新语法特性。可以说作为express框架的进阶框架是非常好的了<\/p><p><br><\/p><\/div><div><div><h2><span style=\"font-size: small;\">#后面的这几个都是企业级框架<\/span><\/h2>\n<p>express =》koa 之后，最大的问题就是开发项目的时候缺少约束，单人开发还好，多人的时候，各种目录结构，各种包的选择，百花齐放的代码风格。都是团队开发头疼的事情。<\/p>\n<p>因为本人之前做过php开发，laravel框架的使用起来很舒服（优雅！），还有配套的laravel-admin。所以一直想找一个能像laravel这样的node框架提高开发效率<\/p>\n<p>回到正题，sails , loopback, thinkjs, egg 都是企业级框架，我们又该如何选择<\/p>\n<p>Sails 是基于 exrpess 的大而全的框架，MVC框架，旨在模拟熟悉的Ruby on Rails框架的MVC模式，但支持现代应用程序的需求。捆绑了一个强大的ORM，即Waterline。自动生成的REST API<\/p>\n<p>LoopBack 是建立在 Express 基础上的企业级 Node.js 框架，只需编写少量代码就能创建动态端到端的 REST API，一致化的模型关系和对 API 访问的权限控制等<\/p>\n<p>ThinkJS 是国内360团队推出的一款面向未来开发的 Node.js 框架，整合了大量的项目最佳实践，让企业级开发变得如此简单、高效。框架底层基于 Koa 2.x 实现，兼容 Koa 的所有功能<\/p>\n<p>Egg.js是《阿里旗下产品》基于Node.js 和 Koa的一个Nodejs的企业级应用开发框架，它可以帮助开发团队及开发人员降低开发和维护成本。Egg.js则是按照约定进行开发，奉行『约定优于配置』，具备提供基于Egg定制上层框架的能力、<br>\n高度可扩展的插件机制、内置多进程管理、基于Koa开发，性能优异、框架稳定，测试覆盖率高、渐进式开发、开发成本和维护成本低等特点。<\/p>\n<h2><span style=\"font-size: small;\">个人结论：<\/span><\/h2>\n<p>个人最终选择了 Egg 框架，当然其他都是很好的框架，但是我在分别用这4个框架新建了项目之后，更喜欢Egg框架。<\/p>\n<p>首选，egg是基于 koa2 的，async的特性让我们避免了回调地狱。洋葱式的中间件架构让我们更容易后置逻辑，内置的多进程管理会帮我们更好的利用服务器性能。更方便的单元测试，更加约束的目录架构<\/p>\n<p>推荐新手的进阶之路是：express -&gt; koa -&gt; egg<\/p><\/div><\/div>egg：【<strong>约定优于配置<\/strong>】按照<a href=\"https:\/\/eggjs.org\/zh-cn\/advanced\/loader.html\">一套统一的约定<\/a>进行应用开发，<span style=\"background-color: rgb(255, 255, 255);\">不会做出技术选型，根据自己的业务场景定制配置<\/span><\/div><\/blockquote>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/3\/6 17:31:00",
"updatetime":"2020\/4\/15 15:30:44"
},
{
"id":21,
"title":"es6基础温习",
"content":"<p>事件委托用e.target获取当前触发的dom（子元素）<br>event.target返回触发事件的元素<br>event.currentTarget返回绑定事件的元素,如事件委托我绑定是ul来监听，点击li还是返回ul的dom<br><br><span style=\"color: rgb(194, 79, 74);\">#简述箭头函数和普通函数的区别&nbsp;&nbsp;<\/span><br><\/p><p><span style=\"color: rgb(194, 79, 74);\">1.箭头函数的this,是声明时就确定了，而不是在运行时确定<\/span><\/p><p><span style=\"color: rgb(194, 79, 74);\">2.箭头函数没有arguments，用...args扩展运算符代替<\/span><\/p><p><span style=\"color: rgb(194, 79, 74);\">3.箭头函数是匿名函数，不能作为构造函数，不能用new<\/span><\/p><p><span style=\"color: rgb(194, 79, 74);\"><br><\/span><\/p><h3><span style=\"color: rgb(194, 79, 74);\">##箭头函数滴<span style=\"font-weight: bold;\">This<\/span>坑<\/span><\/h3><p>var obj = {<br>&nbsp; &nbsp; &nbsp; &nbsp;num:0,<br>&nbsp; &nbsp; &nbsp; &nbsp;count:function(){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setInterval(function(){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log(++this.num)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },1000)<br>&nbsp; &nbsp; &nbsp; &nbsp;}<br>}<br>obj.count()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/ NaN NaN NaN NaN... (this指向了window)<\/p><p><span style=\"color: rgb(194, 79, 74);\">~~用了箭头呢~~<\/span><\/p><p>var obj = {<br>&nbsp; &nbsp; &nbsp; &nbsp;num:0,<br>&nbsp; &nbsp; &nbsp; &nbsp;count:function(){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setInterval(()=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log(++this.num)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },1000)<br>&nbsp; &nbsp; &nbsp; &nbsp;}<br>}<br>obj.count()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/ 1 2 3 4 5\n\n... (this往上级找，指向obj)&nbsp;&nbsp;&nbsp;<br><\/p><p>##用箭头注意【例如写原型方法时注意this指向】<\/p><p>Array.prototype.myFlat = ()=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return this.reduce((a,b)=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return a.concat(Array.isArray(b)?b.myFlat():b)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;},[])<br>}<\/p><p>console.log([1,2,[3,4,[5]]].myFlat())<\/p><p>\/\/ 此时this指向window，<span style=\"color: rgb(194, 79, 74);\">所以原型链添加方法就不要用箭头函数了<\/span><br><\/p><p>Array.prototype.myFlat = function(){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return this.reduce((a,b)=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return a.concat(Array.isArray(b)?b.myFlat():b)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;},[])<br>}&nbsp;&nbsp;<\/p><p>箭头函数可以使用 arguments吗 使用对象结构const arrow = (...args) =&gt; { console.log(args) }&nbsp;&nbsp;<br><\/p><p><br><\/p><p>(变量提升)<br>  \/\/ var 的情况（var会变量提升）<br>  console.log(foo); \/\/ 输出undefined<br>   var foo = 2;<br><br>  \/\/ let 的情况（let不会变量提升）<br>  console.log(bar); \/\/ 报错ReferenceError<br>  let bar = 2;<\/p><p><span style=\"font-weight: bold;\">变量提升的副作用【demo】<\/span><\/p><div><span>var<\/span><span>&nbsp;<\/span><span>tmp<\/span><span>&nbsp;=&nbsp;<\/span><span>new<\/span><span>&nbsp;<\/span><span>Date<\/span><span>();<\/span><\/div><div><span>function<\/span><span>&nbsp;<\/span><span>f<\/span><span>()&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>tmp<\/span><span>);<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>if<\/span><span>&nbsp;(<\/span><span>false<\/span><span>)&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>var<\/span><span>&nbsp;<\/span><span>tmp<\/span><span>&nbsp;=&nbsp;<\/span><span>'hello&nbsp;world'<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;}<\/span><\/div><div><span>}<\/span><\/div><div><span>f<\/span><span>();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ undefined&nbsp; &nbsp; &nbsp; 【访问不到时间，如果改作let就可以访问到了】<\/span><\/div><p><span style=\"font-weight: 700;\"><br><\/span><br>(let和const都不可重复声明)<br>  let message = \"Goodbye!\";<br>  let message = \"sz\";\/\/报错<br><br>  const message = \"Goodbye!\";<br>  const message = \"sz\";\/\/报错<br><br>（const以下情景）<br>  const message;<br>  message = \"Goodbye!\"     \/\/报错，const要一次性写出来<br><br>  const obj = {a:1} <br>  obj.b = 2                \/\/不报错，正常输出object    因为对象是引用类型，返回的是存储内存的指针，指针不会变，和内存存储是两码事<br><br>(解构赋值)<br>  let a = 1;<br>  let b = 2;<br>  let c = 3;<br>  可以写成  let [a, b, c] = [1, 2, 3]<br><br>  let [head,...tail] = [1,2,3,4]<br>  head  \/\/1<br>  tail  \/\/[2,3,4]<br><br>  let a,b,c;<br>  [a,b,c=3] = [1,2]<br>  console.log(a,b,c)   \/\/ 1,2,3<br><br>  let [x, y, ...z] = [\"a\"]<br>  x \/\/\"a\"<br>  y \/\/undefined<br>  z \/\/[]<br><br>  let [a,[b],d] = [1,[2,3],4]<br>  a \/\/1<br>  b \/\/2<br>  d \/\/4<br><br>  let {a,b} = {a:1,b:2}<br>  console.log(a,b)   \/\/ 1 2<br><br>  let {a=10,b=5} = {a:1}<br>  console.log(a,b)   \/\/ 1 5<br><br>  \/\/ 拿取后台返回数据的两个title<br>  let metaData = {<br>      title: \"abc\",<br>      test: [{<br>          title: \"test\",<br>          desc: \"description\"<br>      }]<br>  }<br>  let {title:esTitle,test:[{title:cnTitle}]} = metaData<br>  console.log(esTitle,cnTitle)   \/\/ \"abc\"  \"test\"<br><br>常应用场景<br>1.变量交换<br>{<br>   let a = 1;<br>   let b = 2;<br>   [a,b] = [b,a]<br>   console.log(a,b)   \/\/ 2 1<br>}<br><br>2. 选择性拿值<br>{<br>   function f(){<br>      return [1,2,3]<br>   }<br>   let a,b;<br>   [a,,b]=f();<br>   console.log(a,b);   \/\/ 1 2<br>}<br><br><br><span style=\"color: rgb(194, 79, 74);\">（正则扩展）<\/span><br>{<br>   \/\/ es5<br>   let regex = new RegExp(\"xyz\",\"i\")<br>   let regex2 = new RegExp(\/xyz\/i)<br><br>   var regex = new RegExp(\"xy\",\"g\")<br>   var d = regex.exec(\"12xy34xy\")     \/\/ [\"xy\"]<br>   d.index                            \/\/ 2<br>   regex.lastIndex                    \/\/ 4<br>   var d = regex.exec(\"12xy34xy\")     \/\/ [\"xy\"]<br>   d.index                            \/\/ 6<br>   regex.lastIndex                    \/\/ 8<br>   var d = regex.exec(\"12xy34xy\")     \/\/ [\"xy\"]<br>   d                                  \/\/ null<br>   regex.lastIndex                    \/\/ 0 (重置为0，下次再循环)<br>   <br>   <br>   \/\/ es6写法<br>   let regex3 = new RegExp(\/xyz\/i,\"g\")<br>   console.log(regex3.flags)          \/\/ g<br>}<br><br>{<br>   let s = \"bbb_bb_b\"<br>   let a1 = \/b+\/g<br>   let a2 = \/b+\/y<br>   <br>   console.log(a1.exec(s),a2.exec(s))    \/\/ \"bbb\"   \"bbb\"<br>   console.log(a1.exec(s),a2.exec(s))    \/\/ \"bb\"   null<br>   <br>   g修饰符和y修饰符最大的区别就是如上述情况，g会跳过_找到bb，但y不会跳，必须在bbb之后继续找<br><br>   console.log(a1.sticky,a2.sticky)      \/\/ false true  (表示是否设置了y修饰符)<br>}<br><br>{<br>   console.log(\/u{61}\/.test(\"a\"));       \/\/ false<br>   console.log(\/u{61}\/u.test(\"a\"));      \/\/ true （加u修饰符把unicode码转为对应字符）<br><br>   console.log(\/uD83D\/.test(\"uD83DuDC2A\"));     \/\/ true<br>   console.log(\/uD83D\/u.test(\"uD83DuDC2A\"));    \/\/ false<br>}<br><br>{<br>   \/\/ 如果处理的字符串或正则有大于2个字节的字符，都要加u<br>   let s = \"吉\"<br>   console.log(\/^.$\/.test(s))       \/\/ false<br>   console.log(\/^.$\/u.test(s))      \/\/ true<br><br>   console.log(\/吉{2}\/.test(\"吉吉\"))    \/\/ fasle<br>   console.log(\/吉{2}\/u.test(\"吉吉\"))   \/\/ true<br>}<br><br><span style=\"color: rgb(194, 79, 74);\">（字符串扩展）<\/span><br>{<br>   \/\/ ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符<br>   console.log(\"abc\".charAt(0))   \/\/ a<br>   console.log(\"吉\".charAt(0))    \/\/ \"uD842\"<br><br>   \/\/ ES6提出字符串实例的at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符<br>   console.log(\"abc\".at(0))       \/\/ a<br>   console.log(\"吉\".at(0))        \/\/ \"吉\"<br>}<br>{<br>   console.log(\"a\",`u0061`)      \/\/ a  （两个字节）(在0xffff之内)<br>   console.log(\"s\",`u{20BB7}`)   \/\/ 吉  (超过两个字节，就要用大括号)<br>}<br>{<br>   let s = \"a\"<br>   console.log(s.length)          \/\/ 1<br>   console.log(s.charCodeAt(0))   \/\/ 97<br>   console.log(s.codePointAt(0))   \/\/ 97<br>   console.log(s.codePointAt(0).toString(16))    \/\/ 61<br><br>   let j = \"吉\"<br>   console.log(j.length)          \/\/ 2<br>   console.log(j.charCodeAt(0))   \/\/ 不是想要的值<br>   console.log(j.codePointAt(0).toString(16))    \/\/ 20BB7<br>}<br><br>{<br>   console.log(String.fromCharCode(\"0x20bb7\"))   \/\/ 乱码~<br>   console.log(String.fromCodePoint(\"0x20bb7\"))  \/\/ 吉<br>}<br><br>{<br>    let str = \"u{20BB7}abc\";<br>    for(let i=0;i&lt;str.length;i++){<br>        console.log(\"test for\",str[i])          \/\/  出现两个乱码再出a b c<br>    }<br>    for(let code of str){<br>        console.log(\"test for of\",code)         \/\/  吉 a b c<br>    }<br>}<br><br>{<br>    let str = \"string\"<br>    console.log(str.includes(\"s\"))            \/\/ true<br>    console.log(str.includes(\"c\"))            \/\/ false<br>    console.log(str.startsWith(\"str\"))        \/\/ true<br>    console.log(str.endsWith(\"ng\"))           \/\/ true<br>}<br><br>{<br>    let str = \"abc\"<br>    console.log(str.repeat(2))                \/\/ abcabc<br>}<br><br>{<br>    \/\/ 模板字符串<br>    let name = \"eric\"<br>    let say = \"hello\"<br>    <br>    let m = `${say}, i am ${name}`<br>}<br><br>{<br>    console.log(\"1\".padStart(3,\"0\"))          \/\/ 001<br>    console.log(\"1\".padEnd(3,\"0\"))            \/\/ 100<br>}<br><br>{<br>    \/\/ 标签字符串<br>    let user = {<br>        name: \"eric\",<br>        age: 25<br>    }<br>    let result = abc`my name is ${user.name},and i am ${user.age} years old!`<br>    console.log(result)<br>    function abc(s,v1,v2){<br>        return s+v1+v2        \/\/ my name is ,,and i am , years old!eric25<br>    }<br>    返回值s是一个数组[\"my name is \",\",and i am \",\" years old!\"]<br>    v1是\"eric\"v2是\"25\"<br>}<br><br>{<br>     console.log(String.raw`Hi \n${1+2}`)   \/\/ Hi \n3<br>     console.log(`Hi \n${1+2}`)             \/\/ Hi 换行 3<br><br>     String.raw的作用就是转义，也就是在后面再加<br>}<br><br><br><span style=\"color: rgb(194, 79, 74);\">(数值的扩展)<\/span><br>{<br>     console.log(0b11111111)    \/\/ 255<br>     console.log(0o767)         \/\/ 503<br>   <br>     \/\/可以大写  0B 或0O<br>}<br><br>{<br>     console.log(Number.isFinite(15))    \/\/ true<br>     console.log(Number.isFinite(NaN))   \/\/ false<br><br>     console.log(Number.isNaN(NaN))      \/\/ true<br><br>     console.log(Number.isInteger(25))     \/\/ true<br>     console.log(Number.isInteger(25.0))   \/\/ true<br>     console.log(Number.isInteger(\"25\"))     \/\/ false<br><br>     console.log(Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER)<br>     console.log(Number.isSafeInteger(10))    \/\/ true<br>     console.log(Number.isSafeInteger(\"a\"))   \/\/ false<br><br>     \/\/ 直接返回小数的整数<br>     console.log(Math.trunc(4.1))        \/\/ 4<br>     console.log(Math.trunc(4.9))        \/\/ 4<\/p><p>和Math.floor还是有点区别的<\/p><p>console.log(Math.trunc(4.1)) \/\/ 4&nbsp;&nbsp;<br><\/p><p>console.log(Math.trunc(-4.1)) \/\/ 4&nbsp;&nbsp;&nbsp;&nbsp;<\/p><p>console.log(Math.&nbsp;floor(4.1)) \/\/&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;<br>console.log(Math.\n\nfloor(-4.1)) \/\/ -5&nbsp;&nbsp;<br><br>     \/\/ 判断正数负数零<br>     console.log(Math.sign(-5))          \/\/ -1<br>     console.log(Math.sign(0))           \/\/ 0<br>     console.log(Math.sign(5))           \/\/ 1<br>     console.log(Math.sign(\"50\"))        \/\/ 1  会把字符串转为数字<br>     console.log(Math.sign(\"foo\"))       \/\/ NaN<br><br>     \/\/ 立方根<br>     console.log(Math.cbrt(8))           \/\/ 2<br><br>     用Number要传数字，不会自动转为数字，Math的api会转为数字<br>}<br><br><br><span style=\"color: rgb(194, 79, 74);\">(数组的扩展)<\/span><br>{<br>    \/\/ es5的map和filter有什么区别？(一个处理值一个返回条件满足的值)<br>    var a = [1,2,3,4];<br>    var newa = a.map(function(x){<br>       return x = x+1;<br>    });<br>    console.log(newa,a); <br>    \/\/ newa : 2 3 4 5   \/\/a: 1 2 3 4<br><br><br>    var a = [1,2,3,4];<br>    var newa = a.filter(function(x){<br>       return x &gt; 1;<br>    });<br>    console.log(newa,a); <br>    \/\/ newa : 2 3 4    \/\/a: 1 2 3 4<br>    <br>}<br>{<br>    \/\/ es5 （数组+字符串=字符串）<br>    var d = [1,2,3]<br>    console.log(d + \"haha\")            \/\/  1,2,3haha(字符串)<br> <br><br>    Array(7);          \/\/ [ , , , , , , ]<br>    Array(1, 2, 3);    \/\/ [1, 2, 3]<br>    <br>    \/\/es6<br>    Array.of(7);       \/\/ [7] <br>    Array.of(1, 2, 3); \/\/ [1, 2, 3]<br><br>}<br><br>{<br>    \/\/ Array.from转为真正的数组<br>    let p = document.querySelectorAll(\"p\")<br>    Array.from(p).forEach(function(item){<br>        console.log(item.textContent)<br>    })<br><br>    Array.from([1,3,5],function(item){<br>        return item*2<br>    })    \/\/  2 6 10<br><br>    [1,\"a\",undefined].fill(7)       \/\/ 7 7 7<br>    [1,\"a\",undefined].fill(7,1,3)   \/\/ 1 7 7<br>}<br><br>{<br>    for(let index of [1,\"a\",undefined].keys()){<br>        console.log(index)                                 \/\/ 0 1 2<br>    }<br>    for(let value of [1,\"a\",undefined].values()){<br>        console.log(value)                                 \/\/ 1,\"a\",undefined (要加babel-polyfill)<br>    }<br>    for(let [index,value] of [1,\"a\",undefined].entries()){<br>        console.log(index,value)<br>    }<br>}<\/p><h3><a id=\"cb_post_title_url\" href=\"https:\/\/www.cnblogs.com\/rogerwu\/p\/10738776.html\">for in 和 for of 的区别<\/a><\/h3><p><br>{<br>    console.log([1,2,3,4,5].copyWithin(0,3,4))   \/\/ 4 2 3 4 5<br>    console.log([1,2,3,4,5].copyWithin(1,2,5))   \/\/ 1 3 4 5 5<br><br>    \/\/ 第一个参数为要替换的位置索引，第二个参数为替换上的内容起止位置，第三个参数为截止位置<br>}<br><br>{<br>    console.log([1,2,3,4,5,6].find(function(item){return item&gt;3}))        \/\/ 4<br>    console.log([1,2,3,4,5,6].findIndex(function(item){return item&gt;3}))   \/\/ 3<br><br>    console.log([1,2,3,4,5,6].find(function(item){return item&gt;10}))       \/\/ undefined<br>}<br><br>{<br>    console.log([1,2,NaN].includes(1))                                    \/\/ true<br>    console.log([1,2,NaN].includes(NaN))                                  \/\/ true<br><br>    console.log([{a:1},2].includes({a:1})) \/\/ false<\/p><p>let obj = {a:1}<\/p><p>console.log([obj,2].includes(obj))&nbsp; \/\/ true<br>}<br><br>{<br>    let x = \"test\"<br>    function a(x,y=x){<br>        console.log(x,y)<br>    }<br>    a(\"hello\")                       \/\/ hello hello<br>    a()                              \/\/ undefined undefined<br><br>    function b(c,y=x){<br>        console.log(c,y)<br>    }<br>    b(\"hello\")                       \/\/ hello test (对y的赋值先找形参，形参找不到再找定义的变量)<br>} <br><br>{<br>    \/\/ 把不确定数目的参数依次输出来<br>    function a(...args){<br>        for(var item of args){<br>            console.log(item)<br>        }<br>    }<br>    a(1,\"a\",NaN)                     \/\/ 1,\"a\",NaN<br>}<br><br>{<br>    \/\/ 箭头函数<br>    let arrow = v =&gt; v*2<br>    arrow(3)                         \/\/ 6<br><br>    \/\/ 没参数怎么写？<br>    let arrow2 = () =&gt; 5<br>    arrow2()                         \/\/ 5<br>}<br><br>\/\/ 尾调用有利于性能优化<br><br><span style=\"color: rgb(194, 79, 74);\">(对象的扩展)<\/span><br>{<br>    let a = \"b\"<br>    let es5_obj = {<br>        b: \"c\"<br>    }<br>    let es6_obj = {<br>        [a]: \"c\"<br>    }<br>    console.log(es5_obj,es6_obj )     \/\/ 两个一样<br>}<br><br>{<br>    Object.is(\"abc\",\"abc\") 相当于 \"abc\" === \"abc\"    \/\/ true<br>    Object.is([],[])       相当于 [] === []          \/\/ false<br>    Object.is({},{})       相当于 {} === {}          \/\/ false<br>}<br><br>{<br>    \/\/ 属性只有一层的时候为深拷贝<br>    let obj = {}<br>    let a_obj = {a:\"a\"}<br>    let b_obj = {b:\"b\"}<br>    console.log(Object.assign(obj,a_obj,b_obj))<br>    \/\/ 超过两层变为浅拷贝<br>    let a = {x: {y: 1}};<br>    let b = Object.assign({}, a);<br>    b.x.y = 2;<br>    console.log(b);    \/\/{x: {y: 2}}<br>    console.log(a);    \/\/{x: {y: 2}}<br>}<br><br>{<br>    let test = {k:123,o:456}<br>    for(let [key,value] of Object.entries(test)){<br>        console.log(key,value)<br>    }<br>}<br><br><span style=\"color: rgb(194, 79, 74);\">(数据类型之Symbol)<\/span><br>{<br>    \/\/ Symbol生成独一无二的值，.for加标志<br>    <br>    let a1 = Symbol()<br>    let a2 = Symbol()<br>    console.log(a1===a2)             \/\/ false<\/p><p>let a3 = Symbol(\"hi\")<br>let a4 = Symbol(\"hi\")&nbsp;&nbsp;<\/p><p>console.log(a3===a4) \/\/ false<\/p><p><br>    let a5 = Symbol.for(\"hi\")<br>    let a6 = Symbol.for(\"hi\")        \/\/ 寻找是否有key为hi的值，没有的话新建个独一无二的symbol值<br>    console.log(a5===a6)             \/\/ true<br>}<br><br>{<br>    let a = Symbol.for(\"abc\")<br>    let b = Symbol.for(\"d\")<br>    let all = {<br>        [a]: \"123\",<br>        \"abc\": \"456\",<br>        \"d\": \"8\",<br>        [b]: \"910\"<br>    }<br>    \/\/ for of 只能拿到非Symbol值<br>    for(let [key,value] of Object.entries(all)){<br>&nbsp; &nbsp; &nbsp;console.log(key,value)          \/\/ abc 456  d 8<br>    }<\/p><h3><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">[利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。]<\/span><\/h3><p>    \/\/ Object.getOwnPropertySymbols只能拿到Symbol值<br>    Object.getOwnPropertySymbols(all).forEach(function(item){<br>&nbsp; &nbsp; &nbsp; &nbsp; console.log(item,all[item])     \/\/ Symbol(abc) \"123\" Symbol(d) \"910\"<br>    })<br>    \/\/ Reflect.ownKeys能拿到所有值<br>    Reflect.ownKeys(all).forEach(function(item){<br>&nbsp; &nbsp; &nbsp; &nbsp; console.log(item,all[item])     \/\/ abc 456  d 8  Symbol(abc) \"123\" Symbol(d) \"910\"<br>    })<\/p><p><span style=\"color: rgb(194, 79, 74);\">【而Object.keys(all)只能拿非symbol值】<\/span><\/p><p>}<br><br><span style=\"color: rgb(194, 79, 74);\">(数据类型之Set)<\/span>(特点：key独一无二)（去重）<br>可以添加删除各种数据类型<br>Set增：<br>{<br>    let list = new Set()<br>    list.add(5)<br>    list.add(7)<br>    console.log(list.size)              \/\/  2<br><br>    list.add(5)                         <br>    console.log(list.size)              \/\/  2<br>}<br><br>{<br>    let arr = [1,2,3,4,5]<br>    let list = new Set(arr)<br>    console.log(list.size)              \/\/ 5<br>}<br>{<br>    \/\/ 给数组去重<br>    let arr = [1,2,3,1,2]<br>    let list = new Set(arr)<br>    console.log(list.size)              \/\/ 3<br>    console.log(list)                   \/\/ 1 2 3<br><br>    let arr1 = [1,2,3,\"2\"]<br>    let list1 = new Set(arr1)<br>    console.log(list1.size)             \/\/ 4<br>    console.log(list1)                  \/\/ 1 2 3 \"2\"<br>}<br><br>Set查<br>{<br>    let arr = [1,2,3]<br>    let list = new Set(arr)<br>    console.log(list.has(1))            \/\/ true<br>}<br>Set删<br>{<br>    let arr = [1,2,3]<br>    let list = new Set(arr)<br>    list.delete(1)<br>    console.log(list)                   \/\/ 2 3<br>    list.clear()<br>    console.log(list)                   \/\/ 空Set{}<br>} <br>Set遍历<br>{<br>    let arr = [\"a\",\"b\",\"c\"]<br>    let list = new Set(arr)<br>    for(let [key，value] of list.entries()){<br>         console.log(key,value)         \/\/ a a b b c c<br>    }<\/p><p>for(let [key，value] of&nbsp;\n\narr.entries()){<br>console.log(key,value) \/\/ 0 a 1 b 2 c<br>}&nbsp;&nbsp;<br>    \/\/ 类数组都可以用forEach<br>    list.forEach(function(item){console.log(item)})<br>}<br>\/\/ WeakSet(只能添加对象（数组和函数属于对象），没有size属性，不能用clear，不能遍历)<br>{<br>    let weakList = new WeakSet()<br>    let arg = {} <br>    let arr = [1,2,3]<br>    weakList.add(arg)<br>    weakList.add(arr)<br>    console.log(weakList)<br>}<br><span style=\"color: rgb(194, 79, 74);\">(数据类型之Map)<\/span>(key可以是任何数据类型）<br>Map增：<br>{<br>    let map = new Map();<br>    let arr = [1,2,3]<br>    map.set(arr,123)<br>    \/\/ 获取<br>    console.log(map,map.get(arr))       \/\/ [1,2,3] : 123     123<br>}  <br>{<br>    let map = new Map([[\"a\",123],[\"b\",345]])<br>    console.log(map.size)               \/\/ 2<br>}<br>Map删：<br>{<br>    let map = new Map([[\"a\",1]]);<br>    map.delete(\"a\")<br>    console.log(map)                    \/\/ Map(0) {}<br>}<br>Map查：<br>{<br>    let map = new Map([[\"a\",1]]);<br>    console.log(map.has(\"a\"))           \/\/ true<br>}<br>Map清除<br>{<br>    let map = new Map([[\"a\",1]]);<br>    map.clear()<br>    console.log(map)                    \/\/ Map(0) {}<br>}<br>\/\/ WeakMap(只能添加对象（数组和函数属于对象），没有size属性，不能用clear，不能遍历)<br>{<br>    let weakList = new WeakMap()<br>    let arg = {} <br>    let arr = [1,2,3]<br>    weakList.set(arg,1)<br>    weakList.set(arr,1)<br>    console.log(weakList)<br>}<br>（增删改查）大对比<br>与Array和Object的对比 <br>{<br>    let set = new Set()<br>    let map = new Map()<br>    let array = []<br>    let obj = {}<br>    \/\/ 增<br>    set.add({t:1})<br>    map.set(\"t\",1)<br>    array.push({t:1})<br>    obj[\"t\"]=1<br> <br>    \/\/ 查<br>    console.log(set.has({t:1}))                    \/\/ false<br>    console.log(map.has(\"t\"))                      \/\/ true<br>    console.log(array.find(item=&gt;item.t))          \/\/ {t:1}<br>    console.log(\"t\" in obj)                        \/\/ true<br><br>    \/\/ 改<br>    set.forEach(item=&gt;item.t?item.t=2:\"\")<br>    map.set(\"t\",2)<br>    array.forEach(item=&gt;item.t?item.t=2:\"\")<br>    obj[\"t\"]=2<br><br>    \/\/ 删<br>    set.forEach(item=&gt;item.t?set.delete(item):\"\")<br>    map.delete(\"t\")<br>    let index = array.findIndex(item=&gt;item.t)<br>    array.splice(index,1)<br>    delete obj[\"t\"]<br>}<br><br><span style=\"color: rgb(194, 79, 74);\">(代理之proxy)<\/span><br>{<br>    let obj = {<br>        name: \"_eric\",<br>        age: 25<br>    }<br>    let monitor = new Proxy(obj,{<br>        \/\/ 拦截对象属性的读取<br>        get(target,key){<br>            return target[key].toString().replace(\"c\",\"k\")<br>        },<br>        \/\/ 拦截对象属性的设置<br>        set(target,key,value){<br>            if(key === \"name\"){<br>                return target[key]<br>            }else{<br>                return target[key] = value<br>            }<br>        },<br>        \/\/ 拦截key in object操作<br>        has(target,key){<br>            if(key === \"name\"){<br>                return target[key]<br>            }else{<br>                return false<br>            }<br>        },<br>        \/\/ 拦截delete<br>        deleteProperty(target,key){<br>            if(target[key].toString().indexOf(\"_\")&gt;-1){<br>                delete target[key]<br>                return true<br>            }else{<br>                return target[key]<br>            }<br>        },<br>        \/\/ 拦截Object.keys Object.getOwnPropertySymbols Object.getOwnPropertyName<br>        ownKeys(target){<br>            return Object.keys(target).filter(item =&gt; item!=\"name\")<br>        }<br>    })<br>    console.log(monitor.name)             \/\/ _erik<br>    monitor.name = \"222\"<br>    console.log(monitor.name)             \/\/ _erik<br>    delete monitor.age<br>    console.log(\"has\",\"name\" in monitor, \"age\" in monitor)<br>    console.log(\"delete\",monitor)         \/\/ {name: \"_eric\", age: 25}<br>    delete monitor.name<br>    console.log(\"delete\",monitor)         \/\/ {age: 25}<br>    console.log(\"onKey\",Object.keys(monitor))<br>}<br><span style=\"color: rgb(194, 79, 74);\">(代理之reflect)<\/span>proxy有的api   reflect也有<br>{<br>    let obj = {<br>        time: \"2018-04-04\",<br>        name: \"net\"<br>    }<br>    console.log(Relect.get(obj,\"time\"))<br>    Relect.set(obj,\"name\",\"mukewang\")<br>    console.log(obj)<br>    console.log(Reflect.has(obj,\"name\"))         \/\/ true<br>}<br>\/\/ proxy和reflect做数据校验最好<br><br>类<br>{<br>    \/\/继承传递参数<br>    class Parent{<br>        constructor(name=\"mukewang\"){<br>            this.name = name<br>        }<br>    }<br>    class Child extends Parent{<br>        constructor(name=\"child\"){<br>            super(name)&nbsp; &nbsp; &nbsp;<span style=\"color: rgb(194, 79, 74);\"> \/\/ <code>super<\/code>作为函数调用时，代表父类的构造函数&nbsp;。继承时一定要写super，不然实例化会报错<\/span><br>        }<br>    }<br>    let c = new Child(\"ddd\")<br>    console.log(c.name)        \/\/ ddd<br>}<br>{<br>    class Child{<br>        constructor(name=\"child\"){<br>            this.name= name<br>            this.type=\"child\"<br>        }<br>        get weight(){<br>            return this.name + \"50kg\"<br>        }<br>        set changename(value){<br>            this.name = value<br>        }<br>    }<br>    let c = new Child(\"ddd\")<br>    console.log(c,c.weight)     \/\/ ddd50kg<br>    c.changename = \"xiaoming\"<br>    console.log(c.name)         \/\/ xiaoming<br>}<br>{<br>    class Child{<br>        constructor(name=\"child\"){<br>            this.name= name<br>            this.type=\"child\"<br>        }<br>        static output(){<br>            console.log(\"output\")<br>        }<br>    }<br>    Child.skill = \"learn\"<br>    Child.output()                     \/\/ output<br>    console.log(Child.skill)           \/\/ learn<br>}<br>{<br>    \/\/ es5 异步回调（回调地狱）<br>    var ajax = function(callback){<br>        console.log(\"走起\")<br>        setTimeout(function () {<br>            callback &amp;&amp; callback()<br>        },1000)<br>    }<br>    var ajax1 = function(callback){<br>        console.log(\"再走起\")<br>        setTimeout(function(){<br>            callback &amp;&amp; callback()<br>        },1000)<br>    }<br>    var ajax2 = function(callback){<br>        console.log(\"再再走起\")<br>        setTimeout(function(){<br>            callback &amp;&amp; callback()<br>        },1000)<br>    }<br>    ajax(function(){<br>        console.log(\"走起了1s\")<br>        ajax1(function(){<br>            console.log(\"走起了2s\")<br>                ajax2(function(){<br>                    console.log(\"走起了3s\")<br>                      \/\/ ...<br>                })<br>        })<br>    })<br>}<br>{<br>    \/\/ es6 promise<br>    let ajax = function(){<br>        console.log(\"走你\")<br>        return new Promise(function(resolve,reject){<br>            setTimeout(function(){<br>                resolve(1)<br>            },1000)<br>        })<br>    }<br>    let ajax1 = function(num){<br>        console.log(\"走你了1s\")<br>        return new Promise(function(resolve,reject){<br>            setTimeout(function(){<br>                if(num&gt;2){resolve()}else{throw new Error(\"what the hell. Wrong again?\")}<br>            },1000)<br>        })<br>    }<br>    let ajax2 = function(){<br>        console.log(\"走你了2s\")<br>        return new Promise(function(resolve,reject){<br>            setTimeout(function(){<br>                \/\/ resolve()<br>                reject(\"服务器没响应!\")<br>            },1000)<br>        })<br>    }<br>    ajax().then(ajax1).then(ajax2).then(function(){<br>        console.log(\"走你了3s\")<br>    }).catch(function(err){<br>        console.log(\"get a error:\"+err)<br>    })<br>    \/\/ catch拿到reject的参数数据<br>    \/\/ 在一个promise链中，只要任何一个promise被reject，promise链就被破坏了，reject之后的promise都不会再执行，而是直<br><br>接调用.catch方法。<br>}<br>{<br>    \/\/ Promise All<br>    function loadImg(src){<br>        return new Promise((resolve,reject)=&gt;{<br>            let img = document.createElement(\"img\")<br>            img.src = src<br>            img.onload = function(){<br>                resolve(img)<br>            }<br>            img.onerror = function(err){<br>                reject(err)<br>            }<br>        })<br>    }<br>    function showImgs(imgs){<br>        console.log(\"imgs\",imgs)<br>        imgs.forEach((item)=&gt;{<br>            document.body.appendChild(item)<br>        })<br>    }<br>    Promise.all([<br>        loadImg(\"http:\/\/image.qizhidao.cn\/images\/0\/0\/qzddata01\/M00\/13\/99\/eclBmVp7OJ-AAhfcAACpaRsIcZA22.jpeg\"),<br>        loadImg(\"http:\/\/image.qizhidao.cn\/images\/0\/0\/qzddata01\/M00\/13\/A6\/eclBmVrEeT-AE01iAAngWpX4G-A07.jpeg\"),<br>        loadImg(\"http:\/\/image.qizhidao.cn\/images\/0\/0\/qzddata01\/M00\/13\/99\/eclBmlp7OD6AKoJPAAFX4aRtBWk72.jpeg\")<br>    ]).then(showImgs)<br>}<br><br>{<br>    setTimeout(function() {<br>       console.log(1)<br>    }, 0);<br>    new Promise(function executor(resolve) {<br>       console.log(2);<br>       for( var i=0 ; i&lt;10000 ; i++ ) {<br>           i == 9999 &amp;&amp; resolve();<br>       }<br>       console.log(3);<br>    }).then(function() {<br>       console.log(4);<br>    });<br>    console.log(5);<br>    \/\/ 打印 2 3 5 4 1<br>}<br><br><span style=\"color: rgb(194, 79, 74);\">\/\/ Iterator遍历器<\/span><br><br>1、遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。<br>2、Iterator的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。for...of的遍历就是不断应用iterator这个接口<br>3、在ES6中，有些数据结构原生具备Iterator接口（比如数组），即不用任何处理，就可以被for...of循环遍历，有些就不行（比如对象）。原因在于，这些数据结构原生部署了Symbol.iterator属性（详见下文），另外一些数据结构没有。凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。<br>{<br>    let arr = [\"hello\",\"girl\"]<br>    for(let value of arr){<br>        console.log(\"value\",value)<br>    }<br>    \/\/ 数组默认原生有嵌入Symbol.iterator这个属性<br>    let test = arr[Symbol.iterator]()<br>    console.log(test.next())           \/\/ {value: \"hello\", done: false}<br>    console.log(test.next())           \/\/ {value: \"girl\", done: false}<br>    console.log(test.next())           \/\/ {value: undefined, done: true}<br>}<br>4、在ES6中，有三类数据结构原生具备Iterator接口：Set和Map结构。<\/p><h4>原生具备 Iterator 接口的数据结构如下<\/h4><ul><li>Array<\/li><li>Map<\/li><li>Set<\/li><li>String<\/li><li>TypedArray<\/li><li>函数的 arguments 对象<\/li><li>NodeList 对象<span style=\"color: rgb(194, 79, 74);\">【\n\n类数组对象&nbsp; 】<\/span><\/li><\/ul><p>5、一个为对象添加Iterator接口的例子。<br>{<br>&nbsp; &nbsp; &nbsp; &nbsp;let obj = {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start: [1,2,3],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end: [7,8,9],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [Symbol.iterator](){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let self = this<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let arr = self.start.concat(self.end)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let index = 0<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;next(){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;done: index&gt;=arr.length,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;value: arr[index++]<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>    }<br>    for(let value of obj){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.log(value)<br>    }<br>}<br><br><span style=\"color: rgb(194, 79, 74);\">\/\/ Generator【也带有iterator接口】<\/span><\/p><p>yield 后面可以是任意合法的JavaScript表达式，yield语句可以出现的位置可以等价于一般的赋值表达式（比如a=3）能够出现的位置。<\/p><p>举例：&nbsp;<\/p><p>b = 2 + a = 3 \/\/ 不合法&nbsp;<\/p><p>b = 2 + (a = 3) \/\/ 合法&nbsp;<\/p><p>b = 2 + yield 3 \/\/ 不合法&nbsp;<\/p><p>b = 2 + (yield 3) \/\/ 合法&nbsp;&nbsp;<\/p><p><br>{<br>    let tell = function*(){<br>&nbsp; &nbsp; &nbsp; &nbsp;console.log(1)<br>&nbsp; &nbsp; &nbsp; &nbsp;setTimeout(function(){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.log(\"asyncTask\")<br>&nbsp; &nbsp; &nbsp; &nbsp;},1000)<br>&nbsp; &nbsp; &nbsp; &nbsp;yield \"1\"<br>&nbsp; &nbsp; &nbsp; &nbsp;console.log(2)<br>&nbsp; &nbsp; &nbsp; &nbsp;yield \"2\"<br>&nbsp; &nbsp; &nbsp; &nbsp;console.log(2)<br>&nbsp; &nbsp; &nbsp; &nbsp;return \"3\"<br>&nbsp; &nbsp; &nbsp; &nbsp;console.log(3)<br>    }<br>    let k = tell()<br>    console.log(k.next())   \/\/ 1    {value: \"1\", done: false}<br>    console.log(k.next())   \/\/ 2    {value: \"2\", done: false}<br>    console.log(k.next())   \/\/ {value: \"3\", done: true}<br>    console.log(k.next())   \/\/ {value: undefined, done: true}   asyncTask<br>}<br>{<br>     let obj = {}<br>     obj[Symbol.iterator]=function*(){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yield 1<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yield 2<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yield 3<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 4<br>     }<br>\/\/ for of 只打印yield值，return不会打印<br>     for(let value of obj){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.log(\"value\",value)&nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; 1 2 3&nbsp;<br>     }<br>}<br><br>{<br>    let state =function*(){<br>&nbsp; &nbsp; &nbsp; while(1){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;yield \"A\"<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;yield \"B\"<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;yield \"C\"<br>&nbsp; &nbsp; &nbsp; &nbsp;}<br>    }<br>    let status = state()<br>    console.log(status.next())<br>    console.log(status.next())<br>    console.log(status.next())<br>    console.log(status.next())<br>    console.log(status.next())<br>    \/\/ 不断的循环出ABCABC...<br>}<br>相当于<br>{<br>    let state = async function(){<br>&nbsp; &nbsp; &nbsp; &nbsp;while(1){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; await \"A\"<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; await \"B\"<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; await \"C\"<br>&nbsp; &nbsp; &nbsp; &nbsp;}<br>    }<\/p><p><span style=\"color: rgb(194, 79, 74);\">【async await在node.js 8+已经原生支持】<\/span><br>    let status = state()<br>    console.log(status.next())<br>    console.log(status.next())<br>    console.log(status.next())<br>    console.log(status.next())<br>    console.log(status.next())<br>    \/\/ 不断的循环出ABCABC...<br>}<\/p><p>function *foo(x) {&nbsp;<\/p><p>&nbsp;  let y = 2 * (yield (x + 1))&nbsp;<\/p><p>&nbsp;  let z = yield (y \/ 3)\n  return (x + y + z)&nbsp;<\/p><p>}&nbsp;<\/p><p>let it = foo(5)&nbsp;<\/p><p>console.log(it.next())   \/\/ =&gt; {value: 6, done: false}&nbsp;<\/p><p>console.log(it.next(12)) \/\/ =&gt; {value: 8, done: false}&nbsp;<\/p><p>console.log(it.next(13)) \/\/ =&gt; {value: 42, done: true}&nbsp;&nbsp;<br><\/p><p><span style=\"color: rgb(194, 79, 74);\">【next参数代表上一个yield的返回值，不传默认上个yield返回undefined】<\/span><\/p><p><br><\/p><p><span style=\"color: rgb(194, 79, 74);\">【Generator应用】<\/span><\/p><p>\/**<br> * 读取A---&gt;读取B---&gt;读取C<br> *\/<br>function *read() {<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp;let info = yield readFile('.\/JS\/Async\/data\/info.txt', 'utf-8');<br>&nbsp; &nbsp; &nbsp; &nbsp;let base = yield readFile(info, 'utf-8');<br>&nbsp; &nbsp; &nbsp; &nbsp;let age = yield readFile(base, 'utf-8');<br>&nbsp; &nbsp; &nbsp; &nbsp;return age;<br>}<\/p><p>let it = read();<br>let { value, done } = it.next();<br>value.then((data) =&gt; {<br>&nbsp; &nbsp; &nbsp; &nbsp; let { value, done } = it.next(data); \/\/data赋值给了 info<br>&nbsp; &nbsp; &nbsp; &nbsp; value.then((data) =&gt; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let { value, done } = it.next(data); \/\/data赋值给了 base<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;value.then((data) =&gt; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let { value, done } = it.next(data); \/\/data赋值给base<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.log(value); \/\/输出22<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;});<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;});<br>});<\/p><p><span style=\"color: rgb(194, 79, 74);\">#co+generator<\/span><\/p><p>const co = require('co');<br>co(read()).then(data =&gt; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log(data); \/\/输出22<br>}).catch(err =&gt; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log(err);<br>});<\/p><p>#实现co<\/p><p>function co(it){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; return new Promise((resolve,reject)=&gt;{<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function next(data){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let {value,done}=it.next(data)<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(done){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resolve(value)<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}else{<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value.then(val=&gt;{<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;next(val)<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },reject)<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;next()<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; })<\/p><p>}<\/p><p><br><\/p><p><span style=\"color: rgb(194, 79, 74);\">(修饰器decorator)<\/span><br>\/\/ 先安装babel-plugin-transform-decorators-legacy <br>在.babelrc配置加上\"plugins\":[\"transform-decorators-legacy\"]<br>1:修饰器是一个函数<br>2:修饰器修改类的行为<br>\/\/ 第三方库修饰器的js库：core-decorators<br>{<br>    let readonly = function(target,name,descriptor){<br>        descriptor.writable = false<br>        return descriptor<br>    }<br>    class Test{<br>        @readonly<br>        time(){<br>           return \"2018-4-10\"<br>        }<br>    }<br>    let test = new Test()<br>    test.time = function(){<br>        return \"reset time\"<br>    }<br>    console.log(test.time())<br>}<br>{<br>    let typename = function(target,name,descriptor){<br>        target.myname = \"hello\"<br>    }<br>    @typename<br>    class Test{<br>        <br>    }<br>    console.log(Test.myname)<br>}<br><span style=\"color: rgb(194, 79, 74);\">(模块化)<\/span><br>.\/lesson17.js<br>{<br>    export let A = 20   <br>    export function test(){console.log(\"test\")}<br>    export class Hello{}<br>}<br>{<br>    import {A,test,Hello} from \".\/lesson17\"<br>    console.log(A,test,Hello)<br>}<br>(输出多个文件的情况)<br>{<br>    import * as lesson from \".\/lesson17\"<br>    console.log(lesson.A,lesson.test,lesson.Hello)<br>}<br>\/\/最好还是用export default<br>{<br>    export default {<br>        A,<br>        test,<br>        Hello<br>    }<br>}<br>{<br>    import lesson from \".\/lesson17\"<br>    console.log(lesson.A,lesson.test,lesson.Hello)<br>}<br><br><\/p><h3><span style=\"color: rgb(194, 79, 74); font-weight: normal;\">#ES6模块和CommonJS模块的差异？<\/span><\/h3><h3><span style=\"font-weight: bold;\">1. commonJs 输出的是值的浅拷贝【内部修改值不会同步到外部，内部修改对象的key会同步，浅拷贝】，esModule 输出值的<span style=\"color: rgb(194, 79, 74);\">只读<\/span>引用<\/span>【内部修改值会同步到外部】<span style=\"color: rgb(194, 79, 74);\">【重新赋值会报错】<\/span><\/h3><p>\/\/ a.js【commonJs】<\/p><div><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'a执行了'<\/span><span>);&nbsp; &nbsp;<\/span>var&nbsp;count&nbsp;=&nbsp;0;&nbsp; &nbsp;function&nbsp;plusCount(){ count++ };&nbsp; module.exports&nbsp;=&nbsp;{count, plusCount};<\/div><p>\/\/ b.js【es6】<\/p><div>console.log('a执行了');&nbsp; &nbsp;export var&nbsp;count&nbsp;=&nbsp;0;&nbsp; &nbsp; &nbsp;export function&nbsp;plusCount(){ count++ };&nbsp;<\/div><p>\/\/ main.js 【入口js】<\/p><div><span>const<\/span><span>&nbsp;<\/span><span>a<\/span><span>&nbsp;=&nbsp;<\/span><span>require<\/span><span>(<\/span><span>'.\/components\/a.js'<\/span><span>)<\/span><\/div><div><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'a:'<\/span><span>,&nbsp;<\/span><span>a.count<\/span><span>)&nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp; 0<\/span><\/div><div><span>a<\/span><span>.<\/span><span>plusCount<\/span><span>()<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'a:'<\/span><span>,&nbsp;<\/span>\na.count<span>)&nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; &nbsp; 0<\/span><\/div><div><div>import { count,plusCount&nbsp; } from '.\/components\/b.js'&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: rgb(194, 79, 74);\">【不可以import&nbsp; obj from '.\/components\/b.js'，这种除非是export default {}】【可以用import * as obj from&nbsp;'.\/components\/b.js'代替】<\/span><\/div><div>console.log('b:',&nbsp;count)&nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp; 0<\/div><div>plusCount()<\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div>console.log('b:',&nbsp;&nbsp;count)&nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; &nbsp; 1<\/div><\/div><p>【想要commonjs的count也同步过去，那就改成get方法module.exports&nbsp;=&nbsp;{get count(){return count}, plusCount};】<\/p><p>【CommonJS模块无论require了多少次，\n\n只会执行一次代码】<\/p><p>【同样，重复 import 同一个模块，只会执行一次代码】<\/p><p>const&nbsp;a&nbsp;=&nbsp;require('.\/components\/a.js');&nbsp; &nbsp; &nbsp; &nbsp;const&nbsp;aa&nbsp;=&nbsp;require('.\/components\/a.js');&nbsp; &nbsp; &nbsp; console.log(a===aa)&nbsp; &nbsp;\/\/&nbsp; true<\/p><h3>2.require可以写动态路径，import不可以<\/h3><h3><span style=\"font-weight: bold;\">3.import自动采用严格模式<\/span><\/h3><h3><span style=\"font-weight: bold;\">4.可以对commonjs模块重新赋值，对es6模块重新赋值会编译报错<\/span><\/h3><div><h3>5.ES6在编译期间会将所有import提升到顶部，commonjs不会提升require【所以import的js比require早执行】<\/h3><\/div><h3><span style=\"font-weight: bold;\">6.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。<\/span><\/h3><div><span style=\"font-weight: 700;\">相同点：都是引用多次只执行一遍，<\/span><span style=\"font-weight: bold;\">两者都可以对对象内部属性的值进行改变<\/span><\/div><div><a href=\"https:\/\/es6.ruanyifeng.com\/#docs\/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82\">https:\/\/es6.ruanyifeng.com\/#docs\/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82<\/a>&nbsp;&nbsp;<span style=\"font-weight: bold;\"><br><\/span><\/div><p><br><\/p><p><br>#ES next 最新语法<\/p><p>Promise.allSettled<\/p><ul><li>pending: 初始状态，既不是成功，也不是失败状态。<\/li><li>fulfilled: 意味着操作成功完成。<\/li><li>rejected: 意味着操作失败。<\/li><li>Settled：&nbsp;<code>Promise<\/code>要么被完成，要么被拒绝。<code>Promise<\/code>一旦达成，它的状态就不再改变。<\/li><\/ul><pre><code>const p1 = new Promise((res, rej) =&gt; setTimeout(res, 1000));\n\nconst p2 = new Promise((res, rej) =&gt; setTimeout(rej, 1000));\n\nPromise.allSettled([p1, p2]).then(data =&gt; console.log(data));\n\n<p>\n#合并空运算符<\/p><p>let person = {<br>  profile: {<br>    name: \"\",<br>    age: 0<br>  }<br>};<br><br>console.log(person.profile.name || \"Anonymous\"); \/\/ Anonymous<br>console.log(person.profile.age || 18); \/\/ 18<\/p><p>我们可以使用??操作符来代替||，使其类型更严格一些，这只允许在值为null或未定义时使用默认值。<\/p><p>console.log(person.profile.name ?? \"Anonymous\"); \/\/ \"\"<\/p><p>console.log(person.profile.age ?? 18); \/\/ 0<\/p><p>console.log(person.profile.grader ?? 16); \/\/ 16\n<br><\/p><p>let person = {}<\/p><p>一般只有两层时我们是这样写的<\/p><p>console.log(person&amp;&amp;person.name||'Anonymous')<\/p><p>用新语法呢？<\/p><p>console.log(person?.name?? \"Anonymous\")<\/p><p>如果三层以上呢？用以前写法太长了<\/p><p>console.log(person?.profile?.name ?? \"Anonymous\")\n<\/p><\/code><\/pre><p><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/3\/15 11:45:17",
"updatetime":"2020\/5\/18 14:41:29"
},
{
"id":22,
"title":"精简代码量，从我做起~~",
"content":"<h3><stronghelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" text-align:=\"\" start;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(255,=\"\" 255,=\"\" 255);\"=\"\" style=\"font-weight: bold;\">过滤唯一值&nbsp;<\/stronghelvetica><\/h3><p>const arr = [1,2,3,3,5,5,1]<br>const uniqueArr = [...new Set(arr)]<br><\/p><p><stronghelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" text-align:=\"\" start;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(255,=\"\" 255,=\"\" 255);\"=\"\">console.log(uniqueArr)&nbsp;<\/stronghelvetica><br><\/p><h3><stronghelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" text-align:=\"\" start;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(255,=\"\" 255,=\"\" 255);\"=\"\" style=\"font-weight: bold;\">&amp;&amp;&nbsp; 和&nbsp; ||&nbsp; 写法<\/stronghelvetica><\/h3><p><stronghelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" text-align:=\"\" start;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(255,=\"\" 255,=\"\" 255);\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-style:=\"\" normal;=\"\" font-variant:=\"\" font-weight:=\"\" letter-spacing:=\"\" 0.544000029563904px;=\"\" orphans:=\"\" auto;=\"\" text-align:=\"\" start;=\"\" text-indent:=\"\" 0px;=\"\" text-transform:=\"\" none;=\"\" white-space:=\"\" widows:=\"\" 1;=\"\" word-spacing:=\"\" -webkit-text-stroke-width:=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">与（&amp;&amp;）运算符将会返回第一个<codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\">false\/‘falsy’<spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-style:=\"\" normal;=\"\" font-variant:=\"\" font-weight:=\"\" letter-spacing:=\"\" 0.544000029563904px;=\"\" orphans:=\"\" auto;=\"\" text-align:=\"\" start;=\"\" text-indent:=\"\" 0px;=\"\" text-transform:=\"\" none;=\"\" white-space:=\"\" widows:=\"\" 1;=\"\" word-spacing:=\"\" -webkit-text-stroke-width:=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">的值。当所有的操作数都是<codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\">true<spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-style:=\"\" normal;=\"\" font-variant:=\"\" font-weight:=\"\" letter-spacing:=\"\" 0.544000029563904px;=\"\" orphans:=\"\" auto;=\"\" text-align:=\"\" start;=\"\" text-indent:=\"\" 0px;=\"\" text-transform:=\"\" none;=\"\" white-space:=\"\" widows:=\"\" 1;=\"\" word-spacing:=\"\" -webkit-text-stroke-width:=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">时，将返回最后一个表达式的结果。&nbsp;&nbsp;<\/spanhelvetica><\/codesource><\/spanhelvetica><\/codesource><\/spanhelvetica><br><\/stronghelvetica><\/p><p><stronghelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" text-align:=\"\" start;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(255,=\"\" 255,=\"\" 255);\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-style:=\"\" normal;=\"\" font-variant:=\"\" font-weight:=\"\" letter-spacing:=\"\" 0.544000029563904px;=\"\" orphans:=\"\" auto;=\"\" text-align:=\"\" start;=\"\" text-indent:=\"\" 0px;=\"\" text-transform:=\"\" none;=\"\" white-space:=\"\" widows:=\"\" 1;=\"\" word-spacing:=\"\" -webkit-text-stroke-width:=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-style:=\"\" normal;=\"\" font-variant:=\"\" font-weight:=\"\" letter-spacing:=\"\" 0.544000029563904px;=\"\" orphans:=\"\" auto;=\"\" text-align:=\"\" start;=\"\" text-indent:=\"\" 0px;=\"\" text-transform:=\"\" none;=\"\" white-space:=\"\" widows:=\"\" 1;=\"\" word-spacing:=\"\" -webkit-text-stroke-width:=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-style:=\"\" normal;=\"\" font-variant:=\"\" font-weight:=\"\" letter-spacing:=\"\" 0.544000029563904px;=\"\" orphans:=\"\" auto;=\"\" text-align:=\"\" start;=\"\" text-indent:=\"\" 0px;=\"\" text-transform:=\"\" none;=\"\" white-space:=\"\" widows:=\"\" 1;=\"\" word-spacing:=\"\" -webkit-text-stroke-width:=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><\/spanhelvetica><\/codesource><\/spanhelvetica><\/codesource><\/spanhelvetica><\/stronghelvetica><\/p><pre><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">let one = 1, two = 2, three = 3;<codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">console.log(one &amp;&amp; two &amp;&amp; three); \/\/ Result: 3<codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><br><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">console.log(0 &amp;&amp; null); \/\/ Result: 0<\/codeliberation><\/codeliberation><\/codeliberation><\/codeliberation><\/pre><pre><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">或（||）运算符将返回第一个<codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\">true\/‘truthy’<spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">的值。当所有的操作数都是<codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\">false<spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">时，将返回最后一个表达式的结果。<\/spanhelvetica><\/codesource><\/spanhelvetica><\/codesource><\/spanhelvetica><\/codeliberation><\/codeliberation><\/codeliberation><\/codeliberation><\/pre><pre><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><pre>let<span style=\"font-size: 1em;\"> one = <\/span><span style=\"font-size: 1em;\">1<\/span><span style=\"font-size: 1em;\">, two = <\/span><span style=\"font-size: 1em;\">2<\/span><span style=\"font-size: 1em;\">, three = <\/span><span style=\"font-size: 1em;\">3<\/span><span style=\"font-size: 1em;\">;<\/span><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;\"=\"\" style=\"font-size: 1em;\">console.log(one || two || three); \/\/ Result: 1<\/codeliberation><br><\/pre><pre><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;\"=\"\">console.log(0 || null); \/\/ Result: null<\/codeliberation><\/codeliberation><\/codeliberation><\/codeliberation><\/pre><span style=\"font-weight: bold;\">例如：<\/span><\/spanhelvetica><\/codesource><\/spanhelvetica><\/codesource><\/spanhelvetica><\/codeliberation><\/codeliberation><\/codeliberation><\/codeliberation><\/pre><pre><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><pre><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">if (this.state.data) {<codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">  return this.state.data;<codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">} else {<codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">  return 'Fetching Data';<codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">}<\/codeliberation><\/codeliberation><\/codeliberation><\/codeliberation><\/codeliberation><\/pre><pre><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">少点：<\/codeliberation><\/codeliberation><\/codeliberation><\/codeliberation><\/codeliberation><\/pre><pre><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">return <\/codeliberation><\/codeliberation><\/codeliberation><\/codeliberation><\/codeliberation>this.state.data?this.state.data:'Fetching Data'<\/pre><pre>再少点：<\/pre><pre>return this.state.data || 'Fetching Data'<\/pre><pre><span style=\"font-weight: bold;\">抓取数组最后一个元素<\/span><\/pre><p>[1,2,3,4,5,6].slice(-1)  \/\/ [6]<\/p>\n\n\n\n\n\n<\/spanhelvetica><\/codesource><\/spanhelvetica><\/codesource><\/spanhelvetica><\/codeliberation><\/codeliberation><\/codeliberation><\/codeliberation><\/pre><pre><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><br><\/spanhelvetica><\/codesource><\/spanhelvetica><\/codesource><\/spanhelvetica><\/codeliberation><\/codeliberation><\/codeliberation><\/codeliberation><\/pre><pre><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><br><\/spanhelvetica><\/codesource><\/spanhelvetica><\/codesource><\/spanhelvetica><\/codeliberation><\/codeliberation><\/codeliberation><\/codeliberation><\/pre><pre><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><br><\/spanhelvetica><\/codesource><\/spanhelvetica><\/codesource><\/spanhelvetica><\/codeliberation><\/codeliberation><\/codeliberation><\/codeliberation><\/pre><pre><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codeliberation mono',=\"\" menlo,=\"\" courier,=\"\" monospace;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\"><codesource code=\"\" pro',=\"\" consolas,=\"\" menlo,=\"\" monaco,=\"\" 'courier=\"\" new',=\"\" monospace;=\"\" font-size:=\"\" 0.93em;=\"\" color:=\"\" rgb(199,=\"\" 37,=\"\" 78);=\"\" border-radius:=\"\" 4px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;=\"\" background-color:=\"\" rgb(249,=\"\" 242,=\"\" 244);\"=\"\"><spanhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'microsoft=\"\" yahei',=\"\" 'source=\"\" han=\"\" sans=\"\" 'noto=\"\" cjk=\"\" 'wenquanyi=\"\" micro=\"\" hei',=\"\" sans-serif;=\"\" font-size:=\"\" 14px;=\"\" overflow-wrap:=\"\" break-word=\"\" !important;\"=\"\">\n\n<\/spanhelvetica><\/codesource><\/spanhelvetica><\/codesource><\/spanhelvetica><\/codeliberation><\/codeliberation><\/codeliberation><\/codeliberation><\/pre>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/3\/22 17:51:47",
"updatetime":"2019\/4\/25 13:55:47"
},
{
"id":23,
"title":"Webpack配置解说",
"content":"<h2><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/h2><h5>这样设置路由打包出来是home.js异步加载文件<\/h5><h5 style=\"font-weight: normal;\"><\/h5><h2><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><h5 style=\"font-weight: normal;\">{<br>path: '\/home',<br>name: 'home',<br>component: () =&gt; import(<span style=\"color: rgb(194, 79, 74);\">\/* webpackChunkName: \"Home\" *\/<\/span> '..\/views\/Home.vue')<br>  },<\/h5><\/divcourier><\/h2><h2><a href=\"https:\/\/juejin.im\/post\/5de06aa851882572d672c1ad#2_1\">https:\/\/juejin.im\/post\/5de06aa851882572d672c1ad#2_1<\/a>&nbsp;&nbsp;<strong style=\"color: rgb(194, 79, 74);\"><br><\/strong><\/h2><h2><strong style=\"color: rgb(194, 79, 74);\">##webpack<\/strong><\/h2><div><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">loader<\/span>: webpack 只能理解 JavaScript 和 JSON 文件。<strong>loader<\/strong>&nbsp;让 webpack 能够去处理其他类型的文件，并将它们转换为有效<a href=\"https:\/\/webpack.docschina.org\/concepts\/modules\">模块<\/a>，以供应用程序使用，以及被添加到依赖图中。&nbsp;&nbsp;<strong style=\"color: rgb(194, 79, 74);\"><br><\/strong><\/div><div><span style=\"color: rgb(194, 79, 74); font-weight: bold;\">plugin<\/span>:loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。&nbsp;&nbsp;<strong style=\"color: rgb(194, 79, 74);\"><br><\/strong><\/div><div><strong style=\"color: rgb(194, 79, 74);\"><br><\/strong><\/div><h2><strong style=\"color: rgb(194, 79, 74);\">#loader解说<\/strong><\/h2><div><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><div>{<\/div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test:&nbsp;\/.css$\/,<\/div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exclude:&nbsp;\/(node_modules|bower_components)\/,<\/div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use:&nbsp;['style-loader',&nbsp;'css-loader']<\/div><div>}<\/div><div>loader 从右到左地取值(evaluate)\/执行(execute)：css-loader处理css格式的文件，style-loader使用js创建style便签写入样式<br><br><\/div><\/divcourier><\/div><div><strong style=\"color: rgb(194, 79, 74);\"><br><\/strong><\/div><p>##清除已打包的文件(遇到的坑)<\/p><p><span style=\"color: rgb(194, 79, 74);\">（注意：webpack4已经内置这功能了~ 下面针对之前版本）<\/span><br><\/p><p>以前:<br>const CleanWebpackPlugin = require('clean-webpack-plugin')<br>plugins:[<br>        new CleanWebpackPlugin(['dist'])<br>]<br>现在:<br>const {CleanWebpackPlugin} = require('clean-webpack-plugin')<br>plugins:[<br>        new CleanWebpackPlugin()<br>]<\/p><p><br><br><br>##entry可以为字符串，也可以为数组或对象<br>\/\/默认是这样<br>entry:'.\/src\/index.js',  <br>\/\/数组打包为一个main.js<br>entry: ['.\/src\/a.js','.\/src\/b.js']     <br>\/\/对象打包为多个(a.js,b.js...)     <br>entry:{<br>    a:'.\/src\/a.js',<br>    b:'.\/src\/b.js',<br>    ...<br>},<br><br><br>##hash和chunkhash的区别<br>entry:{<br>    a:'.\/src\/a.js',<br>    b:'.\/src\/b.js'<br>},<br>output:{<br>    path:path.resolve(__dirname,'dist'),<br>    filename:'[name].[chunkhash:8].js'<br>}<br>在多文件入口的情况下，选hash的，任意改动一个文件打包生成的所有文件hash都会变化（统一的hash值），都失去缓存作用<br>而chunkhash的话改动一个文件，打包后只更新对应的文件hash，其他文件还是有缓存作用(但当webpack配置文件改动时，所有文件hash都会变化)<br><br><br>##webpack.DefinePlugin插件<br>作用：定义全局变量，定义所有js文件都能访问的变量<br>\/\/webpack.config.js<br>new webpack.DefinePlugin({<br>     'process.env': {<br>          NODE_ENV: JSON.stringify('production')<br>     },<br>     'eric': JSON.stringify('a handsome boy')<br>}),<br>\/\/b.js<br>console.log(process.env.NODE_ENV,eric)    <br><br>编译为：console.log('production','a handsome boy')   <br>不加JSON.stringify的话就变成变量了：console.log(production,a handsome boy)  <br>webpack4后可以直接配置mode(默认为production)，这时就不需要用插件定义process.env.NODE_ENV了<br><br>#热更新<\/p><div><span>devServer: {<\/span><\/div><div><span>        port: <\/span><span>8081<\/span><span>,<\/span><\/div><div><span>        contentBase: <\/span><span>'.\/src'<\/span><span>,<\/span><\/div><div><span>        hot:<\/span><span>true<\/span><span>,&nbsp; &nbsp; &nbsp;\/\/ 和 inline: true&nbsp; 一样都是自动刷新(区别在于hot开启后比inline多了HMR模块热更新)<\/span><\/div><div><span>        open: <\/span><span>true&nbsp; \/\/ 自动打开浏览器<\/span><\/div><div><span>    },<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><br><br>##webpack性能优化<br>chunk分离（设置多入口）<br><br>#tree-shaking<br>没副作用的情况下，才可以用<br>生产环境才能用<br><\/p><p><strong><br><\/strong><\/p><p><strong>#webpack按需加载原理，运用esmodule的import('xxx')<\/strong><\/p><div><div><p>原理很简单，就是利用的 jsonp 的实现原理加载模块，只是在这里并不是从 server 拿数据而是从其他模块中<\/p>\n<ol>\n<li>调用模块时会在 <code>window<\/code> 上注册一个 <code>webpackJsonp<\/code> 数组，window['webpackJsonp'] = window['webpackJsonp'] || []<\/li>\n<li>当我们 <code>import<\/code>时，<code>webpack<\/code> 会调用 <code>__webpack_require__.e(0)<\/code> 方法，也就是 <code>requireEnsure<\/code><\/li>\n<li><code>webpack<\/code> 会动态创建一个 <code>script<\/code> 标签去加载这个模块，加载成功后会将该模块注入到 <code>webpackJsonp<\/code> 中<\/li>\n<li><code>webpackJsonp.push<\/code> 会调用 <code>webpackJsonpCallback<\/code> 拿到模块<\/li>\n<li>模块加载完（then）再使用 <code>__webpack_require__<\/code> 获取模块<\/li><\/ol><\/div><br><\/div><p><strong><br><\/strong><\/p><h2><strong style=\"color: rgb(194, 79, 74);\">##babel<\/strong><\/h2><p><strong>babel可以将当前运行平台(浏览器、node服务器)尚不支持的下一代或几代js语法编译为当前支持的js语法版本，比如可以把es6 es7和es8的js代码编译为es5的代码。<\/strong><\/p><p>&nbsp;<\/p><p><strong>需要明确的几个概念：<\/strong><\/p><p>&nbsp;<\/p><ul><li>es2015 === es6<\/li><li>es2016 === es7<\/li><li>es2017 === es8<\/li><\/ul><p>&nbsp;<\/p><p>&nbsp;<\/p><p><strong>plugin: babel的插件，在6.x版本之后babel必需要配合插件来进行工作<\/strong><\/p><p><strong>preset: babel插件集合的预设，包含某一部分的插件plugin<\/strong><\/p><p>&nbsp;<\/p><div><pre>{\n  \"plugins\": [\"transform-es2015-arrow-functions\"]，\n  \"presets\": [\"es2015\"]\n}<\/pre><\/div><p>&nbsp;<\/p><p>babel-preset-es2015: 可以将es2015即es6的js代码编译为es5<\/p><p>babel-preset-es2016: 可以将es2016即es7的js代码编译为es6<\/p><p>babel-preset-es2017: 可以将es2017即es8的js代码编译为es7<\/p><p>babel-preset-stage-x: 可以将处于某一阶段的js语法编译为正式版本的js代码<\/p><p>stage-X: 指处于某一阶段的js语言提案。<\/p><ul><li>提案共分为五个阶段：<\/li><li><em>stage-0: 稻草人-只是一个大胆的想法<\/em><\/li><li><em>stage-1: 提案-初步尝试<\/em><\/li><li><em>stage-2: 初稿-完成初步规范<\/em><\/li><li><em>stage-3: 候选-完成规范和浏览器初步实现<\/em><\/li><li><em>stage-4: 完成-将被添加到下一年发布<\/em><\/li><\/ul><p>&nbsp;<\/p><p><strong>当前 babel 推荐使用 babel-preset-env 替代 babel-preset-es2015 和 babel-preset-es2016 以及 babel-preset-es2017 ,env的支持范围更广，包含es2015 es2016 es2017的所有语法编译，并且它可以根据项目运行平台的支持情况自行选择编译版本。<\/strong><\/p><p>使用方法： '.babelrc' 中 'es2015' 改为 'env'，<\/p><div><pre>.babelrc<br><br>{\n  \"presets\": [\"env\", \"stage-2\"]\n}<\/pre><\/div><p>&nbsp;<\/p><p><strong>插件中每个访问者都有排序问题。<\/strong><\/p><p>这意味着如果两次转译都访问相同的”程序”节点，则转译将按照 plugin 或 preset 的规则进行排序然后执行。<\/p><ul><li>Plugin 会运行在 Preset 之前。<\/li><li>Plugin 会从第一个开始顺序执行。ordering is first to last.<\/li><li>Preset 的顺序则刚好相反(从最后一个逆序执行)。<\/li><\/ul><p><br><\/p><p><br><\/p><h2><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">#webpack调试<\/span><\/h2><div><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><div>\"dev\":&nbsp;\"webpack-dev-server&nbsp;--mode&nbsp;development\",<\/div><div>改为<\/div><div><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\">\"dev\":&nbsp;\"node&nbsp;--inspect-brk=<span style=\"color: rgb(194, 79, 74);\">5858<\/span>&nbsp;.\/node_modules\/webpack-dev-server\/bin\/webpack-dev-server&nbsp;--mode&nbsp;development\",<br><\/divcourier><\/div><div><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\">vscode的launch.json<\/divcourier><\/div><div><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><div>{<\/div><div>&nbsp;&nbsp;\"version\":&nbsp;\"0.2.0\",<\/div><div>&nbsp;&nbsp;\"configurations\":&nbsp;[{<\/div><div>&nbsp;&nbsp;&nbsp;&nbsp;\"type\":&nbsp;\"node\",<\/div><div>&nbsp;&nbsp;&nbsp;&nbsp;\"request\":&nbsp;\"launch\",<\/div><div>&nbsp;&nbsp;&nbsp;&nbsp;\"name\":&nbsp;\"dev-webpack\",<\/div><div>&nbsp;&nbsp;&nbsp;&nbsp;\"runtimeExecutable\":&nbsp;\"npm\",<\/div><div>&nbsp;&nbsp;&nbsp;&nbsp;\"runtimeArgs\":&nbsp;[\"run\",&nbsp;\"dev\"],<\/div><div>&nbsp;&nbsp;&nbsp;&nbsp;\"port\":&nbsp;<span style=\"color: rgb(194, 79, 74);\">5858<\/span><\/div><div>&nbsp;&nbsp;}]<\/div><div>}<\/div><\/divcourier><\/divcourier><\/div><\/divcourier><\/div><div><span style=\"font-weight: bold; color: rgb(194, 79, 74);\"><br><\/span><\/div><h2><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">#插件解说<\/span><\/h2><div><div><h3>Webpack 插件组成<\/h3>\n<p>在自定义插件之前，我们需要了解，一个 Webpack 插件由哪些构成，下面摘抄文档：<\/p>\n<ul>\n<li>一个具名 JavaScript 函数；<\/li>\n<li>在它的原型上定义&nbsp;apply&nbsp;方法；<\/li>\n<li>指定一个触及到 Webpack 本身的<a target=\"_blank\" href=\"https:\/\/webpack.docschina.org\/api\/compiler-hooks\/\" rel=\"nofollow noopener noreferrer\">事件钩子<\/a>；<\/li>\n<li>操作 Webpack 内部的实例特定数据；<\/li>\n<li>在实现功能后调用 Webpack 提供的 callback。<\/li><\/ul><\/div><div><div><h3>选择插件触发时机<\/h3>\n<p>选择插件触发时机，其实是选择插件触发的 compiler 钩子（即何时触发插件）。<br>Webpack 提供钩子有很多，这里简单介绍几个，完整具体可参考文档《<a target=\"_blank\" href=\"https:\/\/webpack.js.org\/api\/compiler-hooks\/\" rel=\"nofollow noopener noreferrer\">Compiler Hooks<\/a>》：<\/p>\n<ul>\n<li><code>entryOption<\/code>&nbsp;: 在 webpack 选项中的 <code>entry<\/code> 配置项 处理过之后，执行插件。<\/li>\n<li><code>afterPlugins<\/code>&nbsp;:&nbsp;设置完初始插件之后，执行插件。<\/li>\n<li><code>compilation<\/code>&nbsp;:&nbsp;编译创建之后，生成文件之前，执行插件。。<\/li>\n<li><code>emit<\/code>&nbsp;:&nbsp;生成资源到 <code>output<\/code> 目录之前。<\/li>\n<li><code>done<\/code>&nbsp;:&nbsp;编译完成。<\/li><\/ul><\/div><a href=\"https:\/\/juejin.im\/post\/5e5309ece51d4526e03f9e53\">https:\/\/juejin.im\/post\/5e5309ece51d4526e03f9e53<\/a>&nbsp;&nbsp;<br><\/div><\/div>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/3\/28 10:29:39",
"updatetime":"2020\/5\/15 17:10:25"
},
{
"id":26,
"title":"nodejs 通过nginx后出现响应慢的解决方法",
"content":"<div id=\"cnblogs_post_body\"><p>最近用了nodejs搭建服务器，然后用了nginx做了反向代理，项目开发需求，没办法。但是发现了经过代理之后发现网页请求变慢了，而且是不能忍的一分钟以上。<\/p><p>&nbsp; &nbsp; 一开始，怀疑是在nodejs那边的问题，结果在nodejs那边进行了判断（通过写测试代码），但是发现是经过了一分多钟请求才到nodejs这边，那么只能先排除nodejs这方面的问题。<\/p><p>&nbsp; &nbsp; 那么要排除nginx的问题，我的环境是 windows7(x64) nginx(1.62) &nbsp;nodejs(4.23)，配置如下<\/p><div><div id=\"highlighter_658770\"><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><div>1<\/div><div>2<\/div><div>3<\/div><div>4<\/div><div>5<\/div><div>6<\/div><div>7<\/div><div>8<\/div><div>9<\/div><div>10<\/div><div>11<\/div><div>12<\/div><div>13<\/div><\/td><td><div><div><code>server {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>listen 80;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>server_name mysite.com;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>location \/ {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_set_header&nbsp;&nbsp;&nbsp; X-Real-IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $remote_addr;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_set_header&nbsp;&nbsp;&nbsp; X-Forwarded-For&nbsp;&nbsp;&nbsp;&nbsp; $proxy_add_x_forwarded_for;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_set_header&nbsp;&nbsp;&nbsp; Host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $http_host;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_set_header&nbsp;&nbsp;&nbsp; X-NginX-Proxy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <\/code><code>true<\/code><code>;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_set_header&nbsp;&nbsp;&nbsp; Connection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <\/code><code>\"\"<\/code><code>;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_http_version&nbsp; 1.1;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_pass&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http:<\/code><code>\/\/localhost<\/code><code>:3333;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>}<\/code><\/div><div><code>}<\/code><\/div><\/div><\/td><\/tr><\/tbody><\/table><\/div><\/div><p>&nbsp; &nbsp; 这是一个比较普通的配置，找不出来问题，那么只能去找错误日志了，突然发现错误日志error.log里面有这么一段代码<\/p><blockquote>2015\/12\/25 16:30:43 [error] 7652#7008: *1 upstream timed out (10060: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond) while connecting to upstream, client: 127.0.0.1, server<\/blockquote><p>&nbsp; &nbsp; 之前没怎么留意错误日志，罪过了啊，那么既然发现了这个错误，找方法就简单多了。<\/p><p>&nbsp; &nbsp; 像是nodejs那边没有给nginx及时响应，那么可以增加这几个配置来解决（单位为秒）<\/p><div><div id=\"highlighter_237938\"><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><div>1<\/div><div>2<\/div><div>3<\/div><\/td><td><div><div><code>proxy_connect_timeout 1; <\/code><\/div><div><code>proxy_send_timeout 30; <\/code><\/div><div><code>proxy_read_timeout 60;<\/code><\/div><\/div><\/td><\/tr><\/tbody><\/table><\/div><\/div><p>&nbsp;<\/p><p>&nbsp; &nbsp; 这三个设置的定义是：<\/p><p>&nbsp;&nbsp;&nbsp;&nbsp;proxy_connect_timeout<br>&nbsp;&nbsp;&nbsp;&nbsp;后端服务器连接的超时时间_发起握手等候响应超时时间<br><br>&nbsp;&nbsp;&nbsp;&nbsp;proxy_read_timeout<br>&nbsp;&nbsp;&nbsp;&nbsp;连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）<br><br>&nbsp;&nbsp;&nbsp;&nbsp;proxy_send_timeout<br>&nbsp;&nbsp;&nbsp;&nbsp;后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据<br><\/p><p>&nbsp;&nbsp;&nbsp;&nbsp;添加之后，就解决了，完整的是：<\/p><div><div id=\"highlighter_779238\"><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td><div>1<\/div><div>2<\/div><div>3<\/div><div>4<\/div><div>5<\/div><div>6<\/div><div>7<\/div><div>8<\/div><div>9<\/div><div>10<\/div><div>11<\/div><div>12<\/div><div>13<\/div><div>14<\/div><div>15<\/div><div>16<\/div><\/td><td><div><div><code>server {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>listen 80;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>server_name mysite.com;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>location \/ {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_set_header&nbsp;&nbsp;&nbsp; X-Real-IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $remote_addr;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_set_header&nbsp;&nbsp;&nbsp; X-Forwarded-For&nbsp;&nbsp;&nbsp;&nbsp; $proxy_add_x_forwarded_for;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_set_header&nbsp;&nbsp;&nbsp; Host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $http_host;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_set_header&nbsp;&nbsp;&nbsp; X-NginX-Proxy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <\/code><code>true<\/code><code>;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_set_header&nbsp;&nbsp;&nbsp; Connection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <\/code><code>\"\"<\/code><code>;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_http_version&nbsp; 1.1;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_connect_timeout 1; <\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_send_timeout 30; <\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_read_timeout 60;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>proxy_pass&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http:<\/code><code>\/\/localhost<\/code><code>:3333;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>}<\/code><\/div><div><code>}<\/code><\/div><\/div><\/td><\/tr><\/tbody><\/table><\/div><\/div><p><br><\/p><p><br><\/p><p>&nbsp;&nbsp;&nbsp;&nbsp;<\/p><p><br><\/p><p><br><\/p><\/div><div id=\"MySignature\">保持一颗好奇的心<\/div>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/4\/8 11:25:58",
"updatetime":"2019\/4\/8 11:25:58"
},
{
"id":27,
"title":"mysql",
"content":"<div style=\"text-align: left;\"><span style=\"color: rgb(194, 79, 74);\">\/\/ 这种方法就不用转逗号转义<\/span><br><\/div><div>exports.update&nbsp;=&nbsp;(array)&nbsp;=&gt;&nbsp;{<\/div><div>let&nbsp;_sql&nbsp;=&nbsp;`update posts set title=?,content=?,type=? where id=?`<\/div><div>return&nbsp;query(_sql,&nbsp;array)<\/div><p><divcourier new\\\\',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div>}<\/div>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/4\/16 11:21:40",
"updatetime":"2019\/4\/19 13:42:24"
},
{
"id":29,
"title":"又是你闭包",
"content":"<ol><li>高级程序设计三中:<span style=\"font-weight: bold; color: rgb(194, 79, 74);\">闭包是指有权访问另外一个函数作用域中的变量的函数<\/span>.可以理解为(<strong>能够读取其他函数内部变量的函数<\/strong>)&nbsp;<\/li><li><strong>闭包的作用:<\/strong>&nbsp;正常函数执行完毕后,里面声明的变量被垃圾回收处理掉,但是闭包可以让作用域里的 变量,在函数执行完之后依旧保持没有被垃圾回收处理掉&nbsp;<\/li><li>这就是闭包最重要的两个用处，一个是<span style=\"color: rgb(194, 79, 74);\">可以读取函数内部的变量<\/span>，另一个就是<span style=\"color: rgb(194, 79, 74);\">让这些变量的值始终保持在内存中<\/span>。&nbsp;&nbsp;<\/li><li><strong>接下来通过一个实例来感受一下闭包的作用（计数器）:<\/strong>&nbsp;<pre><code><p>var count = 0;<\/p>function add() {<br>  count = count + 1;<br>  console.log(count);<br>}<br>add(); \/\/确实实现了需求<br>\/\/但是如果需要第二个计数器呢?<br>\/\/难道要如下这样写吗?<br>var count1 = 0;<br><br>function add1() {<br>  count1 = count1 + 1;<br>  console.log(count1);<br>}<br>add1(); \/\/确实实现了需求<\/code><\/pre><p>正确的姿势应该是：<\/p><pre><code><span style=\"font-size: 1em;\">function addCount() {<\/span><br>   var conut = 0;<br>  return function() {<br>    count = count + 1;<br>    console.log(count);<br>  };<br>}<\/code><\/pre><p>测试：这里解释一下上边的过程: addCount() 执行的时候,&nbsp;<strong>返回一个函数<\/strong>, 函数是可以<strong>创建自己的作用域的<\/strong>, 但是此时返回的这个函数内部需要引用 addCount()&nbsp;<strong>作用域下的变量 count<\/strong>,&nbsp;<strong>因此这个 count 是不能被销毁的<\/strong>.接下来需要几个计数器我们就定义几个变量就可以,<strong>并且他们都不会互相影响,每个函数作用域中还会保存 count 变量不被销毁,进行不断的累加<\/strong><\/p><pre><code><p>var fun1 = addCount();<\/p>fun1(); \/\/1<br>fun1(); \/\/2<br>var fun2 = addCount();<br>fun2(); \/\/1<br>fun2(); \/\/2<\/code><\/pre><p><br><\/p><\/li><li><h3><span style=\"font-weight: bold;\">闭包应用<\/span><\/h3><\/li><\/ol><p>&nbsp; &nbsp; &nbsp; 防抖节流<\/p><p>&nbsp; &nbsp; &nbsp; 单例模式<\/p><p>&nbsp; &nbsp; &nbsp; generator的执行器<\/p><p>&nbsp; &nbsp; &nbsp; 迭代器&nbsp;&nbsp;<br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/4\/22 14:57:37",
"updatetime":"2020\/5\/12 22:07:17"
},
{
"id":30,
"title":"被疏忽的知识点~~多看看咯",
"content":"<h4><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><span style=\"font-weight: normal;\">浏览器内核代表有 Trident（IE），Gecko（firefox），Webkit（Safari chrome 等）以及 Presto（opera)&nbsp; ，分为渲染引擎和js引擎。<\/span><\/codemicrosoft><\/h4><div><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\">渲染引擎 （看看【<\/codemicrosoft>你不知道的浏览器页面渲染机制<codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\">】<\/codemicrosoft><a href=\"https:\/\/juejin.im\/post\/5ca0c0abe51d4553a942c17d\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/juejin.im\/post\/5ca0c0abe51d4553a942c17d<\/a>）<\/div><div><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\">常用的javascript引擎有v8&nbsp;<span style=\"font-weight: normal;\"><br><\/span><\/codemicrosoft><\/div><h2><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><br><\/codemicrosoft><\/h2><h2><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\">谈及跨域，可以扯到 nginx, cors，postMessage，websocket等~~<\/codemicrosoft><\/h2><p><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\">CORS是一个 <codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\">W3C标准，全称是\"跨域资源共享\" <codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\">（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 <codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\">XMLHttpRequest请求。<\/codemicrosoft><\/codemicrosoft><\/codemicrosoft><\/codemicrosoft><\/p><p><span style=\"font-weight: bold;\">服务端设置 <\/span><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><span style=\"font-weight: bold;\">Access-Control-Allow-Origin就可以开启 <\/span><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><span style=\"font-weight: bold;\">CORS。<\/span>该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。<\/codemicrosoft><\/codemicrosoft><\/p><p><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><br><\/codemicrosoft><\/codemicrosoft><\/p><p><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><h3source code=\"\" pro',=\"\" consolas,=\"\" inconsolata,=\"\" 'ubuntu=\"\" mono',=\"\" 'dejavu=\"\" sans=\"\" 'courier=\"\" new',=\"\" 'droid=\"\" 'hiragino=\"\" gb',=\"\" 微软雅黑,=\"\" monospace=\"\" !important;=\"\" background-color:=\"\" rgb(255,=\"\" 255,=\"\" 255);\"=\"\"><span>postMessage跨域<\/span><\/h3source><\/codemicrosoft><\/codemicrosoft><\/p><p><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><span>postMessage()<\/span><span>方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。<\/span><\/codemicrosoft><\/p><ol><li><p><span><code><span>\/\/捕获iframe<\/span><\/code><\/span><\/p><\/li><li><p><span><code><span>var<\/span><span> domain = <\/span><span>'http:\/\/scriptandstyle.com'<\/span><span>;<\/span><\/code><\/span><\/p><\/li><li><p><span><code><span>var<\/span><span> iframe = document.getElementById(<\/span><span>'myIFrame'<\/span><span>).contentWindow;<\/span><\/code><\/span><\/p><\/li><li><p><br><\/p><\/li><li><p><span><code><span>\/\/发送消息<\/span><\/code><\/span><\/p><\/li><li><p><span><code><span>setInterval(<\/span><span>function<\/span><span>(){<\/span><\/code><\/span><\/p><\/li><li><p><span><code><span>    <\/span><span>var<\/span><span> message = <\/span><span>'Hello!  The time is: '<\/span><span> + (<\/span><span>new<\/span><span> <\/span><span>Date<\/span><span>().getTime());<\/span><\/code><\/span><\/p><\/li><li><p><span><code><span>    console.log(<\/span><span>'blog.local:  sending message:  '<\/span><span> + message);<\/span><\/code><\/span><\/p><\/li><li><p><span><code><span>        <\/span><span>\/\/send the message and target URI<\/span><\/code><\/span><\/p><\/li><li><p><span><code><span>    iframe.postMessage(message,domain);<\/span><\/code><\/span><\/p><\/li><li><p><span><code><span>},<\/span><span>6000<\/span><span>);<\/span><\/code><\/span><\/p><\/li><\/ol><ol><li><p><span><code><span>\/\/响应事件<\/span><\/code><\/span><\/p><\/li><li><p><span><code><span>window.addEventListener(<\/span><span>'message'<\/span><span>,<\/span><span>function<\/span><span>(event) {<\/span><\/code><\/span><\/p><\/li><li><p><span><code><span>    <\/span><span>if<\/span><span>(event.origin !== <\/span><span>'http:\/\/davidwalsh.name'<\/span><span>) <\/span><span>return<\/span><span>;<\/span><\/code><\/span><\/p><\/li><li><p><span><code><span>    console.log(<\/span><span>'message received:  '<\/span><span> + event.data,event);<\/span><\/code><\/span><\/p><\/li><li><p><span><code><span>    event.source.postMessage(<\/span><span>'holla back youngin!'<\/span><span>,event.origin);<\/span><\/code><\/span><\/p><\/li><li><p><span><code><span>},<\/span><span>false<\/span><span>);<\/span><\/code><\/span><\/p><\/li><\/ol><p><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><h3source code=\"\" pro',=\"\" consolas,=\"\" inconsolata,=\"\" 'ubuntu=\"\" mono',=\"\" 'dejavu=\"\" sans=\"\" 'courier=\"\" new',=\"\" 'droid=\"\" 'hiragino=\"\" gb',=\"\" 微软雅黑,=\"\" monospace=\"\" !important;=\"\" background-color:=\"\" rgb(255,=\"\" 255,=\"\" 255);\"=\"\"><premicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 1px=\"\" solid=\"\" rgb(226,=\"\" 226,=\"\" 226)=\"\" background:=\"\" rgb(241,=\"\" 239,=\"\" 238);\"=\"\"><premicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 1px=\"\" solid=\"\" rgb(226,=\"\" 226,=\"\" 226)=\"\" background:=\"\" rgb(241,=\"\" 239,=\"\" 238);\"=\"\"><\/premicrosoft><\/premicrosoft><\/h3source><\/codemicrosoft><\/codemicrosoft><\/p><p><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><span>postMessage<\/span><span>跨域适用于以下场景：<\/span><span>同浏览器多窗口间跨域通信、 <\/span><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><span>iframe<\/span><span>间跨域通信。<\/span><\/codemicrosoft><\/codemicrosoft><\/p><p><br><\/p><p><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><span><br><\/span><\/codemicrosoft><\/codemicrosoft><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/4\/25 11:46:11",
"updatetime":"2020\/3\/14 10:28:27"
},
{
"id":31,
"title":"页面性能优化",
"content":"<p><a href=\"https:\/\/mp.weixin.qq.com\/s?__biz=MzUxMTcwOTM4Mg==&amp;mid=2247483962&amp;idx=1&amp;sn=f9337ad983c6303811eb43d07d9f23d5&amp;chksm=f96edb93ce195285943211e645cc683989826abdaaa8ab0b073a20761369ed04843c835c50b7#rd\" target=\"_blank\">嗨，送你一张Web性能优化地图<\/a><br><\/p><p><br><\/p><p>性能优化主要涉及<span style=\"color: rgb(194, 79, 74);\">【网络层面和渲染层面】的优化<\/span><\/p><p><span style=\"color: rgb(194, 79, 74);\">网络层面<\/span>1.DNS解析 2.TCP连接 3. HTTP请求\/响应&nbsp;<\/p><p>【前面两个环节前端能做的有限，主要核心在第三点】HTTP请求\/响应，优化分为以下两个方向：<\/p><p>1. 减少http请求【雪碧图啊，css\/js合并，合理利用缓存第二次减少请求】<\/p><p>2. 减少单次请求所花费的时间【资源压缩【还有个gzip压缩】，使用cdn快速获取静态资源】<\/p><p><span style=\"color: rgb(194, 79, 74);\">可以看下这里的性能优化<\/span><a href=\"https:\/\/mp.weixin.qq.com\/s\/sWoACpZqWmTs88-RHG29ZQ\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/mp.weixin.qq.com\/s\/sWoACpZqWmTs88-RHG29ZQ<\/a>&nbsp;&nbsp;<\/p><p>资源压缩涉及到<span style=\"color: rgb(194, 79, 74);\">webpack，<\/span>优化分为以下两个方向：<\/p><p>1.加快构建速度，提高工作效率<\/p><p>2.减少打包后的体积&nbsp;<a href=\"https:\/\/www.aiheart.top\/eblog\/#\/blog\/detail\/53?type=\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/www.aiheart.top\/eblog\/#\/blog\/detail\/53?type=<\/a><\/p><p><span style=\"color: rgb(194, 79, 74);\">渲染层面<\/span>&nbsp;&nbsp;<span style=\"color: rgb(194, 79, 74);\"><br><\/span><\/p><p><span style=\"font-weight: bold;\">代码优化【vue项目】<\/span><\/p><h3>#你了解哪些Vue性能优化方法？<\/h3><p>0.不要把所有数据都放到data里，data里所有数据都会添加getter和setter，会收集对应的watcher。对于长列表只展示的，可以用computed计算属性直接return 数组就好。或者参考第5点<\/p><p>1.合理使用路由懒加载和异步组件<\/p><p>const router = new VueRouter({ routes: [ { path: '\/foo', component: () =&gt;&nbsp;import('.\/Foo.vue') } ] })&nbsp;<\/p><p>2.单页应用多用keep-alive缓存组件<br><\/p><p>3.频繁切换的元素用v-show不用v-if<\/p><p>4.v-for 遍历避免同时使用 v-if，v-for需要给每项元素绑定事件可以用事件代理<\/p><p>5.长列表性能优化&nbsp; Object.freeze(users)&nbsp; var obj= {a:1}&nbsp; &nbsp;Object.freeze(obj)&nbsp; &nbsp;new Vue({el:'#app', data:obj })&nbsp;<\/p><p>6.事件的销毁定时器，绑定事件【原生绑定的事件，eventbus的$off】<\/p><p>created() { this.timer = setInterval(this.refresh, 2000) }, beforeDestroy() { clearInterval(this.timer) }&nbsp;<\/p><p>7.图片懒加载&nbsp;<a target=\"_blank\" href=\"https:\/\/github.com\/hilongjw\/vue-lazyload\" rel=\"nofollow noopener noreferrer\">vue-lazyload<\/a><\/p><p>8.用Map表代替大量的if-else和switch会提升性能<\/p><p>9.某些场景可以考虑用weakMap或weakSet弱引用对象，避免内存泄漏<\/p><p>10.滚动到可视区域动态加载vue-virtual-scroll-<\/p><p><span style=\"font-weight: bold;\">代码优化【非mvvm项目】<\/span><\/p><p>懒加载，减少dom操作以尽量避免重绘回流(repaint reflow), 可以用文档碎片(DocumentFragment) 事件委托，异步加载js，有些场景用weakSet，weakMap避免内存泄漏。更多可参考<a href=\"https:\/\/www.cnblogs.com\/xianyulaodi\/p\/5755079.html\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">雅虎军规<\/a><\/p><p><img src=\"https:\/\/user-gold-cdn.xitu.io\/2018\/10\/23\/1669f5358f63c0f8?imageView2\/0\/w\/1280\/h\/960\/format\/webp\/ignore-error\/1\" style=\"max-width:100%;\"><span style=\"font-weight: bold;\"><br><\/span><\/p><p><a href=\"https:\/\/www.aiheart.top\/eblog\/#\/blog\/detail\/53?type=1\" target=\"_blank\">webpack极限配置<\/a><\/p><p><span style=\"color: rgb(194, 79, 74);\">面试性能优化谈论路线【掘金】：<\/span><a href=\"https:\/\/juejin.im\/book\/5b936540f265da0a9624b04b\/section\/5b97cd22e51d450e8f5f6375\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/juejin.im\/book\/5b936540f265da0a9624b04b\/section\/5b97cd22e51d450e8f5f6375<\/a><\/p><p><span style=\"font-weight: bold;\">#垃圾回收机制<\/span><\/p><h5><span style=\"font-weight: normal;\">哪些情况会引起内存泄漏？<\/span><\/h5><div><h4>1. 意外的全局变量<\/h4><\/div><p>全局变量的生命周期最长，直到页面关闭前，它都存活着，所以全局变量上的内存一直都不会被回收<\/p><p>当全局变量使用不当，没有及时回收（手动赋值 null），或者拼写错误等将某个变量挂载到全局变量时，也就发生内存泄漏了。<\/p><h4>2. 遗忘的定时器<\/h4><p>由于定时器持有该页面部分引用而造成页面无法正常被回收，从而导致内存泄漏了&nbsp;<\/p><h4>3. 使用不当的闭包<\/h4><p>不宜烂用就是了&nbsp;<\/p><p><span style=\"font-weight: bold;\">如何避免内存泄漏？&nbsp;<\/span><br><\/p><p>1. 不要滥用闭包<br><\/p><p>2. 用weakSet或weakMap弱引用，意思是引用的对象不可到达的话，就会被垃圾回收机制释放内存。<\/p><p>3. 像vue项目，组件销毁前清除定时器，解除window的事件绑定<\/p><p>beforeDestroyed () {\n    window.removeEventListener('resize', this.getScale);\n}&nbsp;&nbsp;<br><\/p><p><br><\/p><p>这份优化清单，你都做了吗？<a href=\"https:\/\/juejin.im\/post\/5bbaeb48f265da0aca3323c1\">https:\/\/juejin.im\/post\/5bbaeb48f265da0aca3323c1<\/a>&nbsp;&nbsp;<br><\/p><p><br><\/p><p>defer&nbsp;与相比普通&nbsp;script，有两点区别：<strong>载入&nbsp;JavaScript&nbsp;文件时不阻塞&nbsp;HTML&nbsp;的解析，执行阶段被放到&nbsp;HTML&nbsp;标签解析完成之后；<\/strong><strong>在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载。<\/strong>&nbsp;<\/p><p>把&nbsp;DOM&nbsp;和&nbsp;JavaScript&nbsp;各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能&nbsp;JavaScript》<\/p><p>过“桥”要收费——这个开销本身就是不可忽略的。我们每操作一次&nbsp;DOM（不管是为了修改还是仅仅为了访问其值），都要过一次“桥”。过“桥”的次数一多，就会产生比较明显的性能问题。因此“减少&nbsp;DOM&nbsp;操作”的建议，并非空穴来风。&nbsp;<br><\/p><p>基于上面介绍的浏览器渲染原理，DOM&nbsp;和&nbsp;CSSOM&nbsp;结构构建顺序，初始化可以对页面渲染做些优化，提升页面性能。<\/p><p><span style=\"font-weight: bold;\">注意 async 与 defer 属性对于 inline-script 都是无效的，所以下面这个示例中三个 script 标签的代码会从上到下依次执行。&nbsp;<\/span>&nbsp;<br><\/p><div><span>&lt;<\/span><span>script<\/span><span>&nbsp;<\/span><span>defer<\/span><span>&gt;<\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'a'<\/span><span>)<\/span><span>&lt;\/<\/span><span>script<\/span><span>&gt;<\/span><\/div><div><span>&lt;<\/span><span>script<\/span><span>&nbsp;<\/span><span>async<\/span><span>&gt;<\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'b'<\/span><span>)<\/span><span>&lt;\/<\/span><span>script<\/span><span>&gt;<\/span><\/div><div><span>&lt;<\/span><span>script<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'c'<\/span><span>)<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>&lt;\/<\/span><span>script<\/span><span>&gt;<\/span><\/div><p><span style=\"font-weight: bold;\">改成src方式引进就生效<\/span><\/p><p><br><\/p><li><p><span style=\"color: rgb(194, 79, 74);\">JS优化<\/span>：&nbsp;<codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\">&lt;script&gt;&nbsp;标签加上&nbsp;defer属性&nbsp;和&nbsp;async属性&nbsp;用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。&nbsp;defer属性：&nbsp;用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。&nbsp;async属性：&nbsp;HTML5新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。<\/codemicrosoft><\/p><\/li><p><ulhelvetica neue',=\"\" 'pingfang=\"\" sc',=\"\" 'hiragino=\"\" sans=\"\" gb',=\"\" 'microsoft=\"\" yahei=\"\" ui',=\"\" yahei',=\"\" arial,=\"\" sans-serif;=\"\" font-size:=\"\" 17px;=\"\" font-style:=\"\" normal;=\"\" font-variant:=\"\" font-weight:=\"\" letter-spacing:=\"\" 0.544000029563904px;=\"\" line-height:=\"\" 27.2000007629395px;=\"\" orphans:=\"\" auto;=\"\" text-align:=\"\" justify;=\"\" text-indent:=\"\" 0px;=\"\" text-transform:=\"\" none;=\"\" white-space:=\"\" widows:=\"\" 1;=\"\" word-spacing:=\"\" -webkit-text-stroke-width:=\"\" list-style-type:=\"\" square;=\"\" background-color:=\"\" rgb(255,=\"\" 255,=\"\" 255);\"=\"\"><\/ulhelvetica><\/p><li><p><span style=\"color: rgb(194, 79, 74);\">CSS优化<\/span>：&nbsp;<codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><span>&lt;link&gt;<\/span>&nbsp;标签的 rel属性 中的属性值设置为 preload 能够让你在你的HTML页面中可以指明哪些资源是在页面加载完成后即刻需要的,最优的配置加载顺序，提高渲染性能<\/codemicrosoft><\/p><\/li><li><p><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><span style=\"color: rgb(194, 79, 74);\">运用雪碧图<\/span> 在线<\/codemicrosoft>自动化生成雪碧图&nbsp;<codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\">&nbsp;<\/codemicrosoft><a href=\"https:\/\/www.toptal.com\/developers\/css\/sprite-generator\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">CSS Sprites<\/a>&nbsp; &nbsp;&nbsp;<a href=\"https:\/\/juejin.im\/post\/59bb864b5188257e7a427c09\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">webpack+svg sprite<\/a><\/p><\/li><li><p><span style=\"color: rgb(77, 128, 191);\">掘金<\/span>网站性能优化实战——从12.67s到1.06s的故事：<a href=\"https:\/\/juejin.im\/post\/5b0b7d74518825158e173a0c\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/juejin.im\/post\/5b0b7d74518825158e173a0c<\/a><\/p><\/li><li><p><span style=\"color: rgb(194, 79, 74);\">缓存：Xmind&nbsp;&nbsp;<\/span><a href=\"https:\/\/www.aiheart.top\/eblog\/assets\/html\/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.html\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">浏览器缓存机制<\/a>&nbsp; &nbsp;&nbsp;<a href=\"https:\/\/www.aiheart.top\/eblog\/assets\/html\/%E7%BC%93%E5%AD%98.html\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">缓存<\/a><\/p><\/li>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/4\/25 15:20:25",
"updatetime":"2020\/5\/12 18:31:39"
},
{
"id":33,
"title":"框架的对比+MVVM定义",
"content":"<p><span style=\"font-weight: bold;\">## MVC的定义<\/span><br><\/p><p>MVC是Model-View- Controller的简写。即模型-视图-控制器。M和V指的意思和MVVM中的M和V意思一样。C即Controller指的是页面业务逻辑。使用MVC的目的就是将M和V的代码分离。‘MVC是<span style=\"color: rgb(194, 79, 74);\">单向通信<\/span>。也就是View跟Model，必须通过Controller来承上启下。MVC和MVVM的区别并不是VM完全取代了C，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。也就是说MVVM实现的是业务逻辑组件的重用。由于mvc出现的时间比较早，前端并不那么成熟，很多业务逻辑也是在后端实现，所以前端并没有真正意义上的MVC模式。而我们今天再次提起MVC，是因为大前端的来到，出现了MVVM模式的框架，我们需要了解一下MVVM这种设计模式是如何一步步演变过来的。<\/p><p><span style=\"color: rgb(194, 79, 74);\">【传统的MVC【前端到后台，统一称MVC】就是，用户操作服务器路由，路由会调用对应的控制器处理获取数据，结果返回前端，页面重新渲染】<\/span><\/p><p><br><span style=\"font-weight: bold;\">## Mvvm定义<\/span><br>MVVM是Model-View-ViewModel的简写。即模型-视图-视图模型。【模型】指的是后端传递的数据。【视图】指的是所看到的页面。【视图模型】mvvm模式的核心，它是连接view和model的桥梁。它有两个方向：一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。总结：在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。<\/p><p><br><\/p><p><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">【MVC数据状态多的时候，需要大量的dom操作影响页面性能，MVVM则不是，改变viewModel就可以更新到view上】<\/span><br><br><\/p><p><span style=\"font-weight: bold;\">##React与Vue的对比<\/span><br><br>不同点：<\/p><p>0.Vue 使用声明式渲染的模板，而 React 使用JSX&nbsp;&nbsp;<br>1.React单向数据流，从上往下。Vue双向绑定。Vue更轻量<br>2.React用JSX语法，用javascript+xml。Vue默认是模板和js分离，当然vue也可以用JSX（通过Vue来整合现有的系统是比较容易的，不需要整体重构。）<br><br>相同点：鼓励组件化应用。都应用虚拟DOM。都有自己的构建工具（React【Create React App】 Vue【Vue-cli】）<\/p><p><a href=\"https:\/\/blog.csdn.net\/CystalVon\/article\/details\/78428036\" target=\"_blank\">Vue.js与React的全面对比<\/a><br><\/p><p><br><\/p><h3><span style=\"font-weight: bold;\">vue用jsx的好处<\/span><\/h3><div><span style=\"font-weight: bold;\">\/\/ 标签属性事件复用<\/span><\/div><p>render (createElement) {<br>&nbsp; &nbsp; &nbsp;const inputAttributes = {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; class: 'input-field has-outline', \/\/ class definition<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; onClick: this.handleClick \/\/ event handler<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backdrop: false \/\/ custom prop<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; const inputMarkup = this.multiline ? &lt;textarea {...inputAttributes}&gt;&lt;\/textarea&gt; : &lt;input {...inputAttributes}\/&gt;<br>&nbsp; &nbsp; &nbsp; &nbsp;return inputMarkup<br> }<\/p><p><br><\/p><h3>Angularjs和Vue.js对比<\/h3><p>相同点：<\/p><p>都是双向绑定，都是mvvm框架<\/p><p>不同点：<\/p><p>angular双向绑定用<strong>脏值检查，<\/strong>vue是数据劫持加发布者订阅者模式。<\/p><p>vue是渐进式框架，比angular更轻量<\/p><p><br><span style=\"font-weight: bold;\">##动态对象<\/span><br><span style=\"color: rgb(194, 79, 74);\">#1<\/span><br>let dreamapple = {<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; firstName: 'dream',<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; lastName: 'apple',<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; get fullName() {<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; return this.firstName + ' ' + this.lastName;<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; },<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; set fullName(fullName) {<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; var names = fullName.trim().split(' ');<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; if(2 === names.length) {<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.firstName = names[0];<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.lastName = names[1];<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>}<br><span style=\"color: rgb(194, 79, 74);\">#2<\/span><br>let dreamapple = {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;firstName: 'dream',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lastName: 'apple'<br>}<br>Object.defineProperty(dreamapple,'fullName',{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; writable: true,         \/\/ 可改，默认false<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; enumerable: true,       \/\/ 可枚举（意思是在for in或者Object.keys能被打印出来），默认false   <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; configurable: false,    \/\/ 不能再define，默认false<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; set:function(fullName){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var names = fullName.trim().split(' ');<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(names.length === 2) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dreamapple.firstName = names[0];<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dreamapple.lastName = names[1];<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; get:function() {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return dreamapple.firstName + ' ' + dreamapple.lastName;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },<br>})<\/p><p><a href=\"https:\/\/pic4.zhimg.com\/80\/edd0080fb145315fbc96164c219fee7e_hd.jpg\">https:\/\/pic4.zhimg.com\/80\/edd0080fb145315fbc96164c219fee7e_hd.jpg<\/a>&nbsp;<\/p><p><img src=\"https:\/\/pic4.zhimg.com\/80\/edd0080fb145315fbc96164c219fee7e_hd.jpg\" style=\"max-width: 100%;\">&nbsp;<br><\/p><p><a href=\"https:\/\/i.loli.net\/2019\/07\/15\/5d2c20df68a3346321.jpg\">https:\/\/i.loli.net\/2019\/07\/15\/5d2c20df68a3346321.jpg<\/a>&nbsp;&nbsp;<br><img src=\"https:\/\/i.loli.net\/2019\/07\/15\/5d2c20df68a3346321.jpg\" style=\"max-width:100%;\"><br><\/p><p><span style=\"font-weight: bold;\">##深入defineProperty<\/span><br>#defineProperty默认writable为<span style=\"color: rgb(194, 79, 74);\">false<\/span>【不能改动】 默认enumerable为<span style=\"color: rgb(194, 79, 74);\">false<\/span>【不能枚举】默认configurable为<span style=\"color: rgb(194, 79, 74);\">false<\/span>【不能再改动前面二位和自己的值】<br>let boy = {}<br>Object.defineProperty(boy,'name',{<br>&nbsp; &nbsp; &nbsp; &nbsp;value:'eric'<br>})<br>console.log(boy.name)   \/\/ eric<br>boy.name = 'super man'<br>console.log(boy.name)   \/\/ eric<br>console.log(Object.keys(boy),boy.propertyIsEnumerable('name'))  \/\/ []  false<br><br>let boy = {name:''}<br>Object.defineProperty(boy,'name',{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value:'eric'<br>})<br>console.log(boy.name)   \/\/ eric<br>boy.name = 'super man'<br>console.log(boy.name)   \/\/ super man<br>console.log(Object.keys(boy),boy.propertyIsEnumerable('name'))  \/\/ ['name']  true<br><br>#defineProperty默认configurable为false，不能删除属性，且不能再更改不同原有的特性值<br>let boy = {}<br>Object.defineProperty(boy,'name',{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; value:'eric',<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; configurable:false<br>})<br>delete boy.name<br>console.log(boy.name)   \/\/ eric<br>Object.defineProperty(boy,'name',{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; configurable:true<br>})<br>\/\/报错<br>Object.defineProperty(boy,'name',{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; enumerable:true<br>})<br>\/\/报错<br>Object.defineProperty(boy,'name',{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; writable:true<br>})<br>\/\/报错<br>Object.defineProperty(boy,'name',{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; writable:false<br>})<br>\/\/没报错，因为本来就是false<\/p><p><span style=\"color: rgb(194, 79, 74);\">【注意】<\/span>在&nbsp;<code>descriptor<\/code>&nbsp;中不能<strong>同时<\/strong>设置访问器 (<code>get<\/code>&nbsp;和&nbsp;<code>set<\/code>) 和&nbsp;<code>wriable<\/code>&nbsp;或&nbsp;<code>value<\/code>，否则会报以下错误：<\/p><pre><code>Invalid&nbsp;property.&nbsp;A&nbsp;property&nbsp;cannot both have accessors&nbsp;and&nbsp;be writable&nbsp;or&nbsp;have a value<\/code><\/pre><p><br><br><span style=\"font-weight: bold;\">##Vue的响应式原理【<\/span><a href=\"https:\/\/www.cnblogs.com\/canfoo\/p\/6891868.html\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/www.cnblogs.com\/canfoo\/p\/6891868.html<\/a><span style=\"font-weight: bold;\">】<\/span><\/p><p>主要运用了Object.defineProperty的数据劫持实现双向绑定,在遍历对象属性时添加dep来依赖收集和派发更新操作。当改动数据时执行更新操作，更新视图<br><br>class Vue{<br>    constructor(obj){<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; this.data = obj.data<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; observe(this.data)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; new Watcher(this.data,'name',update)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; }<br>}<br>class Dep{<br>     constructor(){<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; this.subs = []   <br>     }<br>     addSub(sub){<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; this.subs.push(sub)<br>     }<br>     notify(){<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; this.subs.forEach(sub=&gt;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub.update()<\/p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; })<br>     }<br>}<\/p><p><span style=\"color: rgb(194, 79, 74);\">【更多详情：看源码【<a href=\"https:\/\/www.aiheart.top\/eblog\/assets\/html\/mvvm.html\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/www.aiheart.top\/eblog\/assets\/html\/mvvm.html<\/a>】】<\/span><\/p><p><br><\/p><p><span style=\"font-weight: bold;\">##Proxy比起Object.defineProperty的优势<\/span><\/p><p>Object.defineProperty检测不到value为数组时的变化(push,pop,slice,shift,unshift等【不用怕vue这些方法不能用，vue在这方面做了包裹，但直接更改某个值就不行了，例如this.arr[0] = 1不是响应的】)<br>#Object.defineProperty也不能检测到数组作为target时push等方法<\/p><p>【1. Object.defineProperty只能劫持对象的属性，而Proxy是直接代理对象。】<\/p><p>【2. Object.defineProperty没法监听到对象新增属性的操作，而Proxy可以。】&nbsp;&nbsp;<br><\/p><p>【3. Proxy支持13种拦截方法，而\n\nObject.defineProperty&nbsp;只能监听get， 】&nbsp;&nbsp;&nbsp;<\/p><p>【缺点Proxy兼容性不给力，目前还没有完整的polifill方案【in 2019年】】<\/p><p>let arr = [1,2,3]<br>for(let [i,j] of arr.entries()){<br>&nbsp; &nbsp; &nbsp;Object.defineProperty(arr,i,{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;get(){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.log('get')<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return j<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set(e){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.log('set')<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = e<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp;})<br>}<\/p><p>arr.pop()&nbsp; &nbsp;\/\/ 触发get<br>arr.push(4)       \/\/  没反应<\/p><p>arr.pop()&nbsp; \/\/&nbsp;\n\n没反应,谁叫你push进去一个啥啥<\/p><p><span style=\"color: rgb(194, 79, 74);\">但：<\/span><\/p><p>arr.shift()&nbsp; &nbsp; &nbsp;\/\/ 会触发get，set<\/p><p>arr.unshift()&nbsp; \/\/ 会触发get，set<\/p><p><span style=\"color: rgb(194, 79, 74);\">总而言之，监听数组变化不规范<\/span><br><br><span style=\"font-weight: bold;\">#Proxy可以监听数组变化<\/span><br>let arr = [1,2,3]<br>let newArr = new Proxy(arr,{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get(target,key,receiver){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log('get',key)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return Reflect.get(target,key,receiver)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set(target,key,value,receiver){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log('set',key,value)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return Reflect.set(target,key,value,receiver)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>})<br>newArr.push(4)<br><\/p><p><br><\/p><p><br><\/p><p>##Proxy 实例<br><br>#默认值<br>function defaultProp(defaultObj){<br>     const handler = {<br>           get(target,key){<br>               return Reflect.get(target,key)||defaultObj[key]<br>           }<br>     }<br>     return new Proxy({},handler)<br>}<br>const o = defaultProp({name:'default name'})<br>console.log(o.name)      \/\/ 'default name'<br>o.name = 'eric'          <br>console.log(o.name)      \/\/ 'eric'<br>delete o.name<br>console.log(o.name)      \/\/ 'default name'<br><br><br>#隐藏私有属性【比如隐藏以下划线开头的的属性，让他们真正私有化】<br>function privateProp(target,filter){<br>      const handler = {<br>            get(target,key){<br>                 if(!filter(key)){<br>                      const val = Reflect.get(target,key)<br>                      \/\/ this指向target以获取私有属性【默认this指向代理】<br>                      if(typeof val === 'function'){<br>                             return val.bind(target)<br>                      }<br>                      return val<br>                 }<br>            },<br>            set(target,key,value){<br>                 if(filter(key)){<br>                      throw new Error(`cannot set property ${key}`)<br>                 }<br>                 return Reflect.set(target,key,value)<br>            },<br>            has(target,key){<br>                 return filter(key)?false:Reflect.has(target,key)<br>            },<br>            ownKeys(target){<br>                 return Reflect.ownKeys(target).filter(prop=&gt;!filter(prop))<br>            }<br>      }<br>      return new Proxy(target,handler)<br>}<br>function filter(key){<br>    return key.indexOf('_') === 0<br>}<br>const o = {<br>     '_private': 'private prop',<br>     name: 'public name',<br>     say(){<br>          console.log(this._private)<br>     }<br>}<br>const p = privateProp(o,filter)<br><br>#追踪对象和数组<br>【对象】<br>function track(obj, fn) {<br>    const handler = {<br>        set(target, key, value) {<br>            const oldVal = target[key]<br>            const result = Reflect.set(target, key, value)<br>            fn(target, key, oldVal, value)<br>            return result?true:false<br>        },<br>        deleteProperty(target, key) {<br>            const oldVal = target[key]<br>            const result = Reflect.deleteProperty(target, key)<br>            fn(target, key, oldVal, undefined)<br>            return result?true:false<br>        }<br>    }<br>    return new Proxy(obj, handler)<br>}<br>const obj = track({a:1,b:2},(target,key,oldVal,value)=&gt;{<br>      console.log(`obj.${key} changed from ${oldVal} to ${value}`)<br>})<br>obj.a = 3           \/\/  obj.a changed from 1 to 3<br>delete obj.a        \/\/  obj.a changed from 3 to undefined<br><br>【数组】<br>const arr = track([1,2,3,4,5],(target,key,oldVal,value)=&gt;{<br>      let val= isNaN(parseInt(key))?`.${key}`:`[${key}]`<br>      const sum = arr.reduce((a,b)=&gt;a+b)<br><br>      console.log(`arr${val} changed from ${oldVal} to ${value}`)<br>      console.log(`sum [${arr}] is ${sum}`)<br>})<br>arr.push(6)<br>\/\/ arr[5] changed from undefined to 6<br>\/\/ sum [1,2,3,4,5,6] is 21<br>\/\/ arr.length changed from 6 to 6<br>\/\/ sum [1,2,3,4,5,6] is 21<br>arr.pop()<br>\/\/ arr[5] changed from 6 to undefined<br>\/\/ sum [1,2,3,4,5,] is 15<br>\/\/ arr.length changed from 6 to 5<br>\/\/ sum [1,2,3,4,5] is 15<br>arr[4] = 0<br>\/\/ arr[4] changed from 5 to 0<br>\/\/ sum [1,2,3,4,0] is 10<br>arr[5] = 1<br>\/\/ arr[5] changed from undefined to 1<br>\/\/ sum [1,2,3,4,0,1] is 11<br><br>#实现单例模式<br>function Sigleton(fn){<br>  let instance<br>  const handler = {<br>    construct() {<br>      if(!instance){<br>        instance = new fn()<br>      }<br>      return instance<br>    }<br>  }<br><br>  return new Proxy(fn, handler)<br>}<br><br>function Func() {<br>  this.value = 'value'<br>}<br><br>\/\/ 1.普通的实例化<br>const f1 = new Func()<br>const f2 = new Func()<br><br>f1.value = 'new value'<br>f2.value  \/\/ \"value\"  f1 f2 是两个不同的实例<br><br><br>\/\/ 2. 用Proxy实现的单例<br>const p1 = Sigleton(Func)<br>const p2 = Sigleton(Func)<br><br>p1.value = \"proxy value\"<br><br>p2.value \/\/ \"proxy value\"  p1 p2 引用同一个实例对象<br><br><br><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/5\/20 10:14:33",
"updatetime":"2020\/4\/25 17:46:09"
},
{
"id":34,
"title":"react",
"content":"<div><h2><span style=\"font-weight: normal;\"><\/span>\/**路由**\/<\/h2><p>react-router-dom比react-router多出&lt;Link&gt; &lt;BrowserRouter&gt;这样的 DOM 类组件react-router-dom就好<br><br>(react v16之后只需要装一个即可)<br>&lt;Router&gt;<br>&lt;React.Fragment&gt;<br>    &lt;Link to=\"\/\"&gt;app&lt;\/Link&gt;&lt;br\/&gt;<br>    &lt;Link to=\"\/antzone\"&gt;antzone&lt;\/Link&gt;&lt;br\/&gt;<br>    &lt;Link to=\"\/game\"&gt;game&lt;\/Link&gt;<br><br>    &lt;Route exact path=\"\/\" component={App}&gt;&lt;\/Route&gt;<br>    &lt;Route path=\"\/antzone\" component={AntZone}&gt;&lt;\/Route&gt;<br>    &lt;Route path=\"\/game\" component={Game}&gt;&lt;\/Route&gt;<br>&lt;React.Fragment&gt;<br>&lt;\/Router&gt;<br>##Route加上exact就只渲染一次，路由跳转不渲染<br>##在react-router-dom版本为4.x.x+的时候，不能在&lt;Route&gt;里面在嵌套&lt;Route&gt;。否则一片空白<br>##React.Fragment类似于Vue的template<br><br>##纯函数<br>1.函数返回值只取决于参数<br>2.没有副作用，不会修改外部变量<br>例:function sum(a,b){return a+b}<br><br>##声明式编程vs命令式编程<br>const numbers = [1,2,3,4,5];<br><br>\/\/ 声明式<br>const doubleWithDec = numbers.map(number =&gt; number * 2);<br>console.log(doubleWithDec)<br><br>\/\/ 命令式<br>const doubleWithImp = [];<br>for(let i=0; i&lt;numbers.length; i++) {<br>const numberdouble = numbers[i] * 2;<br>doubleWithImp.push(numberdouble)<br>}<br><br>console.log(doubleWithImp)<br><br><br><\/p><h2>\/**redux**\/<\/h2>import {Provider} from 'react-redux'<br>import {createStore} from 'redux'<br>import reducers from '..\/reducers\/counter'<\/div><div><br>const action = {<br>    increase:()=&gt;({type:'INCREASE',num:1}),<br>    decrease:()=&gt;({type:'DECREASE',num:1})<br>}<br>const reducers = (state={count:0},action)=&gt;{<br>    switch(action.type){<br>         case 'INCREASE': return {count:state.count+action.num}<br>         case 'DECREASE': return {count:state.count-action.num}<br>         default: return state<br>    }<br>}<br>const store = createStore(reducers)<br><br>ReactDOM.render((<br>    &lt;Provider store={store}&gt;<br>        &lt;Routers\/&gt;<br>    &lt;\/Provider&gt;<br>), document.getElementById('root'))<\/div><div><br>#Redux提供的createStore(reducers,initialState)返回的是一个store（store.dispatch<br><br>(action),store.getState()）<br>#Dispatch是更新状态树的方法，dispatch会接受一个action,来决定根据reducer去转换状态树<br>#Reducer是根据action来决定数据应该变化成什么样子的函数<br>#Action是改变状态树的动作。action返回的是一个带有type属性的对象，对应flux的payload<br><br>#Redux只能有一个store，而flux可以拥有多个store<br>#Reducer数据的改变通过纯函数reducer完成<br>reduce函数：<br>let a = [1,2,3,4].reduce(function(sum,item){<br>     return sum + item<br>},0)<br><p><\/p><h1><br><\/h1><h2>\/**生命周期**\/<\/h2><div><span style=\"color: rgb(194, 79, 74);\">正常流程: constructor --&gt; componentWillMount&nbsp; --&gt; render --&gt; componentDidMount<\/span><\/div><div><span style=\"color: rgb(194, 79, 74);\"><br><\/span><\/div><div><span style=\"color: rgb(194, 79, 74);\">内部更改state后: shouldComponentUpdate(判断<\/span>nextState<span style=\"color: rgb(194, 79, 74);\">是否render) --&gt; componentWillUpdate --&gt; render --&gt; componentDidUpdate<\/span><\/div><div><span style=\"color: rgb(194, 79, 74);\"><br><\/span><\/div><div><span style=\"color: rgb(194, 79, 74);\">外部更改prop后:&nbsp;componentWillReceiveProps --&gt;&nbsp;shouldComponentUpdate(判断<\/span>nextProps<span style=\"color: rgb(194, 79, 74);\">是否render) --&gt; componentWillUpdate --&gt; render --&gt; componentDidUpdate<\/span><\/div><div><span style=\"color: rgb(194, 79, 74);\"><br><\/span><\/div><h1>1.constructor(props, context)<\/h1>\n<ul>\n<li>构造函数，在创建组件的时候调用一次。<\/li>\n<\/ul>\n<h1>2.componentWillMount()<\/h1>\n<ul>\n<li>在组件render之前立即调用<\/li>\n<\/ul>\n<p><code>Tip1<\/code>: 不建议在此请求数据，由于请求数据接口一般都是异步，这时候render已经被执行，建议在componentDidMount 数据<\/p>\n<p><code>Tip2<\/code>: 如果在服务端渲染，该钩子函数将被调用两次，一次服务端，一次浏览器端，而componentDidMount函数只会在浏览器端请求一次<\/p>\n<p><code>Tip3<\/code>: 在taro构建的小程序里对应的生命周期是 onLoad。<\/p>\n<h1>3..componentDidMount()<\/h1>\n<ul>\n<li>所有的组件（包括子组件）在render执行完之后立即调用，并且只会被调用一次。<\/li>\n<\/ul>\n<p><code>Tip<\/code>: 建议在此请求数据<\/p>\n<h1>4. componentWillReceiveProps(nextProps)<\/h1>\n<ul>\n<li>在props被改变时被触发，初始化render时不调用。<\/li>\n<li>旧的属性还是可以通过this.props来获取，在这里通过调用this.setState()来更新你的组件状态。<\/li>\n<\/ul>\n<p><code>Tip1<\/code>: 某些情况下，props没变也会触发该钩子函数，需要在方法里手动判断一下this.props和nextProps是否相同，不相同了才执行我的更新方法。<\/p>\n<p><code>Tip2<\/code>：该函数一般用来更新依赖props的状态<\/p>\n<h1>5. shouldComponentUpdate(nextProps, nextState)<\/h1>\n<ul>\n<li>发生重渲染时，在render()函数调用前被调用的函数，当函数返回false时候，阻止接下来的render()函数的调用，阻止组件重渲染，而返回true时，组件照常重渲染。<\/li>\n<li>该方法并不会在初始化渲染或当使用forceUpdate()时被调用。<\/li>\n<\/ul>\n<h1>6.componentWillUpdate(nextProps, nextState)<\/h1>\n<ul>\n<li>shouldComponentUpdate返回true或者调用forceUpdate之后，componentWillUpdate会被调用。<\/li>\n<\/ul>\n<h1>7. getSnapshotBeforeUpdate(prevProps, prevState)<\/h1>\n<ul>\n<li>该函数在最新的渲染输出提交给DOM前将会立即调用。它让你的组件能在当前的值可能要改变前获得它们。这一生命周期返回的任何值将会 作为参数被传递给componentDidUpdate()。<\/li>\n<\/ul>\n<h1>8. componentDidUpdate(prevProps, prevState)<\/h1>\n<ul>\n<li>除了首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。<\/li>\n<\/ul>\n<h1>9.componentWillUnmount()<\/h1>\n<ul>\n<li>在组件被卸载和销毁之前立刻调用。可以在该方法里处理任何必要的清理工作，例如解绑定时器，取消网络请求，清理任何在componentDidMount环节创建的DOM元素。<\/li>\n<\/ul>\n<h1>10.componentDidCatch(error, info)<\/h1>\n<ul>\n<li>该函数称为错误边界，捕捉发生在子组件树中任意地方的JavaScript错误，打印错误日志，并且显示回退的用户界面。<\/li>\n<\/ul>\n<p><code>Tip<\/code>：错误边界只捕捉树中发生在它们之下组件里的错误。一个错误边界并不能捕捉它自己内部的错误。<\/p>\n<h1>11.render()<\/h1>\n<ul>\n<li>render是一个React组件所必不可少的核心函数（上面的其它函数都不是必须的）。<\/li>\n<\/ul>\n<p><code>Tip<\/code>：记住，不要在render里面修改state。<\/p><\/div><div><h2 id=\"目前最流行的数据流方案\">目前最流行的数据流方案<\/h2><p>截止 2017.1，最流行的社区 React 应用架构方案如下。<\/p><ul><li>路由：&nbsp;<a href=\"https:\/\/github.com\/ReactTraining\/react-router\/tree\/v2.8.1\" target=\"_blank\" rel=\"noopener noreferrer\">React-Router<svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" aria-hidden=\"true\" x=\"0px\" y=\"0px\" viewBox=\"0 0 100 100\" width=\"15\" height=\"15\"><path fill=\"currentColor\" d=\"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z\"><\/path><polygon fill=\"currentColor\" points=\"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9\"><\/polygon><\/svg><\/a><\/li><li>架构：&nbsp;<a href=\"https:\/\/github.com\/reactjs\/redux\" target=\"_blank\" rel=\"noopener noreferrer\">Redux<svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" aria-hidden=\"true\" x=\"0px\" y=\"0px\" viewBox=\"0 0 100 100\" width=\"15\" height=\"15\"><path fill=\"currentColor\" d=\"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z\"><\/path><polygon fill=\"currentColor\" points=\"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9\"><\/polygon><\/svg><\/a><\/li><li>异步操作：&nbsp;<a href=\"https:\/\/github.com\/yelouafi\/redux-saga\" target=\"_blank\" rel=\"noopener noreferrer\">Redux-saga<svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" aria-hidden=\"true\" x=\"0px\" y=\"0px\" viewBox=\"0 0 100 100\" width=\"15\" height=\"15\"><path fill=\"currentColor\" d=\"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z\"><\/path><polygon fill=\"currentColor\" points=\"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9\"><\/polygon><\/svg><\/a><\/li><\/ul><p>缺点：要引入多个库，项目结构复杂。<\/p><h2 id=\"dva-是什么\"><a href=\"https:\/\/dvajs.com\/guide\/introduce-class.html#dva-%E6%98%AF%E4%BB%80%E4%B9%88\" aria-hidden=\"true\">#<\/a>dva 是什么<\/h2><p>dva 是体验技术部开发的 React 应用框架，将上面三个 React 工具库包装在一起，简化了 API，让开发 React 应用更加方便和快捷。<\/p><p>dva = React-Router + Redux + Redux-saga<\/p><h2 id=\"dva-应用的最简结构\"><a href=\"https:\/\/dvajs.com\/guide\/introduce-class.html#dva-%E5%BA%94%E7%94%A8%E7%9A%84%E6%9C%80%E7%AE%80%E7%BB%93%E6%9E%84\" aria-hidden=\"true\">#<\/a>dva 应用的最简结构<\/h2><\/div><h2 id=\"核心概念\">核心概念<\/h2><ul><li>State：一个对象，保存整个应用状态<\/li><li>View：React 组件构成的视图层<\/li><li>Action：一个对象，描述事件<\/li><li>connect 方法：一个函数，绑定 State 到 View<\/li><li>dispatch 方法：一个函数，发送 Action 到 State<\/li><\/ul><h2 id=\"state-和-view\"><a href=\"https:\/\/dvajs.com\/guide\/introduce-class.html#state-%E5%92%8C-view\" aria-hidden=\"true\">#<\/a>State 和 View<\/h2><p>State 是储存数据的地方，收到 Action 以后，会更新数据。<\/p><p>View 就是 React 组件构成的 UI 层，从 State 取数据后，渲染成 HTML 代码。只要 State 有变化，View 就会自动更新。<\/p><a href=\"https:\/\/dvajs.com\/guide\/introduce-class.html#react-%E6%B2%A1%E6%9C%89%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98\">https:\/\/dvajs.com\/guide\/introduce-class.html#react-%E6%B2%A1%E6%9C%89%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98<\/a>&nbsp;&nbsp;<br>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/5\/27 15:29:34",
"updatetime":"2020\/3\/4 14:39:56"
},
{
"id":35,
"title":"js题",
"content":"<h3><span style=\"font-weight: bold;\">1.<\/span>What's the output?<\/h3><pre>const shape = {\n  radius: 10,\n  diameter() {\n    return this.radius * 2;\n  },\n  perimeter: () =&gt; 2 * Math.PI * this.radius\n};\n\nshape.diameter();\nshape.perimeter();<\/pre><p><span style=\"font-weight: bold;\">ANSWER:&nbsp; 20 and NaN<\/span><\/p><p><span style=\"font-weight: bold;\"><br><\/span><\/p><p><\/p><h3>2.What's the output?<\/h3>let a = 3;<br>let b = new Number(3);<br>console.log(a==3);<br>console.log(a===3);<br><br><span style=\"font-weight: bold;\">ANSWER: true false<\/span><div>typeof a; \/\/ 'number'<\/div><div>typeof b; \/\/ 'object'<br><br><h3>3.What's the output?<\/h3>let greeting;<br>console.log(greeting);<br><br><span style=\"font-weight: bold;\">ANSWER: undefined<\/span><br><br><br><h3>4.What's the output?<\/h3>function getPersonInfo(one, two, three) {<br>  console.log(one);<br>  console.log(two);<br>  console.log(three);<br>}<br>const person = \"Lydia\";<br>const age = 21;<p><\/p><p><br>getPersonInfo`${person} is ${age} years old`;<br><span style=\"font-weight: bold;\">ANSWER: [\"\", \" is \", \" years old\"] \"Lydia\" 21<\/span><br><br><br><\/p><h3>5.What's the output?<\/h3>function checkAge(data) {<br>  if (data === { age: 18 }) {<br>    console.log(\"You are an adult!\");<br>  } else if (data == { age: 18 }) {<br>    console.log(\"You are still an adult.\");<br>  } else {<br>    console.log(`Hmm.. You don't have an age I guess`);<br>  }<br>}<br><br>checkAge({ age: 18 });<br><br><span style=\"font-weight: bold;\">ANSWER: Hmm.. You don't have an age I guess<\/span><br><br><br><h3>6.What's the output?<\/h3>const sum = eval(\"10*10+5\");<p><\/p><p><span style=\"font-weight: bold;\">ANSWER: 105<\/span><br><br><br><\/p><h3>7.What's the output?<\/h3>const obj = { 1: \"a\", 2: \"b\", 3: \"c\" };<br>const set = new Set([1, 2, 3, 4, 5]);<br><br>obj.hasOwnProperty(\"1\");<br>obj.hasOwnProperty(1);<br>set.has(\"1\");<br>set.has(1);<br><br><span style=\"font-weight: bold;\">ANSWER: true true false true<\/span><\/div><div>所有对象键（不包括<code>Symbols<\/code>）都会被存储为字符串，即使你没有给定字符串类型的键。 这就是为什么<code>obj.hasOwnProperty（'1'）<\/code>也返回<code>true<\/code>。&nbsp;&nbsp;<span style=\"font-weight: 700;\"><br><\/span><br><br><h3>8.What's the output?<\/h3>const a = {};<br>const b = { key: \"b\" };<br>const c = { key: \"c\" };<br><br>a[b] = 123;<br>a[c] = 456;<br><br>console.log(a[b]);<br><br><span style=\"font-weight: bold;\">ANSWER: 456     (Object keys are automatically converted into strings.)<\/span><\/div><div>a[\"Object object\"] = 123&nbsp;<\/div><div>a[\"Object object\"] = 456<br><br><br><h3>9.What's the output?<\/h3>const person = { name: \"Lydia\" };<br><br>function sayHi(age) {<br>  console.log(`${this.name} is ${age}`);<br>}<br><br>sayHi.call(person, 21);<br>sayHi.bind(person, 21);<br><br><span style=\"font-weight: bold;\">ANSWER: Lydia is 21 function      (.bind. returns a copy of the function, but with a bound context! It is not executed <br><br>immediately.)<\/span><br><br><br><h3>10.Which of these values are falsy?<\/h3>0;<br>new Number(0);<br>(\"\");<br>(\" \");<br>new Boolean(false);<br>undefined;<br><br><span style=\"font-weight: bold;\">ANSWER: 0, '', undefined        (There are only six falsy values:undefined,null,NaN,0,'',false)<\/span><br><br><br><h3>11.Everything in JavaScript is either a primitive or object.Primitive types are boolean, null, undefined, bigint, number,string, and symbol.<\/h3><h3><br><h2><span style=\"font-weight: bold;\">##js实现一个eventEmitter类，实现on(), off(), once(), emit()方法&nbsp;&nbsp;<\/span><\/h2><\/h3><p><\/p><\/div>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/6\/17 13:58:48",
"updatetime":"2020\/3\/9 18:11:35"
},
{
"id":36,
"title":"实用设计+前端工具",
"content":"<p><a href=\"http:\/\/upload.otar.im\/\" title=\"在线图床上传工具\" target=\"_blank\" rel=\"friend\"><\/a><\/p><div><span style=\"font-weight: bold;\">在线抠图<\/span>：<a href=\"https:\/\/www.gaoding.com\/koutu\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/www.gaoding.com\/koutu<\/a>&nbsp;&nbsp;<br><\/div><p><span style=\"font-weight: bold;\">在线PS：<\/span><a href=\"https:\/\/ps.gaoding.com\/?hmsr=ivan-intro-juejin#\/\">https:\/\/ps.gaoding.com\/?hmsr=ivan-intro-juejin#\/<\/a>&nbsp;&nbsp;<br><\/p><div><span style=\"font-weight: bold;\">在线图上传工具<\/span>：<a href=\"http:\/\/upload.otar.im\/\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">http:\/\/upload.otar.im\/<\/a>&nbsp; &nbsp;&nbsp;<\/div><p>测试已上传的图：<img src=\"https:\/\/i.loli.net\/2019\/06\/27\/5d142b103353164287.jpg\" style=\"max-width: 100%;\"><\/p><p>雪碧图：<a href=\"https:\/\/www.toptal.com\/developers\/css\/sprite-generator\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/www.toptal.com\/developers\/css\/sprite-generator<\/a>&nbsp;<\/p><p>变量命名工具：&nbsp;<a href=\"https:\/\/unbug.github.io\/codelf\/\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/unbug.github.io\/codelf\/<\/a><\/p><p>检查ip：<a href=\"http:\/\/httpbin.org\/get\">http:\/\/httpbin.org\/get<\/a>&nbsp;&nbsp;<br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/6\/21 14:07:32",
"updatetime":"2019\/8\/13 17:50:21"
},
{
"id":37,
"title":"帅气的CSS&CSS题",
"content":"<p>加载条&nbsp; &nbsp;<a href=\"https:\/\/codepen.io\/TheDutchCoder\/pen\/IKqpA\/\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/codepen.io\/TheDutchCoder\/pen\/IKqpA\/<\/a>&nbsp;&nbsp;<br><\/p><p>作者在这，嗯~~ css真香&nbsp;<a href=\"https:\/\/codepen.io\/TheDutchCoder\/\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/codepen.io\/TheDutchCoder\/<\/a><\/p><h5><span style=\"font-weight: normal;\">基于 Vue 2.0 优雅的 Material Design UI 组件库<\/span><a href=\"https:\/\/muse-ui.org\/#\/zh-CN\" target=\"_blank\" style=\"font-size: 12px; background-color: rgb(255, 255, 255);\">https:\/\/muse-ui.org\/#\/zh-CN<\/a><\/h5><p><br><\/p><p><a href=\"https:\/\/www.itcodemonkey.com\/article\/2853.html\" target=\"_blank\">50道 CSS 基础面试题（附答案）<\/a><br><\/p><p><br><\/p><p>flex详解：<a href=\"https:\/\/www.jianshu.com\/p\/cb6b062a291a\">https:\/\/www.jianshu.com\/p\/cb6b062a291a<\/a>&nbsp;&nbsp;<\/p><p><br><\/p><h3><span style=\"font-weight: bold;\">css优先级顺序<\/span><\/h3><div><span style=\"font-weight: bold;\">!important &gt; 内联样式 &gt; id选择器 &gt;&nbsp;<\/span><strong>类选择器 &gt; 标签 &gt; 通配符*<\/strong><\/div><div><h3>css硬件加速<\/h3><\/div><p>少数属性可以触发GPU的硬件加速&nbsp;<\/p><ul><li><code>transform<\/code><\/li><li><code>opacity<\/code><\/li><li><code>filter<\/code><\/li><\/ul><div><span style=\"font-weight: 700;\">像很多轮播组件用的是<\/span><span style=\"color: rgb(194, 79, 74);\">transform<\/span>: translate3d(-1903px, 0px, 0px);滚动 会更加流畅<\/div><p><code>transform<\/code>&nbsp;属性不会触发浏览器的 repaint，而&nbsp;<code>left<\/code>&nbsp;和&nbsp;<code>top<\/code>&nbsp;则会一直触发 repaint<\/p><p>所以写@keyframe时尽量用transform:&nbsp;translate(200px,&nbsp;0);代替left:0 top:0<\/p><div><strong><br><\/strong><\/div><h2>css题<\/h2><div><h3>\/* 红色区域的大小是多少？ *\/（秒答代表合格）<\/h3><div>.box {&nbsp;<\/div><div>&nbsp;    width: 200px;&nbsp;<\/div><div>&nbsp;    height: 200px;&nbsp;<\/div><div>&nbsp;    padding: 20px;&nbsp;<\/div><div>&nbsp;    margin: 20px;&nbsp;<\/div><div>&nbsp;    background: red;&nbsp;<\/div><div>&nbsp;    border: 20px solid black;&nbsp;<\/div><div>&nbsp;    box-sizing: border-box;<\/div><div>&nbsp;}<\/div><\/div><h3>水平垂直居中<\/h3><p>1.固定宽高<\/p><p>.son{<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp;position:absolute;&nbsp; left:50%; margin-left:-0.5*width;&nbsp; top:50%;&nbsp; margin-top:-0.5*height;<\/p><p>}<\/p><p>2.不固定宽高<\/p><p>.son{<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp;position:absolute;&nbsp; left:50%; top:50%; transform:&nbsp;translate(-50%,-50%);<\/p>    <p>}<\/p><p>（此处我一般用flex（高版本）和兼容IE7（低版本）两种方式）<\/p><p><span style=\"font-weight: bold;\">#HTML:<\/span><\/p><div><span>&lt;<\/span><span>div<\/span><span> <\/span><span>class<\/span><span>=<\/span><span>\"parent\"<\/span><span>&gt;<\/span><\/div><div><span>        <\/span><span>&lt;<\/span><span>img<\/span><span> <\/span><span>class<\/span><span>=<\/span><span>\"son\"<\/span><span> <\/span><span>src<\/span><span>=<\/span><span>\"https:\/\/img3.doubanio.com\/view\/photo\/s_ratio_poster\/public\/p2555084871.jpg\"<\/span><span>&gt;&lt;\/<\/span><span>img<\/span><span>&gt;<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>    <\/span><span>&lt;\/<\/span><span>div<\/span><span>&gt;<\/span><\/div><p><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">#CSS(flex):<\/span><\/p><div><span>.parent{<\/span><\/div><div><span>            <\/span><span>width<\/span><span>:<\/span><span>300<\/span><span>px<\/span><span>;<\/span><\/div><div><span>            <\/span><span>height<\/span><span>:<\/span><span>300<\/span><span>px<\/span><span>;<\/span><\/div><div><span>            <\/span><span>margin<\/span><span>:<\/span><span>0<\/span><span> auto;<\/span><\/div><div><span>            <\/span><span>background-color<\/span><span>:green;<\/span><\/div><div><span>            <\/span><span>display<\/span><span>: flex;<\/span><\/div><div><span>            <\/span><span>justify-content<\/span><span>: center;<\/span><\/div><div><span>            <\/span><span>align-items<\/span><span>: center;<\/span><\/div><div><span>        }<\/span><\/div><div><span>        .son{<\/span><\/div><div><span>            <\/span><span>width<\/span><span>: <\/span><span>100<\/span><span>px<\/span><span>;<\/span><\/div><div><span>            <\/span><span>height<\/span><span>:<\/span><span>100<\/span><span>px<\/span><span>;<\/span><\/div><div><span>            <\/span><span>background<\/span><span>:red;<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>}<\/span><\/div><p><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">#CSS(兼容IE7): 传统的基于【盒状模型】的水平垂直居中的解决方案<\/span><\/p><div><span>.parent{<\/span><\/div><div><span>            <\/span><span>width<\/span><span>:<\/span><span>300<\/span><span>px<\/span><span>;<\/span><\/div><div><span style=\"color: rgb(194, 79, 74); font-weight: bold;\"><span>            <\/span><span>height<\/span><span>:<\/span><span>300<\/span><span>px<\/span><span>;<\/span><\/span><\/div><div><span>            <\/span><span>margin<\/span><span>:<\/span><span>0<\/span><span> auto;<\/span><\/div><div><span>            <\/span><span>background-color<\/span><span>:green;<\/span><\/div><div><span style=\"font-weight: bold; color: rgb(194, 79, 74);\"><span>            <\/span><span>line-height<\/span><span>:<\/span><span>300<\/span><span>px<\/span><span>;<\/span><\/span><\/div><div><span style=\"color: rgb(194, 79, 74); font-weight: bold;\"><span>            <\/span><span>text-align<\/span><span>: center;<\/span><\/span><\/div><div><span>        }<\/span><\/div><div><span>        .son{<\/span><\/div><div><span style=\"font-weight: bold; color: rgb(194, 79, 74);\"><span>            <\/span><span>display<\/span><span>: inline-block;<\/span><\/span><\/div><div><span style=\"font-weight: bold; color: rgb(194, 79, 74);\"><span>            <\/span><span>vertical-align<\/span><span>: middle;<\/span><\/span><\/div><div><span>            <\/span><span>width<\/span><span>: <\/span><span>100<\/span><span>px<\/span><span>;<\/span><\/div><div><span>            <\/span><span>height<\/span><span>:<\/span><span>100<\/span><span>px<\/span><span>;<\/span><\/div><div><span>            <\/span><span>background<\/span><span>:red;<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>}<\/span><\/div><p><br><\/p><p>#帅气的css（部分高亮）<\/p><p>first,你先去<a href=\"https:\/\/www.iconfont.cn\/\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/www.iconfont.cn\/<\/a>&nbsp;\"shopping and add to cart~ and then download the code\"<\/p><p>选用class名引入哟，看下图就知道怎么玩了~~<\/p><p><a href=\"https:\/\/www.aiheart.top\/photo\/1565945837.png\">https:\/\/www.aiheart.top\/photo\/1565945837.png<\/a>&nbsp;&nbsp;<br><\/p><p><img src=\"https:\/\/www.aiheart.top\/photo\/1565945837.png\" style=\"max-width:100%;\"><br><\/p><p><br><\/p><p><br><\/p><p><br><\/p><p><br><\/p><h2><span style=\"font-weight: bold;\">##实用css技巧<\/span><\/h2><div>#<a href=\"https:\/\/codepen.io\/JowayYoung\/pen\/ZgxZJa\" target=\"_blank\">【iCSS：布局】使用text-align-last对齐两端文本<\/a><span style=\"font-weight: bold;\"><br><\/span><\/div><p># 使用vw定制rem自适应布局 \/* 基于UI width=750px DPR=2的页面 *\/&nbsp;html&nbsp;{&nbsp;font-size:&nbsp;calc(100vw \/ 7.5); }&nbsp;<\/p><p>&nbsp;<\/p><h2>##CSS3 box-sizing的作用<\/h2><p>设置CSS盒模型为标准模型或IE模型。标准模型的宽度只包括content，二IE模型包括border和padding<\/p><p>box-sizing属性可以为三个值之一：<\/p><ol><li>content-box，默认值，border和padding不计算入width之内<\/li><li>padding-box，padding计算入width内<\/li><li>border-box，border和padding计算入width之内<\/li><\/ol><p><br><\/p><h2>##nth-child(2)和nth-of-type(2)的区别<\/h2><p>.box div:nth-child(2){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp;color:red;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; 第一个item 111 变红<\/p><p>}<\/p><p>.box div:nth-of-type(2){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp;color:red;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; 第二个item 111 变红<\/p><p>}<\/p><div><span>&lt;<\/span><span>div<\/span><span> <\/span><span>class<\/span><span>=<\/span><span>\"box\"<\/span><span>&gt;<\/span><\/div><div><span>        <\/span><span>&lt;<\/span><span>p<\/span><span>&gt;<\/span><span>666<\/span><span>&lt;\/<\/span><span>p<\/span><span>&gt;<\/span><\/div><div><span>        <\/span><span>&lt;<\/span><span>div<\/span><span> <\/span><span>class<\/span><span>=<\/span><span>\"item\"<\/span><span>&gt;111&lt;\/<\/span><span>div<\/span><span>&gt;<\/span><\/div><div><span>        <\/span><span>&lt;<\/span><span>div<\/span><span> <\/span><span>class<\/span><span>=<\/span><span>\"item\"<\/span><span>&gt;222&lt;\/<\/span><span>div<\/span><span>&gt;<\/span><\/div><div><span>        <\/span><span>&lt;<\/span><span>div<\/span><span> <\/span><span>class<\/span><span>=<\/span><span>\"item\"<\/span><span>&gt;333&lt;\/<\/span><span>div<\/span><span>&gt;<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>    <\/span><span>&lt;\/<\/span><span>div<\/span><span>&gt;<\/span><\/div><div><span><br><\/span><\/div><p><br><\/p><h2><span style=\"font-weight: bold;\">##flex布局<\/span><\/h2><div>flex容器默认存在两根轴：水平的<span style=\"font-weight: bold; color: rgb(194, 79, 74);\">主轴<\/span>（main axis）和垂直的<span style=\"font-weight: bold; color: rgb(194, 79, 74);\">交叉轴<\/span>（cross axis）&nbsp;&nbsp;<span style=\"font-weight: bold;\"><br><\/span><\/div><p><a href=\"http:\/\/www.ruanyifeng.com\/blog\/2015\/07\/flex-grammar.html\">http:\/\/www.ruanyifeng.com\/blog\/2015\/07\/flex-grammar.html<\/a>&nbsp;<\/p><p><code style=\"font-size: 12px;\">flex-direction<\/code>属性决定主轴的方向（即项目的排列方向）。<\/p><ul><li><code>row<\/code>（默认值）：主轴为水平方向，起点在左端。<\/li><li><code>row-reverse<\/code>：主轴为水平方向，起点在右端。<\/li><li><code>column<\/code>：主轴为垂直方向，起点在上沿。<\/li><li><code>column-reverse<\/code>：主轴为垂直方向，起点在下沿。<\/li><\/ul><p><code>flex<\/code>属性是<code>flex-grow<\/code>,&nbsp;<code>flex-shrink<\/code>&nbsp;和&nbsp;<code>flex-basis<\/code>的简写，默认值为<code>0 1 auto<\/code>。后两个属性可选。<\/p><p>flex-grow定义了元素的放大比例【当空间充足时，按照这个比例放大】， flex-shrink定义了元素的缩放比例【当空间不足时，按照这个比例缩小】<\/p><p><code>flex-basis<\/code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto<\/code>，即项目的本来大小。&nbsp;&nbsp;<br><\/p><p><a href=\"https:\/\/www.jianshu.com\/p\/bd7d1597d12d\">https:\/\/www.jianshu.com\/p\/bd7d1597d12d<\/a>&nbsp;&nbsp;<\/p><p>.box{<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp;flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;<\/p><p>}<\/p><p>&nbsp;.item&nbsp;{<br><\/p><pre><code>  flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]\n}<\/code><\/pre><p>flex-basis和width同时存在，width无效<\/p><p>flex-basis和max-width同时存在，max-width有效<br><\/p><p>flex-basis和min-width同时存在，\n\nmin-width有效&nbsp;&nbsp;<br><\/p><p>除了常用的justify-content【主轴对齐方式】，align-items【交叉轴对齐方式】<\/p><p><code>align-content<\/code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。&nbsp;&nbsp;<br><\/p><p>align-self【子元素属性】覆盖align-items【父元素】<\/p><pre><code>.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n<\/code><\/pre><p><code>order<\/code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。&nbsp;&nbsp;<br><\/p><pre><code>.item {\n  order: &lt;integer&gt;;\n}<\/code><\/pre><p>综合上面；<\/p><p>父元素属性有：<\/p><p>.box{<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;display:flex;<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;flex-direction: row;<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;flex-wrap: nowrap;<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;flex-flow: &lt;direction&gt; || &lt;wap&gt;<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;justify-content:center;<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;align-items: center;<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;align-content: flex-start | flex-end | center | space-between | space-around | stretch;<\/p><p>}<br><\/p><p>.item{<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; flex-grow: 1;<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; flex-shrink: 0;<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; flex-basis: &lt;length&gt; | auto; \/* default auto *\/<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ];<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; order: 0;&nbsp; \/* default 0 *\/<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; align-self: auto | flex-start | flex-end | center | baseline | stretch;&nbsp; &nbsp; &nbsp; &nbsp;\/\/ 覆盖align-items&nbsp;&nbsp;<br><\/p><p>}<\/p><p><br><\/p><p><br><\/p><p><br><\/p><p><span style=\"font-weight: bold;\"><br>#移动端适配的方案有：<\/span><\/p><p>1.古老的px+媒体查询<\/p><p>2.px转rem（postcss-px2rem lib-flexible）【1rem等于根元素的字体大小】<\/p><p>3.px转vw( 各种postCss&nbsp;插件 )&nbsp; &nbsp; 【1vw等于视口宽度的1%】<\/p><p>rem<\/p><p>var width = docEl.clientWidth;&nbsp;<\/p><p>if(width \/ dpr &lt; 750) {\n            width = 750 * dpr;\n        }&nbsp;<\/p><p>\/\/ 乘以100，px : rem = 100 : 1<\/p><p>\n        docEl.style.fontSize = <span style=\"color: rgb(194, 79, 74);\">100<\/span> * (width \/ 750) + 'px';&nbsp;&nbsp;<br><\/p><p>.box{<\/p><p>&nbsp; &nbsp; &nbsp; width: 750px;<\/p><p>}<\/p><p>.box{<\/p><p>&nbsp; &nbsp; &nbsp; width: 7.5rem;<\/p><p>}<\/p><h4>css中的1px并不等于设备的1px<\/h4><div><div>从iphone4开始，苹果公司便推出了所谓的Retina屏，分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个css像素是等于两个物理像素的。其他品牌的移动设备也是这个道理。<\/div><div><div>在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例<span style=\"color: rgb(194, 79, 74);\">【设备像素比】<\/span>，也就是 <span style=\"font-weight: bold; color: rgb(194, 79, 74);\">devicePixelRatio = 物理像素 \/ 独立像素<\/span>。css中的px就可以看做是设备的独立像素，所以通过devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。<\/div><div><p>DPR：以iphone6为例，DPR为2。也即是说，他实际是在用4个像素（2x2）在显示你在css中写的1px像素点；<\/p><p>也就是说，iphone6虽然是375px宽，但是他实际x轴的像素点是750（375px * 2DPR）；<\/p><\/div>例如，在Retina屏的iphone上，devicePixelRatio的值为2，也就是说1个css像素相当于2个物理像素。&nbsp;&nbsp;<br><\/div><\/div><p><span style=\"color: rgb(194, 79, 74);\">dpr = parseInt(1\/scale)<\/span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ 此处scale为&lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"&gt;的initial-scale<\/p><h4>rem的问题<\/h4><ul><li>在奇葩的dpr设备上表现效果不太好，比如 一些华为的高端机型 用rem布局会出现错乱。<\/li><li>使用iframe引用也会出现问题；【会受到父元素dpr的影响】<\/li><\/ul><h4>vw的问题<\/h4><ul><li>支持程度不太好，安卓4.4以下都不支持<\/li><\/ul><h2>移动端1px解决方案<\/h2><p><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">1<\/span>. 借助<code>PostCSS<\/code>的<code style=\"color: rgb(194, 79, 74);\">postcss-write-svg<\/code>我们能直接使用<code>border-image<\/code>和<code>background-image<\/code>创建<code>svg<\/code>的<code>1px<\/code>边框：&nbsp;<\/p><div><div>@svg border_1px {&nbsp;<\/div><div>&nbsp;\n  height: 2px;&nbsp;<\/div><div>&nbsp;@rect { \n    fill: var(--color, black); \n    width: 100%; \n    height: 50%; \n    }&nbsp;<\/div><div>}&nbsp;<\/div><div>.example { border: 1px solid transparent; border-image: svg(border_1px param(--color #00b1ff)) 2 2 stretch; }<\/div><div>编译后：<\/div><div><div>.example { border: 1px solid transparent; border-image: url(\"data:image\/svg+xml;charset=utf-8,%3Csvg xmlns='http:\/\/www.w3.org\/2000\/svg' height='2px'%3E%3Crect fill='%2300b1ff' width='100%25' height='50%25'\/%3E%3C\/svg%3E\") 2 2 stretch; }<\/div><div>要先配置哦~<\/div><div><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><div>\"postcss\": {<\/div><div>    \"plugins\": {<\/div><div>      \"autoprefixer\": {},<\/div><div>      \"postcss-write-svg\": {<\/div><div>        \"utf8\": false<\/div><div>      },<\/div><div>      \"postcss-px-to-viewport\": {<\/div><div>        \"viewportWidth\": 750,&nbsp; &nbsp; \/\/ 视口宽度<\/div><div>        \"minPixelValue\": 1&nbsp; &nbsp; &nbsp;\/\/ 超过这个数才被转为vw<\/div><div>      }<\/div><div>    }<\/div><div>  },<\/div><\/divcourier><\/div><span style=\"color: rgb(194, 79, 74);\">2<\/span>. js通过获取dpr动态改变scale<a href=\"https:\/\/blog.csdn.net\/qq20004604\/article\/details\/78522802\">https:\/\/blog.csdn.net\/qq20004604\/article\/details\/78522802<\/a>&nbsp;&nbsp;<br><\/div>3.div {&nbsp;<\/div><div>&nbsp;height:1px;&nbsp;<\/div><div>&nbsp;background:#000;&nbsp;<\/div><div>&nbsp;-webkit-transform: scaleY(0.5);&nbsp;<\/div><div>&nbsp;-webkit-transform-origin:0 0;\n    overflow: hidden;&nbsp;<\/div><div>}<\/div><div><div>\/* 2倍屏 *\/&nbsp;<\/div><div>@media only screen and (-webkit-min-device-pixel-ratio: 2.0) {&nbsp;<\/div><div>&nbsp;.border-bottom::after {\n        -webkit-transform: scaleY(0.5);&nbsp;<\/div><div>&nbsp;transform: scaleY(0.5);\n    }&nbsp;<\/div><div>}&nbsp;<\/div><div>&nbsp;\/* 3倍屏 *\/&nbsp;<\/div><div>@media only screen and (-webkit-min-device-pixel-ratio: 3.0) {&nbsp;<\/div><div>&nbsp;.border-bottom::after {\n        -webkit-transform: scaleY(0.33);&nbsp;<\/div><div>&nbsp;transform: scaleY(0.33);&nbsp;<\/div><div>&nbsp;}&nbsp;<\/div><div>}<\/div><\/div><div><br><h3 id=\"t10\">Autoprefixer<\/h3><p>PostCSS最有名的插件是<a title=\"Autoprefixer\" href=\"https:\/\/github.com\/postcss\/autoprefixer\" target=\"_blank\" rel=\"nofollow\">Autoprefixer<\/a>。如名所示，可以自动为你添加浏览器私有前缀。它的添加值会参考<a title=\"Can I use... Support tables for HTML5, CSS3, etc\" href=\"http:\/\/caniuse.com\/\" target=\"_blank\" rel=\"nofollow\">Can I Use<\/a>及你设定的浏览器支持范围，因此相当可靠。下面是一个示例（以我设定的浏览器支持范围）：<\/p><pre><code>.container{\n    display: flex;\n}\n<\/code><\/pre><p>编译后：<a href=\"http:\/\/caibaojian.com\/postcss.html\">·<\/a><\/p><pre>\/\/code from http:\/\/caibaojian.com\/postcss.html\n<code>.container{\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n}<\/code><\/pre><br><\/div><div><h3 id=\"t10\">#css module<\/h3><\/div><div>依赖webpack的css-loader，在vue项目<\/div><p>&lt;template&gt;<\/p><p>&nbsp; &nbsp; &nbsp;&lt;div&gt;&nbsp; &nbsp;&lt;span :class=\"$style.red\"&gt;&lt;\/span&gt;&nbsp; &nbsp; &lt;\/div&gt;<\/p><p>&lt;\/template&gt;<\/p><p>&lt;style <span style=\"color: rgb(194, 79, 74);\">module<\/span>&gt;<\/p><p>.red{color:red}<\/p><div>&lt;\/style&gt;<\/div><p>可以js访问$style<\/p><p>在react项目&nbsp;&nbsp;<br><\/p><pre>import styles from '.\/dialog.css';    <span style=\"color: rgb(194, 79, 74);\">\/\/ CSS MODULE 只作用于引入的文件<\/span><\/pre><div><pre>export default class Dialog extends React.Component {<br>  render() {<br>    const cx = classNames({<br>      [styles.confirm]: !this.state.disabled,<br>      [styles.disabledConfirm]: this.state.disabled<br>    });<br>    return &lt;div className={styles.root}&gt;<br>      &lt;a className={cx}&gt;Confirm&lt;\/a&gt;<br>      ...<br>    &lt;\/div&gt;<br>  }<br>}<\/pre><\/div><div>scoped缺点：属性选择器的性能是比较差的<\/div><div><br><\/div><div><br><\/div><div><br><\/div><div><br><\/div><div><br><\/div><div><br><\/div><p><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/6\/28 17:52:55",
"updatetime":"2020\/5\/18 15:56:32"
},
{
"id":38,
"title":"前后端分离--详解",
"content":"<p>版权声明：本文为博主原创文章，未经博主允许不得转载。 https:\/\/blog.csdn.net\/weixin_37539378\/article\/details\/79956760<br>一、前言<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ”前后端分离“已经成为互联网项目开发的业界标杆，通过Tomcat+Ngnix(也可以中间有个Node.js)，有效地进行解耦。并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前后端分离(解耦)的核心思想是：前端Html页面通过Ajax调用后端的RestFul API并使用Json数据进行交互。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 注：<br><br>&nbsp;&nbsp;&nbsp;&nbsp; 【在互联网架构中，web服务器：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 应用服务器：一般指像tomcat，jetty，resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有web服务器好。】<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一般只有Web服务器才能被外网访问，应用服务器只能内网访问。<br><br>二、为什么前后端分离<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一般公司后端开发人员直接兼顾前端的工作，一边实现API接口，一边开发页面，两者互相切换着做，而且根据不同的url动态拼接页面，这也导致后台的开发压力大大增加。前后端工作分配不均。不仅仅开发效率慢，而且代码难以维护。而前后端分离的话，则可以很好的解决前后端分工不均的问题，将更多的交互逻辑分配给前端来处理，而后端则可以专注于其本职工作，比如提供API接口，进行权限控制以及进行运算工作。而前端开发人员则可以利用nodejs来搭建自己的本地服务器，直接在本地开发，然后通过一些插件来将api请求转发到后台，这样就可以完全模拟线上的场景，并且与后台解耦。前端可以独立完成与用户交互的整一个过程，两者都可以同时开工，不互相依赖，开发效率更快，而且分工比较均衡。<br><br>三、从MVC到前后端分离<br><br>MVC 是一种经典的设计模式，全名为&nbsp;Model-View-Controller，即&nbsp;模型-视图-控制器。<br><br>其中，模型&nbsp;是用于封装数据的载体，例如，在 Java 中一般通过一个简单的&nbsp;POJO（Plain Ordinary Java Object）来表示，其本质是一个普通的 Java Bean，包含一系列的成员变量及其 getter\/setter 方法。对于&nbsp;视图&nbsp;而言，它更加偏重于展现，也就是说，视图决定了界面到底长什么样子，在 Java 中可通过 JSP 来充当视图，或者通过纯 HTML 的方式进行展现，而后者才是目前的主流。模型和视图需要通过&nbsp;控制器&nbsp;来进行粘合，例如，用户发送一个 HTTP 请求，此时该请求首先会进入控制器，然后控制器去获取数据并将其封装为模型，最后将模型传递到视图中进行展现。<br><br>综上所述，MVC 的交互过程如下图所示：<br><br><br><br>也就是说，我们输入的是 AJAX 请求，输出的是 JSON 数据，市面上有这样的技术来实现这个功能吗？答案是 REST。<br><br>REST 全称是 Representational State Transfer（表述性状态转移），它是 Roy Fielding 博士在 2000 年写的一篇关于软件架构风格的论文，此文一出，威震四方！国内外许多知名互联网公司纷纷开始采用这种轻量级的 Web 服务，大家习惯将其称为 RESTful Web Services，或简称 REST 服务。<br><br>如果将浏览器这一端视为前端，而服务器那一端视为后端的话，可以将以上改进后的 MVC 模式简化为以下前后端分离模式：<br><br><br><br>可见，有了 REST 服务，前端关注界面展现，后端关注业务逻辑，分工明确，职责清晰。<br><br>四、认识Rest架构<br><br><br>REST 本质上是使用 URL 来访问资源种方式。众所周知，URL 就是我们平常使用的请求地址了，其中包括两部分：请求方式&nbsp;与&nbsp;请求路径，比较常见的请求方式是 GET 与 POST，但在 REST 中又提出了几种其它类型的请求方式，汇总起来有六种：GET、POST、PUT、DELETE、HEAD、OPTIONS。尤其是前四种，正好与CRUD（Create-Retrieve-Update-Delete，增删改查）四种操作相对应，例如，GET（查）、POST（增）、PUT（改）、DELETE（删），这正是 REST 与 CRUD 的异曲同工之妙！需要强调的是，REST 是“面向资源”的，这里提到的资源，实际上就是我们常说的领域对象，在系统设计过程中，我们经常通过领域对象来进行数据建模。<br><br>REST 是一个“无状态”的架构模式，因为在任何时候都可以由客户端发出请求到服务端，最终返回自己想要的数据，当前请求不会受到上次请求的影响。也就是说，服务端将内部资源发布 REST 服务，客户端通过 URL 来访问这些资源，这不就是 SOA 所提倡的“面向服务”的思想吗？所以，REST 也被人们看做是一种“轻量级”的 SOA 实现技术，因此在企业级应用与互联网应用中都得到了广泛应用。<br><br>下面我们举几个例子对 REST 请求进行简单描述：<br><br>REST 请求\t描述<br>GET:\/advertisers\t获取所有的广告主<br>GET:\/advertiser\/1\t获取 ID 为 1 的广告主<br>PUT:\/advertiser\/1\t更新 ID 为 1 的广告主<br>DELETE:\/advertiser\/1\t删除 ID 为 1 的广告主<br>POST:\/advertiser\t创建广告主<br>可见，请求路径相同，但请求方式不同，所代表的业务操作也不同，例如，\/advertiser\/1 这个请求，带有 GET、PUT、DELETE 三种不同的请求方式，对应三种不同的业务操作。<br><br>虽然 REST 看起来还是很简单的，实际上我们往往需要提供一个 REST 框架，让其实现前后端分离架构，让开发人员将精力集中在业务上，而并非那些具体的技术细节。<br>五、前后端分离意义大吗？<br><br>1、该网站前端变化远比后端变化频繁，则意义大。<br><br>2、该网站尚处于原始开发模式，数据逻辑与表现逻辑混杂不清，则意义大。<br><br>3、该网站前端团队和后端团队分属两个领导班子，技能点差异很大，则意义大。<br><br>4、该网站前端效果绚丽\/跨设备兼容要求高，则意义大。<br><br>六、术业有专攻（开发人员分离）<br><br>以前的JavaWeb项目大多数都是java程序员又当爹又当妈，又搞前端（ajax\/jquery\/js\/html\/css等等），又搞后端（java\/mysql\/oracle等等）。<br><br>随着时代的发展，渐渐的许多大中小公司开始把前后端的界限分的越来越明确，前端工程师只管前端的事情，后端工程师只管后端的事情。<br>正所谓术业有专攻，一个人如果什么都会，那么他毕竟什么都不精。<br><br>大中型公司需要专业人才，小公司需要全才，但是对于个人职业发展来说，我建议是分开。<br><br>对于后端java工程师：<br>把精力放在java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务隔离与锁机制，mongodb，http\/tcp，多线程，分布式架构（dubbo，dubbox，spring cloud），弹性计算架构，微服务架构（springboot+zookeeper+docker+jenkins），java性能优化，以及相关的项目管理等等。<br>后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等。<br><br>对于前端工程师：<br>把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less\/sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。<br>前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。<br><br><br>七、耦合时代<br><br>几曾何时，我们的JavaWeb项目都是使用了若干后台框架，springmvc\/struts + spring + spring jdbc\/hibernate\/mybatis 等等。<br><br>大多数项目在java后端都是分了三层，控制层（controller\/action），业务层（service\/manage），持久层（dao）。<br>控制层负责接收参数，调用相关业务层，封装数据，以及路由&amp;渲染到jsp页面。<br>然后jsp页面上使用各种标签（jstl\/el\/struts标签等）或者手写java表达式（&lt;%=%&gt;）将后台的数据展现出来，玩的是MVC那套思路。<br><br>我们先看这种情况：需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？<br>你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器（tomcat\/jboss\/weblogic\/websphere\/jetty\/resin）里，对吧？<br><br>发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，dns等等相关，你的网站就可以访问了（假设你是个网站）。<br>那我们来看，你的前后端代码是不是全都在那个war包里？包括你的js，css，图片，各种第三方的库，对吧？<br><br>好，下面在浏览器中输入你的网站域名（www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）<br>我捡干的说了啊，基础不好的童鞋请自己去搜。<br><br>浏览器在通过域名通过dns服务器找到你的服务器外网ip,将http请求发送到你的服务器，在tcp3次握手之后（http下面是tcp\/ip），通过tcp协议开始传输数据，你的服务器得到请求后，开始提供服务，接收参数，之后返回你的应答给浏览器，浏览器再通过content-type来解析你返回的内容，呈现给用户。<br><br>那么我们来看，我们先假设你的首页中有100张图片，此时，用户的看似一次http请求，其实并不是一次，用户在第一次访问的时候，浏览器中不会有缓存，你的100张图片，浏览器要连着请求100次http请求（有人会跟我说http长连短连的问题，不在这里讨论），你的服务器接收这些请求，都需要耗费内存去创建socket来玩tcp传输（消耗你服务器上的计算资源）。<br><br>重点来了，这样的话，你的服务器的压力会非常大，因为页面中的所有请求都是只请求到你这台服务器上，如果1个人还好，如果10000个人并发访问呢（先不聊服务器集群，这里就说是单实例服务器），那你的服务器能扛住多少个tcp连接？你的带宽有多大？你的服务器的内存有多大？你的硬盘是高性能的吗？你能抗住多少IO？你给web服务器分的内存有多大？会不会宕机？<br><br>这就是为什么，越是大中型的web应用，他们越是要解耦。<br>理论上你可以把你的数据库+应用服务+消息队列+缓存+用户上传的文件+日志+等等都扔在一台服务器上，你也不用玩什么服务治理，也不用做什么性能监控，什么报警机制等等，就乱成一锅粥好了。<br>但是这样就好像是你把鸡蛋都放在一个篮子里，隐患非常大。如果因为一个子应用的内存不稳定导致整个服务器内存溢出而hung住，那你的整个网站就挂掉了。<br><br>如果出意外挂掉，而恰好这时你们的业务又处于井喷式发展高峰期，那么恭喜你，业务成功被技术卡住，很可能会流失大量用户，后果不堪设想。<br>注意：技术一定是要走在业务前面的，否则你将错过最佳的发展期。<br><br>此外，你的应用全部都耦合在一起，相当于一个巨石，当服务端负载能力不足时，一般会使用负载均衡的方式，将服务器做成集群，这样其实你是在水平扩展一块块巨石，性能加速度会越来越低，<br>要知道，本身负载就低的功能or模块是没有必要水平扩展的，在本文中的例子就是你的性能瓶颈不在前端，那干嘛要水平扩展前端呢？？？<br>还有发版部署上线的时候，我明明只改了后端的代码，为什么要前端也跟着发布呢？？？<br>（引用：《架构探险-轻量级微服务架构》，黄勇）<br><br>正常的互联网架构，是都要拆开的，你的web服务器集群，你的应用服务器集群+文件服务器集群+数据库服务器集群+消息队列集群+缓存集群等等。<br>JSP的痛点<br><br>以前的javaWeb项目大多数使用jsp作为页面层展示数据给用户，因为流量不高，因此也没有那么苛刻的性能要求，但现在是大数据时代，对于互联网项目的性能要求是越来越高，<br>因此原始的前后端耦合在一起的架构模式已经逐渐不能满足我们，因此我们需要需找一种解耦的方式，来大幅度提升我们的负载能力。<br><br>1.动态资源和静态资源全部耦合在一起，服务器压力大，因为服务器会收到各种http请求，例如css的http请求，js的，图片的等等。<br>一旦服务器出现状况，前后台一起玩完，用户体验极差。<br><br>2.UI出好设计图后，前端工程师只负责将设计图切成html，需要由java工程师来将html套成jsp页面，出错率较高（因为页面中经常会出现大量的js代码），<br>修改问题时需要双方协同开发，效率低下。<br><br>3.jsp必须要在支持java的web服务器里运行（例如tomcat，jetty，resin等），无法使用nginx等（nginx据说单实例http并发高达5w，这个优势要用上），<br>性能提不上来。<br><br>4.第一次请求jsp，必须要在web服务器中编译成servlet，第一次运行会较慢。<br><br>5.每次请求jsp都是访问servlet再用输出流输出的html页面，效率没有直接使用html高（是每次哟，亲~）。<br><br>6.jsp内有较多标签和表达式，前端工程师在修改页面时会捉襟见肘，遇到很多痛点。<br><br>7.如果jsp中的内容很多，页面响应会很慢，因为是同步加载。<br><br>8.需要前端工程师使用java的ide（例如eclipse），以及需要配置各种后端的开发环境，你们有考虑过前端工程师的感受吗。<br><br>基于上述的一些痛点，我们应该把整个项目的开发权重往前移，实现前后端真正的解耦！<br>开发模式<br><br>以前老的方式是：<br>1.产品经历\/领导\/客户提出需求<br>2.UI做出设计图<br>3.前端工程师做html页面<br>4.后端工程师将html页面套成jsp页面（前后端强依赖，后端必须要等前端的html做好才能套jsp。如果html发生变更，就更痛了，开发效率低）<br>5.集成出现问题<br>6.前端返工<br>7.后端返工<br>8.二次集成<br>9.集成成功<br>10.交付<br><br><br><br>新的方式是：<br>1.产品经历\/领导\/客户提出需求<br>2.UI做出设计图<br>3.前后端约定接口&amp;数据&amp;参数<br>4.前后端并行开发（无强依赖，可前后端并行开发，如果需求变更，只要接口&amp;参数不变，就不用两边都修改代码，开发效率高）<br>5.前后端集成<br>6.前端页面调整<br>7.集成成功<br>8.交付<br><br><br>请求方式<br><br>以前老的方式是：<br>1.客户端请求<br>2.服务端的servlet或controller接收请求（后端控制路由与渲染页面，整个项目开发的权重大部分在后端）<br>3.调用service,dao代码完成业务逻辑<br>4.返回jsp<br>5.jsp展现一些动态的代码<br><br><br><br>新的方式是：<br>1.浏览器发送请求<br>2.直接到达html页面（前端控制路由与渲染页面，整个项目开发的权重前移）<br>3.html页面负责调用服务端接口产生数据（通过ajax等等，后台返回json格式数据，json数据格式因为简洁高效而取代xml）<br>4.填充html，展现动态效果，在页面上进行解析并操作DOM。<br>（有兴趣的童鞋可以访问一下阿里巴巴等大型网站，然后按一下F12，监控一下你刷新一次页面，他的http是怎么玩的，大多数都是单独请求后台数据，<br>使用json传输数据，而不是一个大而全的http请求把整个页面包括动+静全部返回过来）<br><br>总结一下新的方式的请求步骤：<br>大量并发浏览器请求---&gt;web服务器集群(nginx)---&gt;应用服务器集群(tomcat)---&gt;文件\/数据库\/缓存\/消息队列服务器集群<br>同时又可以玩分模块，还可以按业务拆成一个个的小集群，为后面的架构升级做准备。<br><br>前后分离的优势<br>1.可以实现真正的前后端解耦，前端服务器使用nginx。<br>前端\/WEB服务器放的是css，js，图片等等一系列静态资源（甚至你还可以css，js，图片等资源放到特定的文件服务器，例如阿里云的oss，并使用cdn加速），前端服务器负责控制页面引用&amp;跳转&amp;路由，前端页面异步调用后端的接口，后端\/应用服务器使用tomcat（把tomcat想象成一个数据提供者），加快整体响应速度。<br>（这里需要使用一些前端工程化的框架比如nodejs，react，router，react，redux，webpack）<br><br>2.发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象。<br>页面逻辑，跳转错误，浏览器兼容性问题，脚本错误，页面样式等问题，全部由前端工程师来负责。<br>接口数据出错，数据没有提交成功，应答超时等问题，全部由后端工程师来解决。<br>双方互不干扰，前端与后端是相亲相爱的一家人。<br><br>3.在大并发情况下，我可以同时水平扩展前后端服务器，比如淘宝的一个首页就需要2000+台前端服务器做集群来抗住日均多少亿+的日均pv。<br>（去参加阿里的技术峰会，听他们说他们的web容器都是自己写的，就算他单实例抗10万http并发，2000台是2亿http并发，并且他们还可以根据预知洪峰来无限拓展，很恐怖，就一个首页。。。）<br><br>4.减少后端服务器的并发\/负载压力<br>除了接口以外的其他所有http请求全部转移到前端nginx上，接口的请求调用tomcat，参考nginx反向代理tomcat。<br>且除了第一次页面请求外，浏览器会大量调用本地缓存。<br><br>5.即使后端服务暂时超时或者宕机了，前端页面也会正常访问，只不过数据刷不出来而已。<br><br>6.也许你也需要有微信相关的轻应用，那样你的接口完全可以共用，如果也有app相关的服务，<br>那么只要通过一些代码重构，也可以大量复用接口，提升效率。（多端应用）<br><br>7.页面显示的东西再多也不怕，因为是异步加载。<br><br>8.nginx支持页面热部署，不用重启服务器，前端升级更无缝。<br><br>9.增加代码的维护性&amp;易读性（前后端耦在一起的代码读起来相当费劲）。<br><br>10.提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖。<br><br>11.在nginx中部署证书，外网使用https访问，并且只开放443和80端口，其他端口一律关闭（防止黑客端口扫描），<br>内网使用http，性能和安全都有保障。<br><br>12.前端大量的组件代码得以复用，组件化，提升开发效率，抽出来！<br>注意事项<br><br>1.在开需求会议的时候，前后端工程师必须全部参加，并且需要制定好接口文档，后端工程师要写好测试用例（2个维度），不要让前端工程师充当你的专职测试，<br>推荐使用chrome的插件postman或soapui或jmeter，service层的测试用例拿junit写。ps：前端也可以玩单元测试吗？<br><br>2.上述的接口并不是java里的interface，说白了调用接口就是调用你controler里的方法。<br><br>3.加重了前端团队的工作量，减轻了后端团队的工作量，提高了性能和可扩展性。<br><br>4.我们需要一些前端的框架来解决类似于页面嵌套，分页，页面跳转控制等功能。（上面提到的那些前端框架）。<br><br>5.如果你的项目很小，或者是一个单纯的内网项目，那你大可放心，不用任何架构而言，但是如果你的项目是外网项目，呵呵哒。<br><br>6.以前还有人在使用类似于velocity\/freemarker等模板框架来生成静态页面，仁者见仁智者见智。<br><br>7.这篇文章主要的目的是说jsp在大型外网java web项目中被淘汰掉，可没说jsp可以完全不学，对于一些学生朋友来说，jsp\/servlet等相关的java web基础还是要掌握牢的，不然你以为springmvc这种框架是基于什么来写的？<br><br>8.如果页面上有一些权限等等相关的校验，那么这些相关的数据也可以通过ajax从接口里拿。<br><br>9.对于既可以前端做也可以后端做的逻辑，我建议是放到前端，为什么？<br>因为你的逻辑需要计算资源进行计算，如果放到后端去run逻辑，则会消耗带宽&amp;内存&amp;cpu等等计算资源，你要记住一点就是<br>服务端的计算资源是有限的，而如果放到前端，使用的是客户端的计算资源，这样你的服务端负载就会下降（高并发场景）。<br>类似于数据校验这种，前后端都需要做！<br><br>10.前端需要有机制应对后端请求超时以及后端服务宕机的情况，友好的展示给用户。<br><br>扩展阅读<br><br>1.其实对于js，css，图片这类的静态资源可以考虑放到类似于阿里云的oss这类文件服务器上（如果是普通的服务器&amp;操作系统，存储在到达pb级的文件后，或者单个文件夹内的文件数量达到3-5万，<br>io会有很严重的性能问题），<br>再在oss上配cdn（全国子节点加速），这样你页面打开的速度像飞一样， 无论你在全国的哪个地方，并且你的nginx的负载会进一步降低。<br><br>2.如果你要玩轻量级微服务架构，要使用nodejs做网关，用nodejs的好处还有利于seo优化，因为nginx只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，<br>这使得应用得不到良好的搜索引擎支持。同时因为nginx不会进行页面的组装渲染，需要把静态页面返回到浏览器，然后完成渲染工作，这加重了浏览器的渲染负担。<br>浏览器发起的请求经过nginx进行分发，URL请求统一分发到nodejs，在nodejs中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应。<br><br>3.如果遇到跨域问题，spring4的CORS可以完美解决，但一般使用nginx反向代理都不会有跨域问题，除非你把前端服务和后端服务分成两个域名。<br>JSONP的方式也被淘汰掉了。<br><br>4.如果想玩多端应用，注意要去掉tomcat原生的session机制，要使用token机制，使用缓存（因为是分布式系统），做单点，对于token机制的安全性问题，可以搜一下jwt。<br><br>5.前端项目中可以加入mock测试（构造虚拟测试对象来模拟后端，可以独立开发和测试），后端需要有详细的测试用例，保证服务的可用性与稳定性。<br>总结<br><br>前后端分离并非仅仅只是一种开发模式，而是一种架构模式（前后端分离架构）。<br>千万不要以为只有在撸代码的时候把前端和后端分开就是前后端分离了。需要区分前后端项目<br>前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。<br>前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署，前端通过ajax来调用http请求调用后端的restful api。<br>前端只需要关注页面的样式与动态数据的解析&amp;渲染，而后端专注于具体业务逻辑。<br>--------------------- <br>作者：山河远阔 <br>来源：CSDN <br>原文：https:\/\/blog.csdn.net\/weixin_37539378\/article\/details\/79956760 <br>版权声明：本文为博主原创文章，转载请附上博文链接！<\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/7\/5 13:43:08",
"updatetime":"2019\/7\/5 13:43:08"
},
{
"id":39,
"title":"VC创",
"content":"<p><span style=\"text-decoration-line: line-through;\"><\/span><a href=\"http:\/\/blog.sina.com.cn\/s\/blog_5ce0a6480100dstl.html\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">http:\/\/blog.sina.com.cn\/s\/blog_5ce0a6480100dstl.html<\/a><br><\/p><p>Termsheet&nbsp;<a href=\"http:\/\/blog.sina.com.cn\/s\/blog_5ce0a6480100azn2.html\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">Termsheet<\/a>&nbsp;<\/p>",
"name":"Eric",
"uid":1,
"type":"0",
"createtime":"2019\/7\/29 17:18:26",
"updatetime":"2019\/7\/30 17:17:50"
},
{
"id":40,
"title":"正则",
"content":"<p>能用正则解决的绝逼不用其他选择！<br><br><\/p><p>^ 匹配输入行首  $匹配输入行尾<br><\/p><p>* 等价于{0,}    +等价于{1,}<br>? 等价于{0,1}   <br>? 当该字符跟在任何一个其他限制符（*,+,?,{n},{n,},{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能的匹配所搜索的字符串。例如，对于字符串'oooo','o+'将尽可能多的匹配'o'，得到结果['oooo']，而'o+?'将尽可能少的匹配'o',得到结果['o','o','o','o']<\/p><p><br><\/p><p>\/$a(?!bc)\/&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #只要前面为a后面不为bc的通过<\/p><p>\/(?!&lt;a)b(?!c)\/&nbsp; &nbsp; &nbsp; &nbsp; #字符b,只有在前面不是a,且后边不是c的情况下通过;<\/p><p><br><\/p><p>let reggg = \/^(.*?\/\/.*?)\/\/<\/p><p>reggg.test('https:\/\/www.aiheart.top\/eblog\/static\/img\/headbk.34bab3b.jpg')<\/p><p>RegExp.$1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; 'https:\/\/www.aiheart.top'<\/p><p><br><br>###判断是否为有效ip<br>let validIP = params =&gt;{<br>    let reg = \/^(d+).(d+).(d+).(d+)$\/<\/p><p>    if(reg.test(params)){<br>        if(RegExp.$1&lt;256&amp;&amp;RegExp.$2&lt;256&amp;&amp;RegExp.$3&lt;256&amp;&amp;RegExp.$4&lt;256){<br>             return true<br>        }<br>    }<br>    return false<br>}<br>这样192.00.00.1也可以透过。下面方法解决这个问题<br><\/p><p><span style=\"color: rgb(194, 79, 74);\">#1<\/span><\/p><p>let validIP = string =&gt;{<\/p><p>    let reg = \/^(d+).(d+).(d+).(d+)$\/<br>    let reg1 = \/^(0d+)$\/<br>    if(reg.test(string)){<br>         let a = RegExp.$1,b = RegExp.$2,c=RegExp.$3,d = RegExp.$4<br>         if(reg1.test(a)||reg1.test(b)||reg1.test(c)||reg1.test(d)){return false}<br>         if(a&lt;256&amp;&amp;b&lt;256&amp;&amp;c&lt;256&amp;&amp;d&lt;256){return true}<\/p><p>    }<br>    return false<br>}<\/p><p><span style=\"color: rgb(194, 79, 74);\">#2<\/span><br>let validIP = params =&gt;{   <br>    var reg =  \/^(0|[1-9]d?|1dd|2[0-4]d|25[0-5]).(0|[1-9]d?|1dd|2[0-4]d|25[0-5]).(0|[1-9]d?|1dd|2[0-4]d|25[0-5]).(0|[1-9]d?|1dd|2[0-4]d|25[0-5])$\/<\/p><p>    return reg.test(ip);   <br>}<br><br><br>###去除前后空格<br>\"\n\n&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -42\n\n&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; \".replace(\/(^s*)|(s*$)\/,'')              \/\/\"-42&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; \"<\/p><p>\"\n\n&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -42&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;\".replace(\/(^s*)|(s*$)\/g,'')              \/\/\"-42    \"<br><br>\"42 43\".match(\/d+\/)&nbsp;<\/p><p>\/\/[\"42\", index: 0, input: \"42 43\", groups: undefined]<br><br>\"42 43\".match(\/d+\/g)<\/p><p>\/\/[\"42\", \"43\"]<br><br><br><br>###exec<br>let reg = \/eric\/g<br><br>reg.exec('what does eric say?oh it is eric')           <br>\/\/[\"eric\", index: 10, input: \"what does eric say?oh it is eric\", groups: undefined]<br><br>reg.exec('what does eric say?oh it is eric')   <br>\/\/[\"eric\", index: 28, input: \"what does eric say?oh it is eric\", groups: undefined]<br><br>reg.exec('what does eric say?oh it is eric')<br>\/\/null<br><br>重复循环。。。<br>在第一次调用时如果设reg.lastIndex = 0就又回归最初的模样<br><br><br>###别犯低级错误<br>let reg = \/^eric$\/<br>用构造函数写let reg = new RegExp('\/^eric$\/')  是错误的<br>应该是let reg = new RegExp('^eric$')<br><br><br><br>业务常见正则<\/p><div><span>e<\/span><span>.<\/span><span>exports<\/span><span>&nbsp;=&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>invoicePhone:<\/span><span>&nbsp;\/<\/span><span>(<\/span><span>^<\/span><span>d<\/span><span>{3,4}<\/span><span>-d<\/span><span>{7,8}<\/span><span>$<\/span><span>)<\/span><span>|<\/span><span>(<\/span><span>^<\/span><span>d<\/span><span>{3,4}<\/span><span>-d<\/span><span>{7,8}<\/span><span>-d<\/span><span>{3}<\/span><span>$<\/span><span>)<\/span><span>|<\/span><span>(<\/span><span>^<\/span><span>d<\/span><span>{10,15}<\/span><span>$<\/span><span>)<\/span><span>\/<\/span><span>,<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>creditCode:<\/span><span>&nbsp;<\/span><span>\/<\/span><span>(<\/span><span>^<\/span><span>(?![<\/span><span>a-zA-Z<\/span><span>]<\/span><span>+<\/span><span>$<\/span><span>)[<\/span><span>0-9A-Za-z<\/span><span>]<\/span><span>{8}<\/span><span>$<\/span><span>)<\/span><span>|<\/span><span>(<\/span><span>^<\/span><span>(?![<\/span><span>a-zA-Z<\/span><span>]<\/span><span>+<\/span><span>$<\/span><span>)[<\/span><span>0-9A-Za-z<\/span><span>]<\/span><span>{15,16}<\/span><span>$<\/span><span>)<\/span><span>|<\/span><span>(<\/span><span>^<\/span><span>(?![<\/span><span>a-zA-Z<\/span><span>]<\/span><span>+<\/span><span>$<\/span><span>)[<\/span><span>0-9A-Za-z<\/span><span>]<\/span><span>{18}<\/span><span>$<\/span><span>)<\/span><span>|<\/span><span>(<\/span><span>^<\/span><span>(?![<\/span><span>a-zA-Z<\/span><span>]<\/span><span>+<\/span><span>$<\/span><span>)[<\/span><span>0-9A-Za-z<\/span><span>]<\/span><span>{20}<\/span><span>$<\/span><span>)<\/span><span>\/<\/span><span>,<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>accountBankCode:<\/span><span>&nbsp;\/<\/span><span>(<\/span><span>^<\/span><span>[<\/span><span>0-9<\/span><span>]<\/span><span>*<\/span><span>)<\/span><span>$<\/span><span>\/<\/span><span>,<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>idCardCode:<\/span><span>&nbsp;<\/span><span>\/<\/span><span>(<\/span><span>^<\/span><span>d<\/span><span>{15}<\/span><span>$<\/span><span>)<\/span><span>|<\/span><span>(<\/span><span>^<\/span><span>d<\/span><span>{18}<\/span><span>$<\/span><span>)<\/span><span>|<\/span><span>(<\/span><span>^<\/span><span>d<\/span><span>{17}<\/span><span>[<\/span><span>x|X<\/span><span>]<\/span><span>$<\/span><span>)<\/span><span>|<\/span><span>(<\/span><span>^<\/span><span>[<\/span><span>0-9a-zA-Z<\/span><span>]<\/span><span>{1}<\/span><span>[<\/span><span>0-9<\/span><span>]<\/span><span>{6}<\/span><span>([<\/span><span>0-9<\/span><span>]<\/span><span>{3}<\/span><span>|<\/span><span>[<\/span><span><\/span><span>(<\/span><span>]<\/span><span>{1}<\/span><span>[<\/span><span>0-9aA<\/span><span>]<\/span><span>{1}<\/span><span>[<\/span><span><\/span><span>)<\/span><span>]<\/span><span>{1}<\/span><span>)<\/span><span>$<\/span><span>)<\/span><span>\/<\/span><span>,<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>businessLicenseCode:<\/span><span>&nbsp;\/<\/span><span>^<\/span><span>([<\/span><span>0-9a-zA-Z<\/span><span>]<\/span><span>{8}<\/span><span>|<\/span><span>[<\/span><span>0-9a-zA-Z<\/span><span>]<\/span><span>{15}<\/span><span>|<\/span><span>[<\/span><span>0-9a-zA-Z<\/span><span>]<\/span><span>{16}<\/span><span>|<\/span><span>[<\/span><span>0-9a-zA-Z<\/span><span>]<\/span><span>{18}<\/span><span>)<\/span><span>$<\/span><span>\/<\/span><span>,<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>telephone:<\/span><span>&nbsp;\/<\/span><span>^<\/span><span>(<\/span><span>(<\/span><span>d<\/span><span>{3,4})<\/span><span>|<\/span><span>d<\/span><span>{3,4}<\/span><span>-<\/span><span>|<\/span><span>s<\/span><span>)<\/span><span>?<\/span><span>d<\/span><span>{7,14}<\/span><span>$<\/span><span>\/<\/span><span>,<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>email:<\/span><span>&nbsp;\/<\/span><span>^<\/span><span>[<\/span><span>a-z0-9<\/span><span>]<\/span><span>+<\/span><span>([<\/span><span>._<\/span><span><\/span><span>-<\/span><span>]<\/span><span>*<\/span><span>[<\/span><span>a-z0-9<\/span><span>])<\/span><span>*<\/span><span>@<\/span><span>([<\/span><span>a-z0-9<\/span><span>]<\/span><span>+<\/span><span>[<\/span><span>-a-z0-9<\/span><span>]<\/span><span>*<\/span><span>[<\/span><span>a-z0-9<\/span><span>]<\/span><span>+<\/span><span>.<\/span><span>)<\/span><span>{1,63}<\/span><span>[<\/span><span>a-z0-9<\/span><span>]<\/span><span>+<\/span><span>$<\/span><span>\/<\/span><span>,<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>orderEmail:<\/span><span>&nbsp;\/<\/span><span>^<\/span><span>[<\/span><span>A-Za-z0-9<\/span><span>u4e00<\/span><span>-<\/span><span>u9fa5<\/span><span>_-<\/span><span>.<\/span><span>]<\/span><span>+<\/span><span>@<\/span><span>[<\/span><span>a-zA-Z0-9<\/span><span>u4e00<\/span><span>-<\/span><span>u9fa5<\/span><span>_<\/span><span>-<\/span><span>]<\/span><span>+<\/span><span>(<\/span><span>.<\/span><span>[<\/span><span>a-zA-Z0-9<\/span><span>u4e00<\/span><span>-<\/span><span>u9fa5<\/span><span>_<\/span><span>-<\/span><span>]<\/span><span>+<\/span><span>)<\/span><span>+<\/span><span>$<\/span><span>\/<\/span><span>,<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>cellphone:<\/span><span>&nbsp;\/<\/span><span>^<\/span><span>1d<\/span><span>{10}<\/span><span>$<\/span><span>\/<\/span><span>,<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>password:<\/span><span>&nbsp;\/<\/span><span>^<\/span><span>(<\/span><span>d<\/span><span>+<\/span><span>[<\/span><span>a-zA-Z<\/span><span>]<\/span><span>+<\/span><span>|<\/span><span>[<\/span><span>a-zA-Z<\/span><span>]<\/span><span>+<\/span><span>d<\/span><span>+<\/span><span>)[<\/span><span>a-zA-Zd<\/span><span>]<\/span><span>*<\/span><span>$<\/span><span>\/<\/span><span>,<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>chinese:<\/span><span>&nbsp;\/<\/span><span>^<\/span><span>[<\/span><span>u4e00<\/span><span>-<\/span><span>u9fa5<\/span><span>]<\/span><span>+<\/span><span>$<\/span><span>\/<\/span><span>,<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>companyName:<\/span><span>&nbsp;\/<\/span><span>(<\/span><span>^<\/span><span>[<\/span><span>u4e00<\/span><span>-<\/span><span>u9fa5<\/span><span>a-zA-Z<\/span><span>]<\/span><span>+<\/span><span>[<\/span><span>（<\/span><span>u4e00<\/span><span>-<\/span><span>u9fa5<\/span><span>a-zA-Z）<\/span><span>]<\/span><span>+<\/span><span>[<\/span><span>u4e00<\/span><span>-<\/span><span>u9fa5<\/span><span>a-zA-Z<\/span><span>]<\/span><span>*<\/span><span>$<\/span><span>)<\/span><span>|<\/span><span>(<\/span><span>^<\/span><span>[<\/span><span>u4e00<\/span><span>-<\/span><span>u9fa5<\/span><span>a-zA-Z<\/span><span>]<\/span><span>$<\/span><span>)<\/span><span>\/<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><br>##电话格式<br>function createPhoneNumber(numbers){<br>return numbers.join('').replace(\/^(d{3})(d{3})(d*)$\/,'($1) $2-$3')<br>}<br>createPhoneNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) \/\/ \"(123) 456-7890\"<br>#犯了个低级错误，d[3]不是代表3个数字，而是一个数字和3. d{3}代表3个数字&nbsp;&nbsp;<br><br><br><br><br><br><br><br><br><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/8\/12 09:27:19",
"updatetime":"2020\/5\/16 07:56:23"
},
{
"id":42,
"title":"codewars+leetcode",
"content":"<p><span style=\"font-weight: bold;\">#数字字符串总乘<\/span><\/p><p>function multify(num){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; num = num.toString()<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; return num.split('').<span style=\"color: rgb(194, 79, 74);\">map(Number)<\/span>.reduce((a,b)=&gt;a*b)<\/p><p>}<\/p><p><span style=\"font-weight: bold;\">#for循环return false不等同于continue<\/span><\/p><p>function aha(){<br>&nbsp; &nbsp; &nbsp; &nbsp;let arr = [1,2,3,4,5,6,7,8]<br>&nbsp; &nbsp; &nbsp; &nbsp;for(let i=0;i&lt;arr.length;i++){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(arr[i]==3){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log(arr[i])<br>&nbsp; &nbsp; &nbsp; &nbsp;}<br>}<\/p><p>\/\/ 打印&nbsp; &nbsp; &nbsp; &nbsp;1&nbsp; &nbsp;2&nbsp; &nbsp;false<\/p><p><span style=\"font-weight: bold;\">#splice只能用在数组，字符串没有。而slice都可以用<\/span><\/p><p>'hello'.split('').splice(1,2).join('')&nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp;el&nbsp; &nbsp;<\/p><p>'hello'.substr(1,2)&nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp;el&nbsp; &nbsp;<\/p><p><span style=\"font-weight: bold;\">#for循环长度不能弄成动态的<\/span><\/p><p>function arrayMash (array1, array2) {<br>&nbsp; &nbsp; &nbsp; &nbsp; \/\/ do the mash<br>&nbsp; &nbsp; &nbsp; &nbsp; let arr = []<br>&nbsp; &nbsp; &nbsp; &nbsp; for(let i =0;i&lt;<span style=\"color: rgb(194, 79, 74);\">\n\narray1.length<\/span>;i++){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(i%2){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arr.push(array2.shift())<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }else{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arr.push(array1.shift())<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return arr<br>};<\/p><p>arrayMash([1,2,3], ['a','b','c'] )&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp; &nbsp;[1, \"a\"]<\/p><p>改为静态的：<\/p><p>function arrayMash (array1, array2) {<br>&nbsp; &nbsp; &nbsp; &nbsp; \/\/ do the mash<br>&nbsp; &nbsp; &nbsp; &nbsp; <span style=\"color: rgb(139, 170, 74);\">let len = array1.length<\/span><br>&nbsp; &nbsp; &nbsp; &nbsp; let arr = []<br>&nbsp; &nbsp; &nbsp; &nbsp; for(let i =0;i&lt;<span style=\"color: rgb(139, 170, 74);\">len<\/span>*2;i++){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(i%2){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arr.push(array2.shift())<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }else{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arr.push(array1.shift())<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return arr<br>};&nbsp;&nbsp;<br><\/p><p>arrayMash([1,2,3], ['a','b','c'] )&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp; &nbsp;[1, \"a\", 2, \"b\", 3, \"c\"]&nbsp;<\/p><p><br><\/p><p>\/\/x进制转为10进制<br>parseInt(10,2)    \/\/ 2<br>parseInt(12,8)    \/\/ 10<br>parseInt(12,16)   \/\/ 18<br><br>\/\/x进制转为y进制<br>(15).toString(2)  \/\/ '1111'<br>(10).toString(8)  \/\/ '12'<br>(18).toString(16) \/\/ '12'<br>(0x16).toString(2)  \/\/ '10110'<br><br>\/\/判断是否为整数<br>Number.isInteger(3)  \/\/  true<br><br>\/\/骆驼峰写法<br>String.prototype.camelCase=function(){<br>   return this.split(' ').map(function(word){<br>    return word[0].toUpperCase() + word.slice(1);<br>  }).join('');<br>}<br>这样输入''.camelCase()会报错<br>因为：<br>''.charAt(0)    \/\/ ''<br>''[0]    \/\/ undefined<br><br>\/\/注意字符和数字之间的运算<br>A Narcissistic Number<br>1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153<br>1^4 + 6^4 + 3^4 + 4^4 = 1 + 1296 + 81 + 256 = 1634<br>function narcissistic(value) {<br>  \/\/ Code me to return true or false<br>  let str = value.toString()<br>  return str == str.split('').reduce((a,b)=&gt;{<br>       return parseInt(a)+Math.pow(b,str.length)  <br>  },0)<br>}<br><br>\/\/a 1 b 2 c 3 ...<br>快捷获取let getNum = s =&gt; s.charCodeAt()-96<br><br>\/\/String.fromCharCode(97)       \/\/ 'a'<br><br>\/\/分析元素含量<br>function parseMolecule(formula) {<br>  \/\/ do your science here<br>  let reg = \/(([^()]*)|[[^[]]*]|{[^{}]*})(d+)\/g<br>  while(formula.match(reg)){<br>     formula = formula.replace(reg,(_,g,m)=&gt;{<br>         return g.slice(1,-1).repeat(m)<br>     })<br>  }<br>  return formula.match(\/[A-Z][a-z]?d*\/g).reduce((a,b)=&gt;{<br>        let [_,g,m] = b.match(\/([A-Z][a-z]?)(d*)\/)<br>        m = m?(+m):1<br>        a[g]=a[g]?a[g]+m:m<br>        return a<br>  },{})<br>}<br>parseMolecule('As2{Be4C5[BCo3(CO2)3]2}4Cu5')<br>{As: 2,B: 8,Be: 16,C: 44,Co: 24,Cu: 5,O: 48}<br><br>\/\/sort不仅能排序数字，也能排序字母<br>function sortGiftCode(code){<br>  \/\/TODO <br>  return code.split('').sort().join('')<br>}<br>sortGiftCode('zyxwvutsrqponmlkjihgfedcba')         \/\/'abcdefghijklmnopqrstuvwxyz'<br><br>#用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值 js<br>let getRandomArr = e =&gt;{<br>     if(e&lt;=0)return<br>     let rand = parseInt(31*Math.random()+2)<br>     let next = getRandomArr(e-1)<br>     if(Array.isArray(next)&amp;&amp;next.includes(rand)){<br>          return getRandomArr(e)<br>     }<br>     return next?[rand].concat(next):[rand]<br>}<br><br>\/\/Move the first letter of each word to the end of it,then add 'ay' to the end of the word.Leave punctuaction marks untouched<br>exp:<br>pigIt('Pig latin is cool'); \/\/ igPay atinlay siay oolcay<br>pigIt('Hello world !');     \/\/ elloHay orldway !<br><br>let pigIt = str =&gt; str.replace(\/(w)(w*)(s|$)\/g,'$2$1ay$3')<br>或者<br>let pigIt = str =&gt; str.replace(\/(w)(w*)(s|$)\/g,(_,a,b,c)=&gt;{<br>      return b+a+'ay'+c<br>})<\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/8\/27 15:59:15",
"updatetime":"2020\/3\/13 11:44:40"
},
{
"id":43,
"title":"English improvement",
"content":"<h2>##怎么写<\/h2><p>现在你可以试着写英文博客和日记了。你可以和我一样搭建一个个人博客，用英文写作。也可以自己写英文日记。这个时候你应该可以很顺畅用英文感悟人生和总结经验了。在怎么写上，推荐两个读物。<\/p><p>一个是 Elements of Style (风格的要素)，建议买原版读。这是一本简短精炼的书，教你怎么写作。英语专业的学生必读。你当然也能读。<\/p><p>二是乔治奥威尔的一篇论文 Politics and the English Language (政治与英语)，可以直接在网上看。我大学时读到这篇论文，学到很多。乔治奥威尔批评了英语中的矫饰虚浮的文风，提倡言而有实的写作。你在跟着英美本土写作者学英语时，也可能学到烂英语，这篇文章教你怎么识别出来。<\/p>",
"name":"Eric",
"uid":1,
"type":"0",
"createtime":"2019\/8\/28 09:26:51",
"updatetime":"2019\/8\/28 09:26:51"
},
{
"id":44,
"title":"事件循环event loop 和 promise",
"content":"<p>#<span style=\"font-weight: bold;\">#扒一扒PROMISE的原理，大家不要怕！<\/span>:<a href=\"https:\/\/juejin.im\/post\/5b66f2935188251afc259f45\" target=\"_blank\">https:\/\/juejin.im\/post\/5b66f2935188251afc259f45<\/a><br>promise原理：<a href=\"https:\/\/github.com\/nanaSun\/promise\/blob\/master\/p5.js\" target=\"_blank\">https:\/\/github.com\/nanaSun\/promise\/blob\/master\/p5.js<\/a><br><br><\/p><p><span style=\"font-weight: bold;\">#promise的race【谁跑的快，以谁为准执行回调】<\/span><\/p><p>比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下：&nbsp;<\/p><p>&nbsp;function requestImg(){<br><\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; return new Promise((resolve,reject)=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let img = new Image()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;img.onload = ()=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;resolve(img)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;img.src = 'aaa'<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;})<br>}<br><\/p><p>function timeout(){<br>&nbsp; &nbsp; &nbsp; &nbsp; return new Promise((resolve,reject)=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;setTimeout(()=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reject('图片请求超时')<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },5000)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;})<br>}<\/p><p>Promise.race([requestImg(),timeout()]).then(res=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log('请求成功：'+res)<br>},err=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log('报错：'+err)<br>})<\/p><p><br><\/p><p><span style=\"font-weight: bold;\">#look<\/span><\/p><div><div>Promise.resolve()\n  .then(() =&gt; {\n    return new Error('error!!!')\n  })\n  .then((res) =&gt; {\n    console.log('then: ', res)\n  })\n  .catch((err) =&gt; {\n    console.log('catch: ', err)\n  })<\/div>因为返回任意一个非 promise 的值都会被包裹成 promise 对象，即&nbsp;<code>return new Error('error!!!')<\/code>&nbsp;等价于&nbsp;<code>return Promise.resolve(new Error('error!!!'))<\/code>。&nbsp;<\/div><div>改成return Promise.reject(new Error('error!!!'))或者 throw new Error('error!!!') 就能被catch<\/div><p><br><\/p><p><br><\/p><h4>渲染进程（浏览器内核）<\/h4><p>浏览器的渲染进程是多线程的，页面的渲染，JavaScript 的执行，事件的循环，都在这个进程内进行：<\/p><ul><li><p><span style=\"color: rgb(77, 128, 191);\">GUI 渲染线程<\/span>：负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。<\/p><\/li><li><p><span style=\"color: rgb(77, 128, 191);\">JavaScript 引擎线程<\/span>：也称为 JavaScript 内核，负责处理 Javascript 脚本程序、解析 Javascript 脚本、运行代码等。（例如 V8 引擎）<\/p><\/li><li><p><span style=\"color: rgb(77, 128, 191);\">事件触发线程<\/span>：用来控制浏览器事件循环，注意这不归 JavaScript 引擎线程管，当事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。<\/p><\/li><li><p><span style=\"color: rgb(77, 128, 191);\">定时触发器线程<\/span>：传说中的&nbsp;<code>setInterval<\/code>&nbsp;与&nbsp;<code>setTimeout<\/code>&nbsp;所在线程，注意，W3C 在 HTML 标准中规定，规定要求&nbsp;<code>setTimeout<\/code>&nbsp;中低于 4ms 的时间间隔算为 4ms 。<\/p><\/li><li><p><span style=\"color: rgb(77, 128, 191);\">异步 http 请求线程<\/span>：在&nbsp;<code>XMLHttpRequest<\/code>&nbsp;连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就<strong>产生状态变更事件<\/strong>，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。<\/p><\/li><\/ul><p>注意，<strong>GUI 渲染线程与 JavaScript 引擎线程是互斥的<\/strong>，当 JavaScript 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中<strong>等到 JavaScript 引擎空闲时<\/strong>立即被执行。所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。<\/p><p><br>##Event Loop<br>事件循环（也叫事件机制）<span style=\"color: rgb(0, 0, 0);\">【是指浏览器或node的一种解决js单线程不阻塞的一种机制，也就是我们经常用异步的原理】<\/span><br>一个页面是一个进程，一个进程有多个线程。js是<span style=\"color: rgb(194, 79, 74);\">单线程【如果多线程会导致操作Dom引起的渲染冲突】<\/span><br>任务有两种：<br>1.宏任务<br><code>script<\/code>全部代码&nbsp; ，setTimeout，setInterval，setImmediate(只有IE和node才有)，requestAnimationFrame，MessageChannel&nbsp;&nbsp;<br>2.微任务<br>常见的Promise，process.nextTick，mutationObserver<\/p><p><span style=\"color: rgb(194, 79, 74);\">宏任务和微任务的区别<\/span><\/p><p><span style=\"color: rgb(194, 79, 74);\">1.宏任务：当前调用栈中执行的代码（主代码块，定时器）<\/span><\/p><p><span style=\"color: rgb(194, 79, 74);\">2.微任务：可以理解成当前宏任务执行完，在下一次宏任务执行前的任务（promise，mutationObserver）<\/span><\/p><p><br><br>主线程的任务会进入执行栈（后入先出的数据结构，这里每执行完一行代码就出来）<br>遇到同步代码会在执行栈执行，遇到异步代码（例如setTimeout就走定时触发器线程，规定时间到了的回调函数）会被丢到任务队列（先入先出的数据结构）。等主线程空闲下来后就把任务队列的任务（先读微任务队列，再读任务队列），放到执行栈执行。又空闲后又去读任务队列。这就是事件循环。<br><br><br>#JS引擎线程和GUI渲染线程是互斥的关系<br>\/\/ 宏任务--&gt;渲染--&gt;宏任务--&gt;渲染--&gt;。。。<br>1.<br>document.body.style = 'background:black';<br><br>document.body.style = 'background:red';<br><br>document.body.style = 'background:blue';<br><br>document.body.style = 'background:grey';<br><br><br>控制台执行一下~  <br>（页面背景瞬间变为灰色，以上代码属于同一次宏任务。所以全部执行完才触发页面渲染，渲染时GUI线程会将所有UI改动优化合并，所以视觉效果只变成灰色）<br><br>2.<br>document.body.style = 'background:blue';<br>setTimeout(function(){<br>    document.body.style = 'background:black'<br>},0)<br>控制台执行一下~  <br>（页面先显示成蓝色背景，然后瞬间变成了黑色背景，这是因为以上代码属于两次宏任务，第一次宏任务执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色。）<br><br><br>3.<br>document.body.style = 'background:blue'<br>Promise.resolve().then(()=&gt;{<br>    document.body.style = 'background:black'<br>})<br>控制台执行一下~ <br>（页面背景色直接变成黑色，没有经过蓝色的阶段，是因为，我们在宏任务中设置为蓝色，但在进行渲染前执行了微任务，在微任务中将背景变成了黑色，然后才执行的渲染）<br><br><br><br><br><br>嘿嘿，看看你是否真的懂？<br><br>console.log('script start')<br>async function async1() {<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; await async2()<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; console.log('async1 end')<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; await async3()<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; console.log('async13 end')<br>}<br>async function async2() {<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; console.log('async2 end') <br>}<br>async function async3() {<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; console.log('async3 end') <br>}<br>async1()<br><br>setTimeout(function() {<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; console.log('setTimeout')<br>}, 0)<br><br>new Promise(resolve =&gt; {<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; console.log('Promise')<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; resolve()<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; console.log('Promise0')&nbsp;&nbsp;<br>})<br>.then(function() {<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; console.log('promise1')<br>})<br>.then(function() {<br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;console.log('promise2')<br>})<br>console.log('script end')<\/p><p><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">#遇到<code style=\"font-size: 12px;\">then<\/code>，会将其分发到微任务<\/span><\/p><p><br><\/p><p>#再试试这个呢<\/p><p>async function async1(){<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; console.log('async1 start')<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; await async2()<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; console.log('async1 end')<br>  }<br>async function async2(){<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; console.log('async2')<br>}<br>console.log('script start')<br>setTimeout(function(){<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; console.log('setTimeout0') <br>},0)  <br>setTimeout(function(){<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; console.log('setTimeout3') <br>},3)  <br>setImmediate(() =&gt; console.log('setImmediate'));<br>process.nextTick(() =&gt; console.log('nextTick'));<br>async1();<br>new Promise(function(resolve){<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; console.log('promise1')<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; resolve();<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; console.log('promise2')<br>}).then(function(){<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; console.log('promise3')<br>})<br>console.log('script end')<\/p><p><br><\/p><p><br><\/p><p><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">result:<\/span><\/p><p>script start<br>async1 start<br>async2<br>promise1<br>promise2<br>script end<br>nextTick<br>async1 end<br>promise3<br>setTimeout0<br>setImmediate<br>setTimeout3<\/p><p><br><\/p><p>#node的事件循环<\/p><p>##基于libuv引擎，分为 6 个阶段，它们会按照顺序反复运行。<\/p><div><div><li><span style=\"color: rgb(0, 0, 0);\">timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调<\/span><\/li>\n<li>I\/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I\/O 回调<\/li>\n<li>idle, prepare 阶段：仅node内部使用<\/li>\n<li>poll 阶段：获取新的I\/O事件, 适当的条件下node将阻塞在这里<\/li>\n<li><span style=\"color: rgb(0, 0, 0);\">check 阶段：执行 setImmediate() 的回调<\/span><\/li>\n<li>close callbacks 阶段：执行 socket 的 close 事件回调<\/li><\/div><\/div><p><br>宏任务：script所有代码&nbsp; &nbsp;setTimeout()&nbsp; &nbsp; setInterval()&nbsp; &nbsp; &nbsp;setImmediate()<\/p><p>微任务：promise&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process.nextTick()&nbsp;<br><\/p><p><img src=\"https:\/\/user-gold-cdn.xitu.io\/2019\/1\/12\/16841bad1cda741f?imageView2\/0\/w\/1280\/h\/960\/format\/webp\/ignore-error\/1\"><br><\/p><p><br><\/p><p><span style=\"color: rgb(0, 0, 0); font-weight: bold;\">#浏览器与node的区别<\/span><\/p><p><span style=\"color: rgb(0, 0, 0); font-weight: bold;\"><br><\/span><\/p><div><div>console.log('start')<\/div><div>setTimeout(() =&gt; {&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp;console.log('timer1')&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp;Promise.resolve().then(function() {\n    console.log('promise1')\n  })&nbsp;<\/div><div>}, 0)&nbsp;<\/div><div>setTimeout(() =&gt; {&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp;console.log('timer2')&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp;Promise.resolve().then(function() {\n    console.log('promise2')\n  })<\/div><div>}, 0)&nbsp;<\/div><div>Promise.resolve().then(function() {\n  console.log('promise3')\n})&nbsp;<\/div><div>console.log('end')<\/div><\/div><p><span style=\"color: rgb(194, 79, 74);\">node【version 10及以前】：<\/span>'start‘ =》'end'=》'promise3'=》'timer1'=》'timer2'=》'promise1'=》'promise2'<\/p><p><span style=\"color: rgb(194, 79, 74);\">node【version 11】：&nbsp; 和浏览器一致<\/span><br><\/p><p>解析：【<strong>timers阶段有几个setTimeout\/setInterval都会依次执行<\/strong>，并不像浏览器端，每执行一个宏任务后就去执行一个微任务】<\/p><div><strong>浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务<\/strong>。&nbsp;<\/div><div><br><\/div><p><br><\/p><p>setTimeout(function timeout () {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log('timeout');<br>},0);<br>setImmediate(function immediate () {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log('immediate');<br>});<br><\/p><div><div><li>对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。<\/li>\n<li>首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的\n进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调<\/li>\n<li>如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了<\/li><\/div><span style=\"font-weight: bold;\"><div><span style=\"font-weight: bold;\"><br><\/span><\/div>#process.nextTick<\/span><\/div><div><div>setTimeout(() =&gt; {&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; console.log('timer1')&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; Promise.resolve().then(function() {\n   console.log('promise1')\n })&nbsp;<\/div><div>}, 0)&nbsp;<\/div><div>process.nextTick(() =&gt; {&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; console.log('nextTick')&nbsp;&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; process.nextTick(() =&gt; {&nbsp;&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.log('nextTick')&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process.nextTick(() =&gt; {&nbsp;&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log('nextTick')&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;process.nextTick(() =&gt; {&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.log('nextTick')&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;})<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; })<\/div><div>&nbsp; &nbsp; &nbsp; })<\/div><div>})&nbsp;<\/div><div>\/\/ nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;timer1=&gt;promise1<\/div><div>【process.nextTick这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。】<\/div><\/div><p><br><\/p><p><br><\/p><p><br><\/p><p><br><\/p><p><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/9\/4 09:42:17",
"updatetime":"2020\/5\/10 16:55:44"
},
{
"id":45,
"title":"vue富文本的坑",
"content":"<h2>##vue-quill-editor（<a href=\"https:\/\/surmon-china.github.io\/vue-quill-editor\/\" style=\"font-size: 12px; background-color: rgb(255, 255, 255);\">https:\/\/surmon-china.github.io\/vue-quill-editor\/<\/a>）<\/h2><pre>npm install vue-quill-editor quill-image-resize-module quill-image-drop-module highlight.js --save<\/pre><p>选择性加载module<\/p><p>图片：quill-image-resize-module(裁剪)&nbsp; &nbsp; quill-image-drop-module（拖曳）&nbsp;<\/p><p>额外配置处理：<\/p><div><span>{<\/span><\/div><div><span>                test:<\/span><span> \/<\/span><span>.<\/span><span>js<\/span><span>$<\/span><span>\/<\/span><span>,<\/span><\/div><div><span>                loader: <\/span><span>'babel-loader'<\/span><span>,<\/span><\/div><div><span>                exclude:<\/span><span> \/node_modules(?!<\/span><span>\/<\/span><span>quill-image-drop-module<\/span><span>|<\/span><span>quill-image-resize-module)\/<\/span><span>,<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>},<\/span><\/div><div><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><div>plugins: [<\/div><div>        new webpack.ProvidePlugin({<\/div><div>            'window.Quill': 'quill'<\/div><div>        })<\/div><div>    ]<\/div><div><span style=\"font-weight: bold;\">##Vue part<\/span><\/div><div><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><div>import hljs from 'highlight.js'<\/div><div>    import {<\/div><div>        quillEditor<\/div><div>    } from 'vue-quill-editor'<\/div><div>    \/\/ require styles<\/div><div>    import 'quill\/dist\/quill.core.css'<\/div><div>    import 'quill\/dist\/quill.snow.css'<\/div><div>    import 'quill\/dist\/quill.bubble.css'<\/div><div>    import VueQuillEditor, {<\/div><div>        Quill<\/div><div>    } from 'vue-quill-editor'<\/div><div>    import {<\/div><div>        ImageDrop<\/div><div>    } from 'quill-image-drop-module'<\/div><div>    import ImageResize from 'quill-image-resize-module'<\/div><div>    Quill.register('modules\/imageDrop', ImageDrop)<\/div><div>    Quill.register('modules\/imageResize', ImageResize)<\/div><\/divcourier><\/div><\/divcourier><\/div><p><span style=\"color: rgb(194, 79, 74);\"><a href=\"https:\/\/blog.csdn.net\/weixin_43968658\/article\/details\/88060540\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">vue-quill-editor设置字体大小<\/a><\/span><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/9\/20 10:36:26",
"updatetime":"2019\/9\/20 16:05:14"
},
{
"id":46,
"title":"Learning how to learn",
"content":"<p>MY FLAWS:<\/p><p>1.Easily distracted<\/p><p><br><\/p><p><br><\/p><p><br><\/p><p>高效学习:<\/p><p>1.番茄工作法（25分钟思考【集中模式】+5分钟休息【发散模式】&nbsp; ）&nbsp; &nbsp;<a href=\"https:\/\/tomato-timer.com\/\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/tomato-timer.com\/<\/a>&nbsp;&nbsp;<\/p><p>2.间隔重复很重要。相同主题6天每天学1个小时效果好于1天学6个小时<\/p><p>3.<a href=\"https:\/\/link.zhihu.com\/?target=http%3A\/\/www.scotthyoung.com\/learnonsteroids\/grab\/TranscriptFeynman.pdf\" target=\"_blank\" rel=\"nofollow noreferrer\" style=\"background-color: rgb(255, 255, 255);\">费曼技巧（The Feynman Technique）<\/a>（简单来说在费曼技巧中不仅要回忆自己所学的内容，还要<b>设法用一句话把每个概念解释清楚<\/b>。这对我们提出了更高的要求，也有利于达到更深的理解层次。）<\/p><p>4.思维导图（研究表明，图像可以直接唤醒右脑的&nbsp;<b>Visual Spatial Centers<\/b>。也就是说图像可以帮助你<b>更好地封装概念和知识<\/b>，从而形成更多和更加牢固的神经回路，日后就更容易回想起来。事实上其他的感觉也可以起到相似的作用，但对于人类来说视觉的地位是最重要的。）<\/p><p>5.找到自己容易错的地方,然后从错误中学习,不断的测试自己<\/p><p>6.关掉所有让人分心的提醒,手机短信,email,网站之类<\/p><p><span style=\"color: rgb(194, 79, 74);\">最终养成习惯吧<\/span><\/p><p><br><\/p><p>【集中模式和发散模式的切换，是学好新知识的前提。】<\/p><ul><li>打个比喻： 盖一面墙， 我们需要铺一层砖和黏合剂，等黏合剂干了把砖头稳固好， 再铺上面一层。 这样墙才能盖起来。 盖得太快太急， 墙可能会塌掉。<br><\/li><li>搭建神经网络也是这样。 Focue mode learning 就是连接神经元； diffuse mode learning 就是给时间让这些连接稳固。 对于好的神经网络搭建，两者缺一不可。<\/li><\/ul><p>【多种感官的刺激对学习效果更好，因为那样子的神经连接更丰富，更稳固】<\/p><p>【记忆系统】<\/p><ul><li>短期： 研究表明我们的短期记忆最多只能放四间事情。<br><\/li><li>长期： Chunking (对概念进行切割和封装) 做得越好， 记起来越容易，越牢靠。<\/li><\/ul>",
"name":"Eric",
"uid":1,
"type":"0",
"createtime":"2019\/9\/24 10:17:04",
"updatetime":"2019\/11\/12 15:21:23"
},
{
"id":47,
"title":"平时可能用到的工具",
"content":"<p>解决代码粘贴全部左对齐的bug，没错就是你这个wangeditor<\/p><p><a href=\"https:\/\/github.com\/wangfupeng1988\/wangEditor\/issues\/206\">https:\/\/github.com\/wangfupeng1988\/wangEditor\/issues\/206<\/a>&nbsp;&nbsp;<br><\/p><p><br><\/p><p><a href=\"https:\/\/www.jianshu.com\/p\/84dd2da33c82\" target=\"_blank\">代码管理——学会Git和Gitflow工作流<\/a><br><\/p><p><a href=\"https:\/\/www.jianshu.com\/p\/072587b47515\" target=\"_blank\">一篇文章，教你学会Git<\/a><br><\/p><p><br><\/p><p><span style=\"text-decoration-line: line-through;\"><\/span><span style=\"text-decoration-line: line-through;\"><\/span><a href=\"https:\/\/www.crx4chrome.com\/\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">谷歌插件商店（面翻墙）<\/a><br><\/p><p><a href=\"https:\/\/www.baiduyun.wiki\/\" target=\"_blank\">百度网盘直链下载助手<\/a><br><\/p><p><br><\/p><p>一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，附图是他们提供的 demo，效果很棒啊。 <a href=\"http:\/\/t.cn\/EUq8Rhz\" title=\"http:\/\/t.cn\/EUq8Rhz\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><img alt=\"http:\/\/t.cn\/EUq8Rhz\" draggable=\"false\" src=\"https:\/\/b-gold-cdn.xitu.io\/v3\/static\/img\/pin-url-link.3f843e8.svg\">t.cn\/EUq8Rhz<\/a>&nbsp;&nbsp;<br><\/p><p><br><\/p>",
"name":"Eric",
"uid":1,
"type":"0",
"createtime":"2019\/9\/24 15:47:44",
"updatetime":"2020\/5\/2 18:09:31"
},
{
"id":48,
"title":"散",
"content":"<p>个人所得税计算方式（2019）<img src=\"https:\/\/www.aiheart.top\/photo\/incomeTax0.png\" style=\"max-width:100%;\"><br><\/p><p><img src=\"https:\/\/www.aiheart.top\/photo\/incomeTax1.png\" style=\"max-width:100%;\"><br><\/p><p><img src=\"https:\/\/www.aiheart.top\/photo\/incomeTax2.png\" style=\"max-width:100%;\"><br><\/p>",
"name":"Eric",
"uid":1,
"type":"0",
"createtime":"2019\/9\/24 16:50:14",
"updatetime":"2019\/9\/24 16:50:14"
},
{
"id":49,
"title":"工作业务遇到的问题[+面问]+二进制",
"content":"<p><span style=\"color: rgb(194, 79, 74);\">##for interview<\/span><\/p><ol><li><p>做过的有特点的项目<\/p><\/li><li><p>遇到的问题与解决方案<\/p><\/li><\/ol><p>&nbsp; 3.有什么问我的(团队简介、前端参与项目的过程)&nbsp;&nbsp;<span style=\"color: rgb(194, 79, 74);\"><br><\/span><\/p><p><br><\/p><p><span style=\"color: rgb(194, 79, 74);\">##tortoise git<\/span><\/p><p><a href=\"https:\/\/www.jianshu.com\/p\/2790a860f151\">https:\/\/www.jianshu.com\/p\/2790a860f151<\/a>&nbsp;window下生成ssh<\/p><p><a href=\"https:\/\/blog.csdn.net\/dolores_peng\/article\/details\/78614309\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/blog.csdn.net\/dolores_peng\/article\/details\/78614309<\/a>&nbsp;配置tortoise git支持ssh远程拉取代码&nbsp;<span style=\"color: rgb(194, 79, 74);\"><br><\/span><\/p><p><br><\/p><p><span style=\"color: rgb(194, 79, 74);\">##nvm<\/span><\/p><p>#nvm切换node和npm版本<br>Github： https:\/\/github.com\/coreybutler\/nvm-windows\/releases<br>在安装 Nvm 之前，先将之前安装的 node 进行卸载。否则可能会出现无法切换 node 版本的问题<br>将之前安装的全局插件删除掉，否则可能会导致 nvm 命令不起作用。文件目录如下<br>C:UsersAdministratorAppDataRoaming\npm<br>C:UsersAdministratorAppDataRoaming\npm-cache<br><br>安装后要把nvm和nodejs放在同个路径下，且不能放在有空格的文件夹里<br>如：<br>root: D:Node\nvm<br>path: D:Node\nodejs<br><br>nvm 在下载NPM的时候速度相对来说较慢，可以修改NVM文件夹的settings.txt文件，追加两行代码，目的是使用国内的镜像下载<br>settings.txt内容如下<br>root: D:Node\nvm<br>path: D:NodeNodeJs<br>\/\/后面这两句是要追加的配置代码<br>node_mirror: https:\/\/npm.taobao.org\/mirrors\/node\/<br>npm_mirror: https:\/\/npm.taobao.org\/mirrors\/npm\/<br><br>nvm install latest：   安装最新的 nodejs 版本<br>nvm install 11.12.0：  安装对应的 nodejs 版本<br>nvm uninstall 11.12.0：卸载对应的 nodejs 版本<br>nvm list available：   列出所有可用的 nodejs 版本<br>nvm list：             查看 nvm 列出已经安装的 nodejs 版本<br>nvm use 11.12.0：      使用对应的 nodejs 版本<br>更多命令在命令行输入 nvm 即可查看<br><br><br>报错：exit status 1<br>原因：我把nvm安装到了有空格的路径上（D:Program Files），导致切换失败<br>解决：把nvm卸载重装到没有空格的路径上（例如：D:\nvm），即可解决问题<br><br>报错：The process cannot access the file because it is being used by another process.<br>解决：重新设置了如下的镜像，完美解决<br>nvm node_mirror  https:\/\/npm.taobao.org\/mirrors\/node\/<br>nvm npm_mirror  https:\/\/npm.taobao.org\/mirrors\/npm\/<br><br>#nrm切换npm下载源<br>npm install nrm -g<br><\/p><p><br><\/p><p><span style=\"color: rgb(194, 79, 74);\">##需求1：下载pdf<\/span><br>默认预览（浏览器支持的话）<br>弄成下载模式的话服务端返回的头部需要设置（例:）<br>Content-Disposition: \"attachment; filename=xxxx.pdf;\"<br>Content-Disposition: \"attachment; filename=xxxx.docx;\"<br>window.open(url)<br><br>还有一种解决方式是前端ajax请求'dataType': 'arraybuffer'<br>处理res<br>var blob = new Blob([res], {<br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; type: 'application\/json'<br>});<br>var url = window.URL.createObjectURL(blob);<br>var link = that.$refs.a;<br>link.href = url;<br>link.download = 'aha.pdf';<br>link.click();<br>window.URL.revokeObjectURL(link.href);<br><span style=\"color: rgb(194, 79, 74);\"><br>##Promise.all在项目中注意的地方<\/span><br>function getPostInfo(){<br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;return new Promise((resolve)=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;ajax({<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;url: 'https:\/\/www.aiheart.top\/api\/post\/findByPage',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;type:'post',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;data:{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageNum: 1,pageSize: 3<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;},<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;success(e){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;resolve(e)<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; })<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;})<br>}<br>function getUserInfo(){<br>&nbsp; &nbsp; &nbsp; &nbsp; return new Promise((resolve)=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ajax({&nbsp;<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;url: 'https:\/\/www.aiheart.top\/api\/post\/findAroundById',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;type:'post',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;data:{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageNum: 1,pageSize: 3<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;success(e){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;resolve(e)<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;})<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;})<br>}<br>Promise.all([getPostInfo(),getUserInfo()]).then(res=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; this.post = res[0]     \/\/ 接口出问题<br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; this.user = res[1]<br>})<br>上面业务，等所有请求完成后再直接回调。这时候如果有请求报404或505，没返回数据，那就一片空白。这用户体验很差。解决方式为：<br>Promise.all([getPostInfo(),getUserInfo()].map(p =&gt; p.catch(e =&gt; e))).then(res=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; this.post = res[0]<br>&nbsp; &nbsp; &nbsp; &nbsp; this.user = res[1]<br>})<br>这样的话就算接口出问题也不会影响到其他接口的数据展示<br><br><br><\/p><p><span style=\"color: rgb(194, 79, 74);\">##vue-router权限管理问题<\/span><br>#main.js<br>router.beforeEach(async(to,from,next)=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp;if(!store.state.hasRules){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;await store.dispatch('getMenuList')<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let r = await store.dispatch('getAuthRoute')<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log(r)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;router.addRoutes(r)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;next(to);<span style=\"color: rgb(194, 79, 74);\">  \/\/ router.addRoutes之后的next()可能会失效，因为可能next()的时候路由并没有完全add完成。用next(to)可以保证全部挂上去了<\/span><br>&nbsp; &nbsp; &nbsp; &nbsp; }else{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;next()<br>&nbsp; &nbsp; &nbsp; &nbsp;}<br>})<br><\/p><p><br><br><span style=\"color: rgb(194, 79, 74);\">##cnpm install的问题【Error: EBUSY: resource busy or locked, symlink....】<\/span><\/p><p>解决方式：关掉杀毒软件例如360<\/p><p>or&nbsp; 执行npm cache clean，再安装依赖。<\/p><p>再不行，把项目拷贝到了d盘里面【不知道为什么，我在F盘报错，D盘就不会】（不能把项目放到桌面哦）。<\/p><p><br><\/p><h4>##npm、cnpm与package-lock.json的操作<\/h4><p>package.json文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，在npm 5时添加package-lock.json。<br>npm i会根据package-lock.json里的内容来处理和安装依赖而不是package.json。<br>cnpm i不受package-lock.json影响，只会根据package.json进行下载。<br>npm i 会生成package-lock.json，如果删除了，再重新npm i会生成package-lock.json。<br>cnpm i是不会生成package-lock.json的。<br>cnpm i xxx@xxx不会跟新到package-lock.json中去。<br>npm i xxx@xxx会跟新到package-lock.json中去。<br><br><\/p><p><span style=\"color: rgb(0, 0, 0);\">#new Date()<\/span>.<span style=\"color: rgb(194, 79, 74);\">getTime()<\/span><span style=\"color: rgb(0, 0, 0);\">在ios显示NaN的问题<\/span><\/p><pre><code>let date = '2017-08-30'.replace(\/-\/g,'\/')\nnew Date(date).getTime()\n这样ios和安卓都能正常显示<\/code><\/pre><p><br><\/p><h3>#ArrayBuffer对象二进制接口<\/h3><p>原生ajax有responseType&nbsp;<\/p><table><tbody><tr><td><code>\"arraybuffer\"<\/code><\/td><td><a href=\"https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/XMLHttpRequest\/response\"><code>response<\/code><\/a>&nbsp;是一个包含二进制数据的 JavaScript&nbsp;<a href=\"https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/ArrayBuffer\"><code>ArrayBuffer<\/code><\/a>&nbsp;。<\/td><\/tr><\/tbody><\/table><table><tbody><tr><td><code>\"blob\"<\/code><\/td><td><code>response<\/code>&nbsp;是一个包含二进制数据的&nbsp;<a href=\"https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/Blob\"><code>Blob<\/code><\/a>&nbsp;对象 。<\/td><\/tr><\/tbody><\/table><table><tbody><tr><td><code>\"json\"<\/code><\/td><td><code>response<\/code>&nbsp;是一个 JavaScript 对象。这个对象是通过将接收到的数据类型视为&nbsp;<a href=\"https:\/\/developer.mozilla.org\/zh-CN\/docs\/Glossary\/JSON\">JSON<\/a>&nbsp;解析得到的。<\/td><\/tr><\/tbody><\/table><table><tbody><tr><td><code>\"text\"<\/code><\/td><td><code>response<\/code>&nbsp;是包含在&nbsp;<a href=\"https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/DOMString\"><code>DOMString<\/code><\/a>&nbsp;对象中的文本。<\/td><\/tr><\/tbody><\/table><p><br><\/p><div><span>this<\/span><span>.<\/span><span>$refs<\/span><span>.<\/span><span>file<\/span><span>.<\/span><span>onchange<\/span><span> <\/span><span>=<\/span><span> (<\/span><span>e<\/span><span>)<\/span><span>=&gt;<\/span><span>{<\/span><\/div><div><span>      <\/span><span>let<\/span><span> <\/span><span>file<\/span><span> <\/span><span>=<\/span><span> <\/span><span>e<\/span><span>.<\/span><span>target<\/span><span>.<\/span><span>files<\/span><span>[<\/span><span>0<\/span><span>]<\/span><\/div><div><span>      <\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>file<\/span><span>)<\/span><\/div><div><span style=\"font-weight: bold;\">\/\/ 二进制转url<\/span><\/div><div><span>      <\/span><span>\/\/ let fileUrl = window.URL.createObjectURL(file)<\/span><\/div><div><span style=\"font-weight: bold;\">\/\/ 二进制转base64&nbsp;&nbsp;<\/span><span><br><\/span><\/div><div><span>      <\/span><span>let<\/span><span> <\/span><span>fr<\/span><span> <\/span><span>=<\/span><span> <\/span><span>new<\/span><span> <\/span><span>FileReader<\/span><span>()<\/span><\/div><div><span>      <\/span><span>fr<\/span><span>.<\/span><span>readAsDataURL<\/span><span>(<\/span><span>file<\/span><span>)<\/span><\/div><div><span>      <\/span><span>fr<\/span><span>.<\/span><span>onload<\/span><span> <\/span><span>=<\/span><span> <\/span><span>function<\/span><span>(){<\/span><\/div><div><span>        <\/span><span>self<\/span><span>.<\/span><span>pic<\/span><span> <\/span><span>=<\/span><span> <\/span><span>this<\/span><span>.<\/span><span>result<\/span><\/div><div><span>      }<\/span><\/div><div><span>    }<\/span><\/div><div><span style=\"font-weight: bold;\">\/\/ 下载<\/span><\/div><div><div><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><div>download(pic){<\/div><div>this.$nextTick(()=&gt;{<\/div><div>let&nbsp;a&nbsp;=&nbsp;document.createElement('a')<\/div><div>a.download&nbsp;=&nbsp;'pic.png'<\/div><div>a.href&nbsp;=&nbsp;pic<\/div><div>document.body.appendChild(a)<\/div><div>a.click()<\/div><div>})<\/div><div>},<\/div><\/divcourier><\/div><\/div><div><span><br><\/span><\/div><div><span style=\"font-weight: bold;\">\/\/ canvas把多张图片合为一张<\/span><\/div><div><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><div>drawImage(){<\/div><div>      let imgs = document.getElementById('picBox').getElementsByTagName('img')&nbsp; \/\/ 获取所有要绘制的img dom<\/div><div>      let cvs = document.createElement('canvas')<\/div><div>      cvs.width = 1000<\/div><div>      cvs.height = 1000<\/div><div>      let ctx = cvs.getContext('2d')<\/div><div>      let startX = 0<\/div><div>      let startY = 0<\/div><div>      imgs.forEach(item=&gt;{<\/div><div>        ctx.drawImage(item,startX,startY,item.width,item.height)&nbsp; &nbsp; &nbsp; &nbsp;\/\/ 把图片写进去<\/div><div>        startY&nbsp;+= item.height<\/div><div>      })<\/div><div>      let bs64 = cvs.toDataURL('image\/png')&nbsp; &nbsp; \/\/ canvas转为base64<\/div><div>      console.log(bs64)<\/div><div>      this.download(bs64)<\/div><div>    },<\/div><\/divcourier><\/divcourier><\/div><div><span><br><\/span><\/div><div><span>#代理工具<\/span><\/div><div><span>charles<\/span><\/div><div><p>很多开发者都需要使用代理工具来调试接口，查看数据等等，但是有时候发现打开代理工具之后，代理工具同时也拦截了电脑的所有网络请求，导致电脑访问网站时提示（您的连接不是私密连接）。。。<\/p><div><img src=\"http:\/\/upload-images.jianshu.io\/upload_images\/3150602-a48d807f9562ba68.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240\" alt=\"\"><br><\/div><p>造成这种问题的原因就是charles等代理工具也拦截了电脑网页的请求，但是使用的是charles代理工具的证书，导致浏览器无法验证此网页的证书，进而导致了报错，那么该如何解决呢？我们只需要将charles的证书添加到电脑的信任证书中即可。<\/p><p>进入Charles的Help中，选择SSL Proxying，然后点击Install Charles Root Certificate。<\/p><div><img src=\"http:\/\/upload-images.jianshu.io\/upload_images\/3150602-cec9c776fb0f4a45.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240\" alt=\"\"><br><\/div><p>此时我们的Charles证书是不被系统信任的，所以访问网站每回都会报证书问题，然后我们点击安装证书。<\/p><div><img src=\"http:\/\/upload-images.jianshu.io\/upload_images\/3150602-4ef4d4e0d9fb6e0a.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240\" alt=\"\"><br><\/div><p>可以选择证书的安装位置，我选择的是本地计算机，所有用户都可以用，或者为了安全，也可以选择只给当前用户安装，那么别的windows用户就没有被安装此证书；<\/p><div><img src=\"http:\/\/upload-images.jianshu.io\/upload_images\/3150602-58eb023d49641c1c.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240\" alt=\"\"><br><\/div><p>然后为证书选择存储位置，这里必须手动选择存储位置，否则自动选择出来的证书位置仍然是不被信任的。<\/p><div><img src=\"http:\/\/upload-images.jianshu.io\/upload_images\/3150602-a8edc6290166717a.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240\" alt=\"\"><br><\/div><p>然后点击浏览，我们手动指定证书的存储位置为“受信任的根证书颁发机构”。<\/p><div><img src=\"http:\/\/upload-images.jianshu.io\/upload_images\/3150602-e5fa92a135cf1406.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240\" alt=\"\"><br><\/div><p>然后点击确定，完成，此时再次进入安装证书的步骤，我们就发现Charles证书已经被系统信任。<\/p><div><img src=\"http:\/\/upload-images.jianshu.io\/upload_images\/3150602-c6f43b4e67c7eb9f.png?imageMogr2\/auto-orient\/strip%7CimageView2\/2\/w\/1240\" alt=\"\"><br><\/div><p>此时，开着Charles再次访问网站，是不是已经可以正常访问了？如果还是报证书问题的话，试着重启一下电脑，重启之后就可以正常访问了。<\/p><\/div><div><span><br><\/span><\/div><p>问题：<br>按照一般流程操作后，发现Get\/Post请求都可以查看，但是有些CONNECT请求无法查看。<br>会报错SSLHandshake: Remote host closed connection during handshake<br><br>解决方案：<br>第一步，需要在Proxy Settings - Proxies HTTP Proxy中勾选Enable transparent HTTP proxying<br><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">第二步，检查iPhone的通用-关于本机-证书信任设置，是否信任了该证书。<\/span><\/p><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><br><br>#iphone X系列<\/p><pre>const isIphonex = () =&gt; {  \/\/ X XS, XS Max, XR\n    const xSeriesConfig = [\n        {\n            devicePixelRatio: 3,\n            width: 375,\n            height: 812,\n        },\n        {\n            devicePixelRatio: 3,\n            width: 414,\n            height: 896,\n        },\n        {\n            devicePixelRatio: 2,\n            width: 414,\n            height: 896,\n        },\n    ];  \/\/ h5\n    if (typeof window !== 'undefined' &amp;&amp; window) {\n        const isIOS = \/iphone\/gi.test(window.navigator.userAgent);\n        if (!isIOS) return false;\n        const {devicePixelRatio, screen} = window;\n        const {width, height} = screen;\n        return xSeriesConfig.some(item =&gt; item.devicePixelRatio === devicePixelRatio &amp;&amp; item.width === width &amp;&amp; item.height === height);\n    }\n    return false;\n}<\/pre><p>或媒体查询<\/p><pre>@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) {\n\n}\n@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) {\n\n}\n@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) {\n\n}<\/pre><p><br><\/p><p><br><\/p><div><span>\/**<\/span><\/div><div><span>&nbsp;*&nbsp;下载文件<\/span><\/div><div><span>&nbsp;*&nbsp;<\/span><span>@param<\/span><span>&nbsp;<\/span><span>request<\/span><\/div><div><span>&nbsp;*&nbsp;<\/span><span>@param<\/span><span>&nbsp;<\/span><span>defaultFileName<\/span><\/div><div><span>&nbsp;*&nbsp;<\/span><span>@param<\/span><span>&nbsp;<\/span><span>successCallback<\/span><span>&nbsp;function()&nbsp;{&nbsp;}<\/span><\/div><div><span>&nbsp;*&nbsp;<\/span><span>@param<\/span><span>&nbsp;<\/span><span>errorCallback<\/span><span>&nbsp;function(errorMsg)&nbsp;{&nbsp;}<\/span><\/div><div><span>&nbsp;*\/<\/span><\/div><div><span>export<\/span><span>&nbsp;<\/span><span>function<\/span><span>&nbsp;<\/span><span>downloadFileWithName<\/span><span>(<\/span><span>request<\/span><span>,&nbsp;<\/span><span>defaultFileName<\/span><span>&nbsp;=&nbsp;<\/span><span>'标准模板.xlsx'<\/span><span>,&nbsp;<\/span><span>successCallback<\/span><span>&nbsp;=&nbsp;()&nbsp;<\/span><span>=&gt;<\/span><span>&nbsp;{&nbsp;},&nbsp;<\/span><span>errorCallback<\/span><span>&nbsp;=&nbsp;()&nbsp;<\/span><span>=&gt;<\/span><span>&nbsp;{&nbsp;})&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>return<\/span><span>&nbsp;<\/span><span>request<\/span><span>.<\/span><span>then<\/span><span>(<\/span><span>response<\/span><span>&nbsp;<\/span><span>=&gt;<\/span><span>&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>const<\/span><span>&nbsp;<\/span><span>blob<\/span><span>&nbsp;=&nbsp;<\/span><span>new<\/span><span>&nbsp;<\/span><span>Blob<\/span><span>([<\/span><span>response<\/span><span>])<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>const<\/span><span>&nbsp;<\/span><span>a<\/span><span>&nbsp;=&nbsp;<\/span><span>document<\/span><span>.<\/span><span>createElement<\/span><span>(<\/span><span>'a'<\/span><span>)<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>const<\/span><span>&nbsp;<\/span><span>url<\/span><span>&nbsp;=&nbsp;<\/span><span>window<\/span><span>.<\/span><span>URL<\/span><span>.<\/span><span>createObjectURL<\/span><span>(<\/span><span>blob<\/span><span>)<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>const<\/span><span>&nbsp;<\/span><span>fileName<\/span><span>&nbsp;=&nbsp;<\/span><span>defaultFileName<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>try<\/span><span>&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>\/\/&nbsp;由于ie不支持download属性，故需要做兼容判断<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>window<\/span><span>.<\/span><span>navigator<\/span><span>.<\/span><span>msSaveBlob<\/span><span>(<\/span><span>response<\/span><span>,&nbsp;<\/span><span>fileName<\/span><span>)<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>successCallback<\/span><span>(<\/span><span>url<\/span><span>)<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<\/span><span>catch<\/span><span>&nbsp;(<\/span><span>e<\/span><span>)&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>a<\/span><span>.<\/span><span>href<\/span><span>&nbsp;=&nbsp;<\/span><span>url<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>a<\/span><span>.<\/span><span>download<\/span><span>&nbsp;=&nbsp;<\/span><span>fileName<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>a<\/span><span>.<\/span><span>click<\/span><span>()<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>window<\/span><span>.<\/span><span>URL<\/span><span>.<\/span><span>revokeObjectURL<\/span><span>(<\/span><span>url<\/span><span>)<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>successCallback<\/span><span>(<\/span><span>url<\/span><span>)<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;}<\/span><\/div><div><span>&nbsp;&nbsp;}).<\/span><span>catch<\/span><span>((<\/span><span>error<\/span><span>)&nbsp;<\/span><span>=&gt;<\/span><span>&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>if<\/span><span>&nbsp;(<\/span><span>errorCallback<\/span><span>)&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>errorCallback<\/span><span>(<\/span><span>error<\/span><span>)<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;}<\/span><\/div><div><span>&nbsp;&nbsp;})<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 15px;line-height:=\"\" 20px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>}<\/span><\/div><div><span><br><\/span><\/div><div><span><br><\/span><\/div><div><a href=\"https:\/\/www.jianshu.com\/p\/54709ba140aa\">https:\/\/www.jianshu.com\/p\/54709ba140aa<\/a>&nbsp;&nbsp;<span><br><\/span><\/div><h1 title=\"vue + swiper 踩坑记实（dom7、es6）\">vue + swiper 踩坑记实（dom7、es6）<\/h1>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/10\/12 15:11:47",
"updatetime":"2020\/9\/4 15:47:36"
},
{
"id":50,
"title":"安全~issues",
"content":"<p>##XSS（Cross Site Scripting）（跨站脚本攻击），是指攻击者在网站上注入恶意代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。<\/p><p>【像论坛、博客等等一些可允许用户录入页面排版、 格式控制相关的HTML的场景，要做好xss攻击防护】&nbsp;&nbsp;<br><\/p><p>XSS分<span style=\"color: rgb(194, 79, 74);\">持久型<\/span>和<span style=\"color: rgb(194, 79, 74);\">非持久型<\/span><\/p><p>持久型就是用户输入的代码被保存在数据库，达到大范围影响的效果。<\/p><p>非持久性就是通过url参数导致，如下：<\/p><p>用jquery要小心，假设访问： http:\/\/xxx?name=&lt;script&gt;alert('attack')&lt;\/script&gt;<\/p><p>let name = getUrlParam('name')&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<\/p><p>$('#name').html(name)&nbsp; &nbsp; &nbsp; &nbsp; \/\/ 会alert 'attack'<\/p><p>用原生innerHTML,\n\ninnerText或vue的双向绑定就不会出现这问题<\/p><p><br><\/p><p>解决xss问题：根据白名单过滤HTML的库<a href=\"https:\/\/jsxss.com\/zh\/index.html\" target=\"_blank\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/jsxss.com\/zh\/index.html<\/a><\/p><ul><li>HttpOnly 防止劫取 Cookie<\/li><li>用户的输入检查【上面白名单过滤】<\/li><li>服务端的输出检查<\/li><\/ul><p><a href=\"https:\/\/segmentfault.com\/a\/1190000016551188\">https:\/\/segmentfault.com\/a\/1190000016551188<\/a>&nbsp;&nbsp;<br><\/p><p><br><\/p><p>##CSRF（跨站请求伪造） 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。&nbsp;&nbsp;<\/p><ul><li>CSRF攻击者不能获取到Cookie等信息，只是使用。<\/li><li>第一步，用户已登录，服务器返回用户凭证的cookie<\/li><li>第二步，诱导用户点击第三方网站（攻击者）的链接，第三方网站发起请求【调用登录后的网站接口】，此时会带上用户凭证cookie，以达到伪造请求搞事情<\/li><\/ul><p><br><\/p><p>解决csrf问题：1. 加验证码&nbsp; 2. 检测referer是否同域名&nbsp; 3. token&nbsp;<\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/10\/16 10:26:20",
"updatetime":"2020\/9\/7 10:16:36"
},
{
"id":51,
"title":"经典面试题",
"content":"<h2><a href=\"https:\/\/mp.weixin.qq.com\/s\/H6S7o5Df3cLRy3ztGhMMBA\" target=\"_blank\">面试指导（大揭秘！“恐怖”的阿里一面，我究竟想问什么）<\/a><br><\/h2><h2><span style=\"font-weight: bold; color: rgb(0, 0, 0); font-size: large;\">#1<\/span><\/h2><p>function Foo(){<br>&nbsp; &nbsp; &nbsp; getName = function(){console.log(1)}<br>&nbsp; &nbsp; &nbsp; return this<br>}<br>Foo.getName = function(){<br>&nbsp; &nbsp; &nbsp; console.log(2)<br>}<br>Foo.prototype.getName = function(){<br>&nbsp; &nbsp; &nbsp; console.log(3)<br>}<br>var getName = function(){<br>&nbsp; &nbsp; &nbsp; console.log(4)<br>}<br>function getName(){<br>&nbsp; &nbsp; &nbsp; console.log(5)<br>}<\/p><p>Foo.getName()<br>getName()<br>Foo().getName()<br>getName()<br>new Foo.getName()<br>new Foo().getName()<br>new new Foo().getName()<\/p><p><br><\/p><p><span style=\"color: rgb(194, 79, 74);\">\/\/就最后一道做错了，想想为什么吧~<\/span><\/p><p><br><\/p><h2><span style=\"font-weight: bold;\">#2&nbsp;<\/span><\/h2><div>let a = {a: 10};&nbsp;<\/div><div>let b = {b: 10};&nbsp;<\/div><div>let obj = {\n  a: 10\n};&nbsp;<\/div><div>obj[b] = 20;&nbsp;<\/div><div>console.log(obj[a]);&nbsp;&nbsp;<span style=\"font-weight: bold;\"><br><\/span><\/div><p><br><\/p><p><span style=\"color: rgb(194, 79, 74);\">\/\/做错了，55~&nbsp;&nbsp;<\/span><br><\/p><p><span style=\"color: rgb(194, 79, 74);\"><br><\/span><\/p><p>【对象的属性名如果是对象的话，那么默认情况会自动将对象转为字符串】<\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/10\/17 14:36:03",
"updatetime":"2020\/3\/12 14:20:06"
},
{
"id":52,
"title":"git",
"content":"<p>线上练习git指令&nbsp;&nbsp;<a href=\"https:\/\/learngitbranching.js.org\/?NODEMO=&amp;locale=zh_CN\">https:\/\/learngitbranching.js.org\/?NODEMO=&amp;locale=zh_CN<\/a>&nbsp;&nbsp;<br><\/p><p>#git与svn的区别<br>git是分布式版本管理系统，svn是集中式<br>分支管理是git的设计核心，亦是超越svn重要的一点<br>git永远工作在一个分支上，基于分支创建分支，而svn创建分支就只是把项目当前状态完完整整的拷贝到新的分支目录上。<br>一定要记住 Git 的分布式特性：分支可以被发布到在远程服务器上，但是本地上的分支对于日常的工作更加重要。<br><br><br>#git<br>本地仓库=工作区（即本地文件）+版本区（.git文件）<br>版本区=暂存区（stage）+分支（master）+指针head<br><br>【克隆】<br>git clone https:\/\/github.com\/EricHug\/letsPlayGitflow.git   （默认拉master的代码）<br>git clone -b other https:\/\/github.com\/EricHug\/letsPlayGitflow.git   （拉other分支的代码）<br><br>【基本玩法】<br>git init        (建立版本区)<br>git add .      （把工作区的所有文件全部提交到版本区里面的暂存区）<br>git add .\/xxx\/xx      (提交单条到暂存区)<br>git commit -m '我是评论!'     (把暂存区的所有文件提交到仓库区，暂存区变空)<br>git remote add origin https:\/\/github.com\/EricHug\/letsPlayGitflow.git     （把本地仓库与远程仓库连接起来,注意后面一定要加上.git）<br>git pull  （把最新提交从远程仓库拉取下来，在本地合并，解决冲突，如果提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to=origin\/&lt;branch-name&gt; &lt;branch-name&gt;）(前远程分支名，后本地分支名)<br>（如果报错说refusing to merge unrelated histories说明是历史无管理的分支，可以后面加多一行解决git pull origin master --allow-unrelated-histories）<br>git branch --set-upstream-to=orgin\/master master<br>git push -u origin master     （把仓库提交到远程仓库）<br><br>【版本的回溯与前进】<br>git log （查看版本号）<br>git reset --hard 版本号<br>git reset --hard HEAD^    (恢复为上个版本，HEAD^^则是上上个版本)<br>git log  （这时被撤销的那一步没被记录，可以git reflog查看记录，这时候你可以git reset来版本穿梭了）<br>git log --graph （查看分支合并图）<br>git log --graph --pretty=oneline（查看分支合并图并且信息精简）<br><br>【撤销】<br>git checkout -- 文件或者.（第一种：在工作区改动但还没添加到暂存区的，恢复为改动前状态。第二种：在工作区改动并且已经添加到暂存区的，这时工作区无论有没有再改动，都被恢复为暂存区）<br>git reset HEAD 文件或者.  （可以把暂存区的修改撤销（unstage））<br>git reset --hard 版本号（如果已经git add 到暂存区了，想撤销就回溯版本吧。同样已经git commit 到仓库区的话，回溯回溯~）<br><br>【删除】<br>git rm 文件 （如果已经git add 到暂存区，然后工作区又把文件删除了，用git rm删除版本区的文件）<br><br>【比较】<br>git diff 文件<br><br>【创建与合并分支】<br>git branch development　（新建分支）<br>git checkout development   （切换分支）<br>git checkout -b development  （新建并切换到新分支）<br>git checkout -b development  origin\/development  （新建并切换到新分支【从远程dev分支拉取】）<br><br>git branch （查看本地所有分支）<br>* development<br>  master<\/p><p><br><\/p><p>git branch -r&nbsp;\n\n（查看远程所有分支）&nbsp;&nbsp;<\/p><p>git branch -a&nbsp; （查看本地和远程所有分支）&nbsp;&nbsp;<\/p><p><br>git branch master<br>git merge development   （合并分支）<br>git merge --no-ff development      (合并分支的时候禁用Fast forward模式（快进模式），因为这个模式会丢失分支历史信息)（【廖雪峰】：合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。）<br>git merge -m 我是评论 development     （加点评论吧） <br>git branch -d development    (删除development分支)<br>git branch -D development    （强行删除，丢弃没被合并的分支）<br>《一个开放小组共同开发一个项目，组长会创建很多分支，每一个分支可以交给一个人去开发某一个功能，一个小组共同开发而且不会相互干扰。谁的功能完成了，可以由组件合并一下完成了的分支》<br><br>【BUG分支】<br>《廖雪峰说过，工作中每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。但如果你手上有分支在工作中，你的上级要你改另外的分支的BUG。你要把现在正在工作的分支保存下来，git stash,把当前工作现场“存储”起来，等以后恢复后继续工作。当你解决BUG后，git checkout other回到自己的分支。用git stash list查看你刚刚“存放”起来的工作去哪里了。此时你要恢复工作》<br>git stash （存储当前工作区的东西）<br>git stash apply   （恢复却不删除stash内容）<br>git stash drop    （删除stash内容）<br>git stash pop     （恢复的同时把stash内容也删了）<br>git stash list    （查看stash内容，但如果被删了就看不到）<br><br>git stash apply stash@{0}   （恢复指定的stash，后面值可以从stash list获取）<br><br>【远程协作】<br>git remote  （查看远程库的信息）<br>git remote -v（显示更详细的信息）<br>git push -u origin master          （推送master分支到origin）<br>git push -u origin development     （推送development分支到origin）<br><br>【创建标签】<br>git tag v1.0              （默认给最新提交的commit打标签）<br>git tag v0.9  版本号      （给指定的commit打上标签号）<br>git tag v0.8  版本号 <br>git tag -d v1.0           （删除标签）<br>git tag                   （查看所有标签）<br><br>【rebase】<\/p><p>git merge和git rebase的区别<\/p><p>都是把一个分支的更改合并到另外一个分支<\/p><p>git merge会把要合并的分支和你当前的 commit 合并在一起，形成一个新的 commit 提交&nbsp;&nbsp;<br><\/p><p>git rebase    （把分叉的提交历史\"整理\"成一条直线，看上去更整洁，可读性更高，缺点是本地的分叉提交已经被修改过了。最后在进行git push -u origin master，rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。）<\/p><p><a href=\"https:\/\/www.jianshu.com\/p\/6960811ac89c\">https:\/\/www.jianshu.com\/p\/6960811ac89c<\/a>&nbsp;&nbsp;<\/p><p><br><br>【注意混淆】<br>我们注意到切换分支使用git checkout &lt;branch&gt;，而前面讲过的撤销修改则是git checkout -- &lt;file&gt;，同一个命令，有两种作用，确实有点令人迷惑。新版本的git提供了git switch命令来切换分支。<br>在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。（记得先cherry-pick后stash pop）<br><br><br><br>#git退出vim模式<br>长按esc+两次Z<br><br><br>#git flow<br>一种分支模型，有两个主分支和其他功能分支<br>主分支：<br>master（存放生产的代码）<br>development（存放最新开发的，可集成功能的代码）<br><br>其他功能分支：<br>feature（基于development，用于新功能的开发）<br>release（基于development，用于发布新的功能，用于发布新的功能, 稳定运行一段时间后合并到master分支, 作为最终的发布）<br>hotfix（基于master，用于修复bug）<\/p><p>#好文章<br><a href=\"https:\/\/juejin.im\/post\/5d157bf3f265da1bcc1954e6\" target=\"_blank\">https:\/\/juejin.im\/post\/5d157bf3f265da1bcc1954e6<\/a><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/11\/6 09:33:15",
"updatetime":"2020\/5\/18 22:10:18"
},
{
"id":53,
"title":"webpack构建极限优化~",
"content":"<h2><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">目标：减少打包体积，提高打包速度<\/span><\/h2><p><a href=\"https:\/\/mp.weixin.qq.com\/s\/hN2yTtFLyFBWmOrKF-E8lQ\">https:\/\/mp.weixin.qq.com\/s\/hN2yTtFLyFBWmOrKF-E8lQ<\/a>&nbsp;&nbsp;<br><\/p><p>##vue项目webpack优化<br>##速度优化策略<br>1.使用webpack4【更新的稳定版本】<\/p><p>2.\n<span style=\"color: rgb(194, 79, 74);\">按需加载<\/span>，优化页面首次加载体积。如根据路由按需加载，根据是否可见按需加载【利用webpack的()=&gt;import()】<br>2.多进程构建(Happypack——将 loader 由单进程转为多进程)<\/p><p>3.<span style=\"color: rgb(194, 79, 74);\">分包<\/span>&nbsp;&nbsp;\n\n根据模块更改频率分层次打包，充分利用缓存&nbsp;&nbsp;<br>4.<span style=\"color: rgb(194, 79, 74);\">缓存<\/span>（提升二次构件速度）<br>5.缩小loader的转译范围【用 include 或 exclude 来帮我们避免不必要的转译】<\/p><p><br>##vue.config.js<br>1.使用webpack-bundle-analyzer对项目模块分析生成report,查看哪个模块体积过大，然后针对性优化，例如项目中引用了常见的element-ui和echarts等<br>2.配置webpack的externals，以减小打包后chunk的体积。<br>externals:{<br>&nbsp; &nbsp; &nbsp; 'vue-router': 'VueRouter',<br>&nbsp; &nbsp; &nbsp; 'vuex':'Vuex',<br>&nbsp; &nbsp; &nbsp; 'element-ui': 'Element',<br>&nbsp; &nbsp; &nbsp; 'v-charts': 'VCharts'<br>}<br>3.在index.html中添加相关库的cdn引用（最后用自己公司域名下的哟~）<br>4.loader范围缩小到src项目文件，例如：rules中loader添加：`include: path.resolve(__dirname, 'src')` <br>5.eslint不检测或者缩小检测范围【用eslint的好处，不但规范化了代码，还提升代码质量，例如import _ from 'lodash' 没用的话webpack还是照常打包进去，eslint可以规避这种低级错误】<br>6.开启gzip压缩，需要服务端配合，例如在nginx配置压缩或node，java上设置<\/p><p>webpack要先gzip压缩资源，因为响应返回的是gzip文件<\/p><pre><code>const CompressionWebpackPlugin = require('compression-webpack-plugin');\nplugins.push(\n    new CompressionWebpackPlugin({\n        asset: '[path].gz[query]',\/\/ 目标文件名\n        algorithm: 'gzip',\/\/ 使用gzip压缩\n        test: new RegExp(\n            '.(js|css)$' \/\/ 压缩 js 与 css\n        ),\n        threshold: 10240,\/\/ 资源文件大于10240B=10kB时会被压缩\n        minRatio: 0.8 \/\/ 最小压缩比达到0.8时才会被压缩\n    })\n);<\/code><\/pre><p>7.happypack多进程进行(运行在node环境的webpack默认是单线程，happypack可以把文件解析任务分解为多个子进程并发执行，子进程处理完任务后再把结果发送给主进程。大大提升webpack的构建速度)<br>  \/\/首先下载插件  npm install --save-dev happypack<br>  \/\/修改 webpack.base.conf.js<br>  const HappyPack = require('happypack')<br>  const os = require('os')<br>  let happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });<br>  \/\/加入此插件【开启缓存将转译结果缓存至文件系统】<\/p><p>  plugins:[<br>&nbsp; &nbsp; &nbsp; &nbsp;new HappyPack({<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;id:'babel',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;loaders:['babel-loader?<span style=\"color: rgb(194, 79, 74);\">cacheDirectory=true<\/span>'],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;threadPool:happyThreadPool<br>&nbsp; &nbsp; &nbsp; &nbsp; })<br>  ],<br>  \/\/将js loader作用代码替换<br>  \/\/ loader: 'babel-loader'    替换成下方loader<br>  loader: 'happypack\/loader?id=babel',<br>8.DllPlugin<span style=\"color: rgb(194, 79, 74);\">【解决包越大速度越慢的问题】<\/span><br>（在引入一些第三方模块时，例如Vue、React等，这些框架的文件一般都是不会修改的，而每次打包都需要去解析他们，也会影响打包速度，就算是做了拆分，也只是提高了上线后的用户访问速度，并不会提高构建速度，所以如果需要提高构建速度，应该使用动态链接库的方式，类似windows的dll文件借助DLLPlugin插件实现将这些框架作为一个个的动态链接库，只构建一次，以后的每次构建都只会生成自己的业务代码，可以很好的提高构建效率。思想在于，讲一些不做修改的依赖文件，提前打包，这样我们开发代码发布的时候就不需要再对这些代码进行打包，从而节省了打包时间，主要使用两个插件: DLLPlugin和DLLReferencePlugin需要注意的是，若是使用的DLLPlugin，CleanWebpackPlugin插件会存在冲突，需要移除CleanWebpackPlugin插件.  <br>https:\/\/juejin.im\/post\/5d897e3cf265da03c721e230）<\/p><h3 id=\"oqlzqb\">当前网上流行的 Webpack Dll 方案<\/h3><ul lake-indent=\"0\"><li><p>1.需要单独写一份 dll 的 webpack 配置文件【webpack.dll.config.js】<\/p><\/li><\/ul><ul lake-indent=\"0\"><li><p>2.需要手动先编译 webpack打包出dll和动态链接库<\/p><\/li><\/ul><ul lake-indent=\"0\"><li><p>3.需要在另一份页面 webpack 配置文件中引用动态链接库<\/p><\/li><\/ul><ul lake-indent=\"0\"><li><p>4.编译好dll manifest 文件后，再编译页面构建<\/p><\/li><\/ul><ul lake-indent=\"0\"><li><p>5.构建的 dll.js 文件 和 页面构建生产的 js 文件 手动引入到html<\/p><\/li><\/ul><ul lake-indent=\"0\"><li><p>6.dll 配置变更时，需要手动再次重新执行 1 和 4 步骤<\/p><\/li><\/ul><p>推荐用easywebpack配置dll，已有内置支持，减少繁琐操作&nbsp;<a href=\"https:\/\/www.yuque.com\/easy-team\/easywebpack\/dll\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/www.yuque.com\/easy-team\/easywebpack\/dll<\/a><\/p><p><br><\/p><p>9.缓存（使用HardSourceWebpackPlugin或者cache-loader）<br>#比DLL更优秀的插件（听说webpak5会自带。。）<br>const HardSourceWebpackPlugin = require('hard-source-webpack-plugin');<br>module.exports = {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;plugins: [<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;new HardSourceWebpackPlugin()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ]<br>}<br><br>10.图片压缩<br>基于Node库的imagemin或者tinypng API<br><br>##webpack4<br>#自带优化<br>tree-shaking<br><br>##webpack3 vs webpack4 <br>公共资源分离:<br>[v3]CommonsChunkPlugin<br>[v4]splitChunksPlugin<\/p><p><br><\/p><div><h5><span style=\"color: rgb(28, 72, 127);\">对于 <code>CommonsChunkPlugin<\/code>，webpack 每次打包实际还是需要去处理这些第三方库，只是打包完之后，能把第三方库和我们自己的代码分开。而 <code>DLLPlugin<\/code> 则是能把第三方代码完全分离开，即每次只打包项目自身的代码。Dll这个概念是借鉴了Windows系统的dll，一个dll包，就是一个纯纯的依赖库，它本身不能运行，是用来给你的app引用的。<\/span><\/h5><\/div><p><br><\/p><p>[v3]UglifyJsPlugin压缩过程对碎片化的冗余代码（如 console 语句、注释等）进行自动化删除：<br>[v4]已经默认使用UglifyJsPlugin对代码压缩了<\/p><p><br><\/p><p>掘金：<a href=\"https:\/\/juejin.im\/post\/5c3c544c6fb9a049d37f5903\" target=\"_blank\">https:\/\/juejin.im\/post\/5c3c544c6fb9a049d37f5903<\/a><br>webpack打包极限优化:&nbsp;<a href=\"https:\/\/www.cnblogs.com\/wanghao123\/p\/10550325.html\" target=\"_blank\">https:\/\/www.cnblogs.com\/wanghao123\/p\/10550325.html<\/a><\/p><h5><span style=\"font-weight: normal;\">Webpack性能优化总结大全<\/span><\/h5><p><a href=\"https:\/\/mp.weixin.qq.com\/s?__biz=MzI0MzIyMDM5Ng==&amp;mid=2649825759&amp;idx=1&amp;sn=726279d3dfc2ea0b6ba34788517753ad&amp;chksm=f175eb1cc602620a66821baedcb2663e393f7ae4857e8daf6d57e4c436f9a7297a555d0e4750&amp;scene=21#wechat_redirect\">https:\/\/mp.weixin.qq.com\/s?__biz=MzI0MzIyMDM5Ng==&amp;mid=2649825759&amp;idx=1&amp;sn=726279d3dfc2ea0b6ba34788517753ad&amp;chksm=f175eb1cc602620a66821baedcb2663e393f7ae4857e8daf6d57e4c436f9a7297a555d0e4750&amp;scene=21#wechat_redirect<\/a>&nbsp;&nbsp;<br><br><\/p><h5><span style=\"font-weight: normal;\">如何更好地优化打包资源&nbsp;<\/span><a href=\"https:\/\/mp.weixin.qq.com\/s\/H-w4LtY3qVNAQLiyGFsEaA\" style=\"font-size: 12px; background-color: rgb(255, 255, 255);\">https:\/\/mp.weixin.qq.com\/s\/H-w4LtY3qVNAQLiyGFsEaA<\/a><\/h5><p><br><\/p><h4><strong>easywebpack<\/strong><strong style=\"font-size: 12px;\">基于 Webpack 的前端构建工程化解决方案<\/strong><\/h4><p><\/p><p><a href=\"https:\/\/www.yuque.com\/easy-team\/easywebpack\/home\">https:\/\/www.yuque.com\/easy-team\/easywebpack\/home<\/a>&nbsp;&nbsp;<br><a href=\"https:\/\/easyjs.cn\/egg-vue\/\">https:\/\/easyjs.cn\/egg-vue\/<\/a>&nbsp;&nbsp;<br><br><br><br>vuecli3的常见webpack配置<\/p><div><code>const path = require(<\/code><code>\"path\"<\/code><code>);<\/code><\/div><div><code>const UglifyJsPlugin = require(<\/code><code>'uglifyjs-webpack-plugin'<\/code><code>);<\/code><\/div><div>&nbsp;<\/div><div><code>const isProduction = process.env.NODE_ENV === <\/code><code>'production'<\/code><code>;<\/code><\/div><div><code>const cdn = {<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>css: [],<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>js: [<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>'<a href=\"https:\/\/cdn.bootcss.com\/vue\/2.5.17\/vue.runtime.min.js\">https:\/\/cdn.bootcss.com\/vue\/2.5.17\/vue.runtime.min.js<\/a>'<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>'<a href=\"https:\/\/cdn.bootcss.com\/vue-router\/3.0.1\/vue-router.min.js\">https:\/\/cdn.bootcss.com\/vue-router\/3.0.1\/vue-router.min.js<\/a>'<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>'<a href=\"https:\/\/cdn.bootcss.com\/vuex\/3.0.1\/vuex.min.js\">https:\/\/cdn.bootcss.com\/vuex\/3.0.1\/vuex.min.js<\/a>'<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>'<a href=\"https:\/\/cdn.bootcss.com\/axios\/0.18.0\/axios.min.js\">https:\/\/cdn.bootcss.com\/axios\/0.18.0\/axios.min.js<\/a>'<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>]<\/code><\/div><div><code>}<\/code><\/div><div>&nbsp;<\/div><div><code>function<\/code> <code>resolve(dir) {<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>return<\/code> <code>path.join(__dirname, dir)<\/code><\/div><div><code>}<\/code><\/div><div>&nbsp;<\/div><div><code>module.exports = {<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>\/\/ 基本路径<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>baseUrl: <\/code><code>'.\/'<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>\/\/ 输出文件目录<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>outputDir: <\/code><code>'dist'<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>\/\/ 放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>\/\/ assetsDir: \".\/\",<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>\/\/ 指定生成的 index.html 的输出路径 (相对于 outputDir)。也可以是一个绝对路径<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>indexPath: <\/code><code>'.\/'<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>\/\/ eslint-loader 是否在保存的时候检查<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>lintOnSave: <\/code><code>true<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>\/\/ webpack配置<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>\/\/ see <a href=\"https:\/\/github.com\/vuejs\/vue-cli\/blob\/dev\/docs\/webpack.md\">https:\/\/github.com\/vuejs\/vue-cli\/blob\/dev\/docs\/webpack.md<\/a><\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>chainWebpack: config =&gt; {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>config<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>.entry(<\/code><code>'index'<\/code><code>)<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>.add(<\/code><code>'babel-polyfill'<\/code><code>)<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>.end();<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>\/\/ 配置别名<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>config.resolve.alias<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>.set(<\/code><code>\"@\"<\/code><code>, resolve(<\/code><code>\"src\"<\/code><code>))<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>.set(<\/code><code>\"@img\"<\/code><code>, resolve(<\/code><code>\"src\/assets\/images\"<\/code><code>))<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>.set(<\/code><code>\"@css\"<\/code><code>, resolve(<\/code><code>\"src\/assets\/styles\/css\"<\/code><code>))<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>.set(<\/code><code>\"@scss\"<\/code><code>, resolve(<\/code><code>\"src\/assets\/styles\/scss\"<\/code><code>));<\/code><\/div><div><div><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp;============压缩图片&nbsp;start============<\/span><\/div><div><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<\/span><span>config<\/span><span>.<\/span><span>module<\/span><\/div><div><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.<\/span><span>rule<\/span><span>(<\/span><span>'images'<\/span><span>)<\/span><\/div><div><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.<\/span><span>use<\/span><span>(<\/span><span>'image-webpack-loader'<\/span><span>)<\/span><\/div><div><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.<\/span><span>loader<\/span><span>(<\/span><span>'image-webpack-loader'<\/span><span>)<\/span><\/div><div><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.<\/span><span>options<\/span><span>({<\/span><\/div><div><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<\/span><span>bypassOnDebug<\/span><span>:<\/span><span>&nbsp;<\/span><span>true<\/span><\/div><div><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; })<\/span><\/div><div><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.<\/span><span>end<\/span><span>()<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>&nbsp; &nbsp;&nbsp;<\/span><span>\/\/&nbsp;============压缩图片&nbsp;end============<\/span><\/div><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>\/\/ 生产环境配置<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>if<\/code> <code>(isProduction) {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>\/\/ 删除预加载<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>config.plugins.<\/code><code>delete<\/code><code>(<\/code><code>'preload'<\/code><code>);<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>config.plugins.<\/code><code>delete<\/code><code>(<\/code><code>'prefetch'<\/code><code>);<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>\/\/ 压缩代码<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>config.optimization.minimize(<\/code><code>true<\/code><code>);<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>\/\/ 分割代码<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>config.optimization.splitChunks({<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>chunks: <\/code><code>'all'<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>})<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>\/\/ 生产环境注入cdn<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>config.plugin(<\/code><code>'html'<\/code><code>)<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>.tap(args =&gt; {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>args[0].cdn = cdn;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>return<\/code> <code>args;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>});<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>}<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>},<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>configureWebpack: config =&gt; {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>if<\/code> <code>(isProduction) {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>\/\/ 用cdn方式引入<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>config.externals = {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>'vue'<\/code><code>: <\/code><code>'Vue'<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>'vuex'<\/code><code>: <\/code><code>'Vuex'<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>'vue-router'<\/code><code>: <\/code><code>'VueRouter'<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>'axios'<\/code><code>: <\/code><code>'axios'<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>}<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>\/\/ 为生产环境修改配置...<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>config.plugins.push(<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>\/\/生产环境自动删除console<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>new<\/code> <code>UglifyJsPlugin({<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>uglifyOptions: {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>compress: {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>warnings: <\/code><code>false<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>drop_debugger: <\/code><code>true<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>drop_console: <\/code><code>true<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>},<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>},<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>sourceMap: <\/code><code>false<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>parallel: <\/code><code>true<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>})<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>);<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>} <\/code><code>else<\/code> <code>{<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>\/\/ 为开发环境修改配置...<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>}<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>},<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>\/\/ 生产环境是否生成 sourceMap 文件<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>productionSourceMap: <\/code><code>false<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>\/\/ css相关配置<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>css: {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>\/\/ 是否使用css分离插件 ExtractTextPlugin<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>extract: <\/code><code>true<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>\/\/ 开启 CSS source maps?<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>sourceMap: <\/code><code>false<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>\/\/ css预设器配置项<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>loaderOptions: {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>\/\/ pass options to sass-loader<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>sass: {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>\/\/ 引入全局变量样式<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>data: `<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>@import \"@\/stylePath\/theme.scss;<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>`<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>}<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>},<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>\/\/ 启用 CSS modules for all css \/ pre-processor files.<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>modules: <\/code><code>false<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>},<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>\/\/ use thread-loader for babel &amp; TS in production build<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>\/\/ enabled by default if the machine has more than 1 cores<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>parallel: require(<\/code><code>'os'<\/code><code>).cpus().length &gt; 1,<\/code><\/div><div><code>&nbsp;&nbsp;<\/code><code>devServer: {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>port: 8888, <\/code><code>\/\/ 端口<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>open: <\/code><code>true<\/code><code>, <\/code><code>\/\/ 自动开启浏览器<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>compress: <\/code><code>false<\/code><code>, <\/code><code>\/\/ 开启压缩<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>overlay: {<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>warnings: <\/code><code>true<\/code><code>,<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>errors: <\/code><code>true<\/code><\/div><div><code>&nbsp;&nbsp;&nbsp;&nbsp;<\/code><code>},<\/code><\/div><div><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ 写接口<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; before(app)&nbsp;{<\/p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; app.get('\/api\/test',&nbsp;(req,&nbsp;res)&nbsp;=&gt;&nbsp;{<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res.json({<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name:&nbsp;'eric'<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;})<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;})<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<\/div><\/divcourier><\/div><div><code>&nbsp;&nbsp;<\/code><code>},<\/code><\/div><div><code>}<\/code><\/div><p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/11\/6 14:34:09",
"updatetime":"2020\/4\/15 09:39:51"
},
{
"id":54,
"title":"易错js整理",
"content":"<h3><code>['1', '2', '3'].map(parseInt)<\/code>&nbsp;what &amp; why ?<\/h3><pre>parseInt(\"10\");\t       \/\/10   第二个参数默认为0，和10一样效果，以10进制计算<\/pre><pre>parseInt(\"11\",2);      \/\/返回 3 (2+1)\nparseInt(\"17\",8);      \/\/返回 15 (8+7)<\/pre><p>parseInt('1',0)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">\/\/1<\/span><\/p><p>parseInt('2',1)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\/\/ NaN<\/p><p>parseInt('3',2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\/\/ NaN&nbsp;<\/p><p><br><\/p><p><br><\/p><h2><span style=\"font-weight: bold;\">##0<\/span><\/h2><p>#1<\/p><pre>var b = 10;\n(function b(){\n    b = 20;\n    console.log(b); \n})();<\/pre><p>【1.函数声明比变量声明优先&nbsp; &nbsp;2.IIFE立即执行函数变量不可修改】<\/p><p><br><\/p><p>#2<\/p><p>var a = ?<br>if( a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 ) {<br>&nbsp; &nbsp; &nbsp; &nbsp; console.log(1);<br>}<\/p><p><br><\/p><p>how to add code here to console 1 in below code.<br>if( a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3 ) {<br>&nbsp; &nbsp; &nbsp; &nbsp; console.log(1);<br>}&nbsp;&nbsp;<br><\/p><p><br><\/p><p>#3<\/p><p>let a = 0&nbsp;<\/p><p>let b = async () =&gt; {\n  a = a + await 10;&nbsp; &nbsp;console.log('2', a); }<\/p><p>b()<\/p><p>a++&nbsp;<\/p><p>console.log('1', a)<br><\/p><p>【对于以上代码你可能会有疑惑，让我来解释下原因<br>首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来<br>因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码<br>同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10<br>】<\/p><p><br><\/p><p>#4 tell me why?<\/p><div><p>Function.prototype.a = 'a';<br>Object.prototype.b = 'b';<br>function Person(){};<br>var p = new Person();<br>console.log('p.a: '+ p.a);&nbsp;<br>console.log('p.b: '+ p.b);<\/p><p><br><\/p><p>#Object.assign会影响原对象<\/p><p>Object.assign(this.list[i],{<\/p><p>&nbsp; &nbsp; status:4, statusName:'已取消'<\/p><p>})<br><\/p><\/div><p><br><\/p><p><\/p><h2><span style=\"font-weight: bold;\">##1<\/span><\/h2>var p1 = new Promise((resolve,reject)=&gt;{<br>       foo.bar()<br>       resolve(1)<br>})<br>p1.then(res=&gt;{<br>       console.log('p1 then value:'+res)<br>},err=&gt;{<br>       console.log('p1 then err:'+err)<br>}).then(res=&gt;{<br>       console.log('p1 then then value:'+res)<br>},err=&gt;{<br>       console.log('p1 then then err:'+err)<br>})<br><br>var p2 = new Promise((resolve,reject)=&gt;{<br>       resolve(2)<br>})<br>p2.then(res=&gt;{<br>       console.log('p2 then value:'+res)<br>       foo.bar()<br>},err=&gt;{<br>       console.log('p2 then err:'+err)<br>}).then(res=&gt;{<br>       console.log('p2 then then value:'+res)<br>},err=&gt;{<br>       console.log('p2 then then err:'+err)<br>       return 1<br>}).then(res=&gt;{<br>       console.log('p2 then then then value:'+res)<br>},err=&gt;{<br>       console.log('p2 then then then err:'+err)<br>})<br><br>#console<br>p1 then err: ReferenceError: foo is not defined<br>p2 then value: 2<br>p1 then then value: undefined<br>p2 then then err: ReferenceError: foo is not defined<br>p2 then then then value: 1<br><br><br><br>##2<br>var p1 = Promise.resolve(1);<br>var p2 = Promise.resolve(p1);<br>console.log(p1 === p2)      \/\/ true<br><br>Promise.resolve(...)可以接收一个值或者一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数。当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2<br><br><br>##3<br>var p1 = new Promise(function(resolve, reject){<br>  resolve(Promise.resolve('resolve'));<br>});<br><br>var p2 = new Promise(function(resolve, reject){<br>  resolve(Promise.reject('reject'));<br>});<br><br>var p3 = new Promise(function(resolve, reject){<br>  reject(Promise.resolve('resolve'));<br>});<br><br>p1.then(<br>  function fulfilled(value){<br>    console.log('fulfilled: ' + value);<br>  }, <br>  function rejected(err){<br>    console.log('rejected: ' + err);<br>  }<br>);<br><br>p2.then(<br>  function fulfilled(value){<br>    console.log('fulfilled: ' + value);<br>  }, <br>  function rejected(err){<br>    console.log('rejected: ' + err);<br>  }<br>);<br><br>p3.then(<br>  function fulfilled(value){<br>    console.log('fulfilled: ' + value);<br>  }, <br>  function rejected(err){<br>    console.log('rejected: ' + err);<br>  }<br>);<br><br><br><br><br><br>##防抖<br>let debounce = (func,time=500)=&gt;{<br>     let timer = null<br>     return function(){<br>           if(timer){clearTimeout(timer)}<br>           timer = setTimeout(func,time)<br>     }()<br>}<br>let touch = ()=&gt;{console.log(1)}<br>document.getElementById('test').onclick = debounce(touch,300)   \/\/ 300ms后出现1【因为返回的函数自执行了，所以绑定上去就会执行了，不用等点击才触发】<br>【正确的方式：返回的函数不要加自执行（）】<br>let debounce = (func,time=500)=&gt;{<br>     let timer = null<br>     return function(){<br>           if(timer){clearTimeout(timer)}<br>           timer = setTimeout(func,time)<br>     }<br>}<br>let touch = ()=&gt;{console.log(1)}<br>【错误：】<br>document.getElementById('test').onclick = function(){<br>     debounce(touch,300)          <br>}\/\/这样防抖就没效果咯【每次都是调用新的debounce】<br>【正确姿势：】<br>document.getElementById('test').onclick = debounce(touch,300)<br>【考虑到参数哟，最好方式是先把防抖函数赋值给ajax】<br>let touch = e=&gt;{console.log(e)}<br>let ajax = debounce(touch,300)<br>document.getElementById('test').onclick = function(){<br>     ajax(2)         \/\/ 2<br>}      <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><p><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/11\/21 14:35:50",
"updatetime":"2020\/3\/18 10:58:52"
},
{
"id":55,
"title":"日常高级写法积累",
"content":"<h3><span style=\"font-weight: bold; font-size: large;\">#reduce<\/span><\/h3><p>reduce本身没有break，但你可以用if来灵活代替<\/p><p>例子：<\/p><pre>var numbers = [1,2,3,4,5,6,7,8,9];\nvar result = numbers.reduce(function(a, b, index, arr) {\n  if(index &gt;= 3) arr.splice(1);     \/\/ reduce()的处理就断了\n  return a + b;\n});\nconsole.log(result);<\/pre><p><br><\/p><h3><span style=\"font-weight: bold;\">#symbol<\/span><\/h3><div><pre><code>let obj = {\n   [Symbol('name')]: '一斤代码',\n   age: 18,\n   title: 'Engineer'\n}<\/code><\/pre><\/div><div>用for...in或Object.keys等遍历不出symbol值，所以利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。例如：不提交的写做symbol，利用JSON.parse(JSON.stringify(obj))过滤<\/div><p><span style=\"color: rgb(194, 79, 74);\">筛选出所有symbol值：<\/span>Object.getOwnPropertySymbols(obj)<\/p><p><span style=\"color: rgb(194, 79, 74);\">筛选出所有值(包含symbol)：<\/span>Reflect.ownKeys(obj)&nbsp;&nbsp;<\/p><p><br><\/p><div><h3><span style=\"font-weight: bold;\">#ES5写一个数组去重<\/span><\/h3><\/div><div><span style=\"font-weight: bold;\">1.const uniqueArr = arr =&gt; arr.filter((item,index,arr)=&gt;arr.indexOf(item) === index)<\/span><\/div><div><span style=\"font-weight: bold;\">2.const uniqueArr = arr =&gt; arr.reduce((prev,item,index)=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(prev.indexOf(item)&lt;0){prev.push(item)}<\/span><\/div><div><span style=\"font-weight: bold;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return prev<\/span><\/div><div><span style=\"font-weight: bold;\">},[])<\/span><\/div><div><span style=\"font-weight: bold;\"><br><\/span><\/div><div><h3>#js字符串转为函数<\/h3><\/div><p>let func = `with(this){return aha(1)}`<\/p><p>function aha(e){console.log(e)}<\/p><p>let realFunc = new Function(func)<\/p><p>realFunc()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; &nbsp; &nbsp;1&nbsp;<br><\/p><p><br><\/p><p>with(obj){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp;console.log(a)<\/p><p>}<\/p><p>等同于<\/p><p>console.log(obj.a)<\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/2\/17 10:52:50",
"updatetime":"2020\/5\/11 10:39:54"
},
{
"id":56,
"title":"代码检查工具",
"content":"<p>ESLint + Prettier&nbsp;&nbsp;<br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/2\/20 10:06:03",
"updatetime":"2020\/2\/20 10:06:03"
},
{
"id":57,
"title":"egg项目笔记",
"content":"<p>egg-bin dev<\/p><p>egg-bin debug开启调试模式需要vscode设置setting.json<\/p><div><span>{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>\"debug.node.autoAttach\"<\/span><span>:&nbsp;<\/span><span>\"on\"<\/span><span>,<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>}<\/span><\/div><div><h3><strong>easywebpack:<\/strong><strong style=\"font-size: 12px;\">基于&nbsp;<\/strong><a href=\"https:\/\/www.yuque.com\/easy-team\/easywebpack\/home\" target=\"_blank\" style=\"font-size: 12px; background-color: rgb(255, 255, 255);\">Webpack 的前端构建工程化解决方案<\/a><\/h3><\/div>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/2\/29 20:25:29",
"updatetime":"2020\/3\/2 17:37:13"
},
{
"id":58,
"title":"HTTP&&SEO",
"content":"<h4><span style=\"font-weight: bold;\">#URL从输入到页面渲染全流程&nbsp;&nbsp;<\/span><\/h4><div><a href=\"https:\/\/segmentfault.com\/a\/1190000021000934\">https:\/\/segmentfault.com\/a\/1190000021000934<\/a>&nbsp;&nbsp;<span style=\"font-weight: bold;\"><br><\/span><\/div><div><div>浏览器解析-&gt;查询缓存-&gt;dns查询-&gt;建立链接-&gt;服务器处理请求-&gt;服务器发送响应-&gt;客户端收到页面-&gt;解析HTML-&gt;构建渲染树-&gt;开始显示内容(白屏时间)-&gt;首屏内容加载完成(首屏时间)-&gt;用户可交互(DOMContentLoaded)-&gt;加载完成(load)<\/div><br><\/div><h4>#URL从输入到页面渲染全流程&nbsp;&nbsp;<\/h4><p><a href=\"https:\/\/www.aiheart.top\/eblog\/#\/blog\/detail\/63?type=1\">https:\/\/www.aiheart.top\/eblog\/#\/blog\/detail\/63?type=1<\/a>&nbsp;&nbsp;<br><\/p><p><span style=\"font-weight: bold;\">#渲染原理<\/span><\/p><p>浏览器把html解析为dom树，把css解析为css树，js操作会阻塞dom树，解析完成后，浏览器会通过已经解析好的dom树 和 css规则树来构造渲染树，有了渲染树，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。<\/p><p><span style=\"font-weight: bold;\">【<\/span><strong>回流必将引起重绘，重绘不一定会引起回流。<\/strong><span style=\"font-weight: bold;\">】<\/span><\/p><p><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">回流<\/span> 当渲染树中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。&nbsp;&nbsp;<\/p><p><strong style=\"color: rgb(194, 79, 74);\">重绘<\/strong>&nbsp;当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code style=\"font-size: 12px;\">color<\/code>、<code style=\"font-size: 12px;\">background-color<\/code>、<code style=\"font-size: 12px;\">visibility<\/code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。<br><\/p><p><a href=\"https:\/\/juejin.im\/post\/5a9923e9518825558251c96a\">https:\/\/juejin.im\/post\/5a9923e9518825558251c96a<\/a>&nbsp;&nbsp;<br><\/p><p><span style=\"font-weight: bold;\"><br><\/span><\/p><h4>#HTTP1.0、HTTP1.1 和 HTTP2.0 的区别<\/h4><p><span style=\"font-weight: bold; color: rgb(70, 172, 200);\">1.1是持久化连接<\/span>。在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： <span style=\"color: rgb(194, 79, 74);\">keep-alive<\/span>，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。1.0是短连接，TCP连线在每一次请求\/回应对之后关闭。<\/p><p><span style=\"color: rgb(70, 172, 200); font-weight: bold;\">1.1添加了一些缓存机制处理<\/span>。在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如cache-control，Etag等更多可供选择的缓存头来控制缓存策略。<\/p><p><span style=\"color: rgb(70, 172, 200); font-weight: bold;\">1.1管线化技术<\/span>。管线化技术是在持久化连接的基础上，进一步对通信性能的提升。在持久化连接下，请求和相应是顺次进行的。上次请求得到响应后，才能发送下次请求。<strong>管线化技术就是指能在未收到响应时，顺次发送多个请求。<\/strong><\/p><p><span style=\"color: rgb(70, 172, 200); font-weight: bold;\">2.0多路复用<\/span>。在 HTTP\/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。 HTTP\/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP\/2 连接发起多重的请求-响应消息。因此 HTTP\/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP\/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。<\/p><div><div><span style=\"font-weight: bold;\"><span style=\"color: rgb(70, 172, 200);\">2.0header压缩<\/span>。<\/span>如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。<\/div><\/div><p><span style=\"color: rgb(70, 172, 200); font-weight: bold;\">2.0二进制分帧&nbsp;&nbsp;<\/span>HTTP2所有性能增强的核心在于<b>新的二进制分帧层<\/b>(不再以<span style=\"font-weight: bold;\">文本格式<\/span>来传输了)，它定义了如何封装http消息并在客户端与服务器之间传输。<\/p><p><span style=\"color: rgb(70, 172, 200);\"><span style=\"font-weight: bold;\">2.0服务器推送<\/span>&nbsp;&nbsp;<\/span>服务端可以主动推送资源给客户端，避免客户端花过多的时间逐个请求资源，这样可以降低整个请求的响应时间。<\/p><p>Node.js从 v8.4.0版本开始支持HTTP\/2&nbsp;<\/p><p><img src=\"https:\/\/user-gold-cdn.xitu.io\/2018\/10\/18\/16684c501ec9c769?imageslim\" style=\"max-width:100%;\"><br><\/p><p><br><\/p><section powered-by=\"xiumi.us\"><section><section><section><section powered-by=\"xiumi.us\"><section><section><section powered-by=\"xiumi.us\"><section><section><h4>#HTTPS与HTTP的一些区别<\/h4><\/section><\/section><\/section><\/section><\/section><\/section><\/section><\/section><\/section><\/section><section powered-by=\"xiumi.us\"><section><section><ul><li><p>HTTPS本质就是HTTP+SSL【使用SSL对HTTP报文进行加密】<\/p><\/li><li><p>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。&nbsp;&nbsp;<br><\/p><\/li><li><p>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL\/TLS之上，SSL\/TLS运行在TCP之上，所有传输的内容都经过加密的。<\/p><\/li><li><p>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<\/p><\/li><li><p>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。<\/p><\/li><\/ul><\/section><\/section><\/section><p>&nbsp;<span style=\"font-weight: bold; color: rgb(70, 172, 200);\"><br><\/span><\/p><p>HTTP拷问<a href=\"https:\/\/juejin.im\/post\/5e76bd516fb9a07cce750746\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/juejin.im\/post\/5e76bd516fb9a07cce750746<\/a><\/p><p><br><\/p><h4>#GET和POST的区别<\/h4><p>get的参数通过url拼接的方法传输，post是带在请求体上，所以post安全性更高<\/p><p>get请求参数有长度限制，而post没有限制<\/p><p>get只接受ASCII字符，而post没有限制&nbsp;&nbsp;<br><\/p><p>get会被浏览器主动缓存，post不会，除非主动配置<\/p><p>get产生一个TCP数据包，而post产生两个TCP数据包（长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。）【<strong>注意一点，并不是所有的浏览器都会发送两次数据包，Firefox就发送一次<\/strong>】<\/p><p><br><\/p><p><br><\/p><h4><span style=\"font-weight: bold;\">#SEO<\/span><\/h4><div>SEO(Search Engine Optimization)，即搜索引擎优化。SEO的存在就是为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。而优化的目的就是为了提升网站在搜索引擎中的权重，增加对搜索引擎的友好度，使得用户在访问网站时能排在前面。&nbsp;&nbsp;<\/div><p>前端能做的事：<\/p><p>（1）突出重要内容---合理的设计title、description和keywords&nbsp;<\/p><p>（2）语义化书写HTML代码，符合W3C标准&nbsp;<br><\/p><p>（3）&lt;img&gt;应使用 \"alt\" 属性加以说明&nbsp;&nbsp;<br><\/p><p>（4）重要内容不要用JS输出，因为“蜘蛛”不会读取JS里的内容，所以重要内容必须放在HTML里。&nbsp;&nbsp;<br><\/p><p>（5）尽量少使用iframe框架,因为“蜘蛛”一般不会读取其中的内容。&nbsp;&nbsp;<br><\/p><p><br><\/p><h4>#客户端渲染和服务端渲染的区别<\/h4><p>CSR和SSR最大的区别在于前者的页面渲染是JS负责进行的，而后者是服务器端直接返回HTML让浏览器直接渲染。&nbsp;<\/p><div><h6>传统CSR的弊端：<\/h6>\n<ul>\n<li>由于页面显示过程要进行JS文件拉取和React代码执行，<span style=\"color: rgb(70, 172, 200);\">首屏加载时间会比较慢<\/span>。<\/li>\n<li>对于SEO(Search Engine Optimazition,即搜索引擎优化)，完全无能为力，因为<span style=\"color: rgb(70, 172, 200);\">搜索引擎爬虫只认识html结构的内容，而不能识别JS代码内容<\/span>。<\/li>\n<\/ul>\n<p>SSR的出现，就是为了解决这些传统CSR的弊端。<\/p><p>浏览器端渲染相较于服务器端渲染的好处在于，<span style=\"color: rgb(70, 172, 200);\">浏览器端渲染可以减少服务器端的压力<\/span>。在用户访问服务器的时候，服务器只需要提供数据，数据的解析有每个用户上的浏览器执行；即使访问的用户非常多，服务器的压力也不会非常大。而如果在服务器端渲染，服务器除了提供数据外，还需要创建好html结构；这样下来，服务器端的压力就会相对来说 比较大。<\/p><div><br><\/div><\/div>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/3\/11 16:01:05",
"updatetime":"2020\/4\/8 09:22:39"
},
{
"id":59,
"title":"Vue&React的各种实现原理",
"content":"<p><a href=\"https:\/\/www.aiheart.top\/eblog\/#\/blog\/detail\/33?type=\" target=\"_blank\">框架的对比+MVVM定义<\/a><br><\/p><h3><span style=\"font-weight: bold;\">#vue的nextTick实现原理以及应用场景<\/span><\/h3><div><span style=\"font-weight: bold;\"><br><\/span><\/div><div><h4><span style=\"font-weight: normal;\">让我们回到上面的主题，Vue 的 nextTick方法，\n从 <a target=\"_blank\" href=\"https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/util\/next-tick.js\" rel=\"nofollow noopener noreferrer\">源码<\/a>  不难发现，Vue 在内部尝试对异步队列使用原生的<\/span>Pr<code>omise.then，<\/code>MutationObserver【微任务】和<code style=\"font-size: 12px;\">setImmediate【宏任务，性能比<\/code>setTimeout好<code style=\"font-size: 12px;\">】<\/code><span style=\"font-weight: normal;\">，如果当前执行环境不支持，就采用<\/span><code style=\"font-size: 12px; font-weight: normal;\">setTimeout(fn, 0)<\/code><span style=\"font-weight: normal;\">代替。<\/span><\/h4><\/div><div>应用场景：dom操作放进去。【将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。 】&nbsp;<\/div><p><br><\/p><h3>#vue和react状态管理区别<\/h3><p><span style=\"color: rgb(77, 128, 191);\">状态管理就是，<strong>把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测<\/strong>。&nbsp;<\/span>&nbsp;<br><\/p><p>vue：vuex&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; react: redux mobx<\/p><p>1.vuex和redux都是基于flux，单向数据流，只有一个store，mobx可以多个store<\/p><p>2.redux支持使用中间件，而且不单只应用与react项目，也可以用在vue，vuex只能用在vue<\/p><p><span style=\"color: rgb(194, 79, 74);\">vuex：&nbsp;<\/span>View 通过&nbsp;<code style=\"font-size: 12px;\">store.dispatch()<\/code>&nbsp;调用 Action ，在 Action 执行完异步操作之后通过&nbsp;<code style=\"font-size: 12px;\">store.commit()<\/code>&nbsp;调用 Mutation 更新 State ，通过 vue 的响应式机制进行视图更新<\/p><p><span style=\"color: rgb(194, 79, 74);\">redux：<\/span>View 发出 Action (<code style=\"font-size: 12px;\">store.dispatch(action)<\/code>)，Store 调用 Reducer根据 action 计算出新的 state ，若 state 产生变化，则调用监听函数重新渲染 View （<code style=\"font-size: 12px;\">store.subscribe(render)<\/code>）&nbsp;&nbsp;<\/p><p><br><\/p><p><br><\/p><h2><span style=\"font-weight: bold; color: rgb(238, 236, 224); background-color: rgb(194, 79, 74);\">Vue<\/span><\/h2><div><p>##keep-alive<br>场景有：在长列表进去详情后，再返回还是之前浏览的位置<br>当组件在 &lt;keep-alive&gt; 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。<br>这两个钩子处于beforeUpdate和updated之间<br>激活后：beforeUpdate   activated    updated<br>停用后：beforeUpdate   deactivated    updated<br><br>question:怎么删除动态缓存的缓存组件，因为一旦组件缓存，就没法进组件的新页面。<br><br>#:key<br>当 Vue 正在更新使用 v-for 渲染的元素列表时，没有key的情况下，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动DOM元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。【index作为key，和不带key的效果是一样的。】<br>https:\/\/cn.vuejs.org\/v2\/guide\/list.html#%E7%BB%B4%E6%8A%A4%E7%8A%B6%E6%80%81<br><br>建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。【所以说，在遍历输出DOM内容简单的情况下，不带key更为高效的复用节点，因为带key在增删节点上有耗时。】<br><br>key是Vue识别节点的一个标志，运用vue的虚拟DOM算法，有用key的话会对比新旧虚拟node节点，数据顺序改变的时候vue会移动DOM元素来匹配数据项的顺序，并且会移除 key不存在的元素。节省性能开销。<br>https:\/\/cn.vuejs.org\/v2\/api\/#key<br><br>key还有其他应用场景：<br>1.完整地触发组件的生命周期钩子<br>2.触发过渡<br>&lt;transition&gt;<br>  &lt;span :key=\"text\"&gt;{{ text }}&lt;\/span&gt;<br>&lt;\/transition&gt;<br>当 text 发生改变时，&lt;span&gt; 会随时被更新，因此会触发过渡。<\/p><\/div><p><br><\/p><h3>#你了解哪些Vue性能优化方法？<\/h3><p>1.路由按需加载<\/p><p>const router = new VueRouter({\n  routes: [\n    { path: '\/foo', component: () =&gt; <span style=\"font-weight: bold;\">import<\/span>('.\/Foo.vue') }\n  ]\n})&nbsp;<\/p><p>2.keep-alive缓存页面<br><\/p><p>3.频繁切换的元素用v-show不用v-if<\/p><p>4.v-for 遍历避免同时使用 v-if<\/p><p>5.长列表性能优化&nbsp; Object.freeze(users)<\/p><p>6.事件的销毁&nbsp;&nbsp;<\/p><p>created() {\n  this.timer = setInterval(this.refresh, 2000)\n},\nbeforeDestroy() {\n  clearInterval(this.timer)\n}&nbsp;<\/p><p>7.图片懒加载&nbsp;<a target=\"_blank\" href=\"https:\/\/github.com\/hilongjw\/vue-lazyload\" rel=\"nofollow noopener noreferrer\" style=\"background-color: rgb(255, 255, 255);\">vue-lazyload<\/a><\/p><p>8.用Map表代替大量的if-else和switch会提升性能<\/p><p>9.脚手架采用runtime-only的vue版本，节省运行时编译损耗<\/p><p><br><\/p><h3>#v-for和v-if不能连用<\/h3><p>如果v-if的判断条件不是取决于v-for的数组属性，那可以直接在外面加个template v-if<\/p><p>如果v-if的判断条件取决于v-for遍历的属性，那可以用计算属性过滤掉数组得到的新数组再v-for<\/p><p><br><\/p><h3>#你对Vue3.0的新特性有没有了解？<\/h3><p>1.更快，基于Proxy的响应式系统<\/p><p>2.更小：通过摇树优化核心库体积<\/p><p>3.更容易维护：TypeScript + 模块化<\/p><p>&nbsp;<\/p><h3>#vue的computed和watch有啥区别<\/h3><div><div><p>computed 计算属性 : 依赖其它属性值,并且 computed 的值<span style=\"font-weight: bold;\">有缓存<\/span>,只有它依赖的属性值发生改变,下一次获取 computed 的值时才会重新计算 computed 的值。【<span style=\"font-weight: bold;\">不支持异步<\/span>】<\/p>\n<p>watch 侦听器 : 更多的是「观察」的作用,<strong>无缓存性<\/strong>,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作。【<span style=\"font-weight: bold;\">支持异步<\/span>】<\/p><\/div><\/div><p><br><\/p><h3>#vue有哪些组件传递方式<\/h3><p>1.父子组件&nbsp; &nbsp;props：父传子，子通过emit事件触发父监听执行相应函数<\/p><p>2.兄弟或跨级&nbsp; &nbsp;event-bus：在一个组件this.$emit('add',参数)&nbsp; &nbsp; 在另外一个组件create时this.$on('add',参数=&gt;{&nbsp; &nbsp; ...&nbsp; &nbsp; })<\/p><p>3.vuex 你懂的，单向数据流<\/p><p>4.provide\/reject (vue2.2.0+)&nbsp;<\/p><p>&nbsp; &nbsp;父组件: provide:{&nbsp; name:'eric'&nbsp; }&nbsp; &nbsp; &nbsp; 子孙组件:&nbsp; reject:['name'],&nbsp; data(){&nbsp; return{&nbsp; &nbsp;userName: this.name&nbsp; &nbsp; }&nbsp; }<\/p><p>Vue 不会对 provide 中的变量进行响应式处理。所以，要想 inject 接受的变量是响应式的，provide 提供的变量本身就需要是响应式的&nbsp;&nbsp;<br><\/p><p>5.ref\/refs&nbsp; &nbsp;【<code style=\"font-size: 12px;\">ref<\/code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据】<\/p><p>6.$attrs\/$listeners【深组件的通信】&nbsp;&nbsp;<a href=\"https:\/\/juejin.im\/post\/5ae4288a5188256712784787\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/juejin.im\/post\/5ae4288a5188256712784787<\/a>&nbsp;&nbsp;<\/p><p>7.$parent\/$children<\/p><p><br><\/p><h3>#vue父子组件<\/h3><p><span style=\"color: rgb(194, 79, 74);\">【1111代表子组件】&nbsp;&nbsp;<\/span><br><\/p><h3>加载渲染过程<\/h3><p>beforeCreate<br>created<br>beforeMount 【调用render方法】&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>beforeCreate <span style=\"color: rgb(194, 79, 74);\">1111<\/span><br>created <span style=\"color: rgb(194, 79, 74);\">1111<\/span><br>beforeMount <span style=\"color: rgb(194, 79, 74);\">1111<\/span><br>mounted <span style=\"color: rgb(194, 79, 74);\">1111<\/span><br>mounted<\/p><h3>父组件更新数据过程<\/h3><p>beforeUpdate<br>updated<\/p><h3>子组件更新数据过程<\/h3><p>beforeUpdate&nbsp;&nbsp;\n\n<span style=\"color: rgb(194, 79, 74);\">1111&nbsp;&nbsp;<\/span><br>updated&nbsp; <span style=\"color: rgb(194, 79, 74);\">1111<\/span><\/p><h3>父组件更新数据且影响子组件过程<\/h3><p>beforeUpdate<\/p><p>beforeUpdate&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(194, 79, 74);\">1111<\/span>&nbsp;&nbsp;<br>updated&nbsp;&nbsp;<span style=\"color: rgb(194, 79, 74);\">1111&nbsp;&nbsp;<\/span><br>updated<\/p><p><span style=\"font-weight: bold;\">父组件销毁过程<\/span><\/p><p>beforeDestroy&nbsp;&nbsp;<br><\/p><p>beforeDestroy&nbsp; &nbsp;<span style=\"color: rgb(194, 79, 74);\">1111&nbsp;&nbsp;<\/span><br>destroyed&nbsp;<span style=\"color: rgb(194, 79, 74);\"> 1111&nbsp;&nbsp;<\/span><br>destroyed&nbsp;&nbsp;<br><\/p><p><span style=\"color: rgb(194, 79, 74);\"><br><\/span><\/p><h3>#vue强制组件重新渲染<\/h3><ul><li>1.简单粗暴的方式：重新加载整个页面<\/li><li>2.不妥的方式：使用&nbsp;<code>v-if<\/code><\/li><li>3.较好的方法：使用Vue的内置<code>forceUpdate<\/code>方法【强制调用beforeUpdate updated生命周期】<\/li><li>4.最好的方法：在组件上进行&nbsp;<code>key<\/code>&nbsp;更改<\/li><li><h3>父组件数据设置为子组件的key，数据改变过程<\/h3><p>beforeUpdate&nbsp;&nbsp;<br><\/p><p><span style=\"color: rgb(77, 128, 191);\">beforeCreate&nbsp; &nbsp; 1111<br>created&nbsp; &nbsp; 1111&nbsp;&nbsp;<br>beforeMount&nbsp; &nbsp; 1111&nbsp;&nbsp;<br>beforeDestroy&nbsp; &nbsp;1111&nbsp;&nbsp;<br>destroyed&nbsp; &nbsp;1111&nbsp;&nbsp;&nbsp;&nbsp;<br>updated&nbsp;&nbsp;1111&nbsp;&nbsp;<br>mounted&nbsp; 1111&nbsp;&nbsp;&nbsp;<\/span>&nbsp;<br>updated<\/p><\/li><\/ul><p><br><\/p><h3><span style=\"font-weight: bold;\">#Vue组件data选项为什么必须是个函数而Vue的根实例则没有此限制？<\/span><\/h3><div>在一个项目中，组件可以有多个，每一个组件均可当作一个构造器，注册组件的本质其实就是构造器的引用。如果直接使用对象，他们的内存地址是一样的，一个数据改变了其他也改变了，这就造成了数据污染，如果使用函数的话，会形成一个全新的作用域，这样data中的数据不会相互影响，从而避免数据污染。但由于根实例只有一个，所以不存在数据污染这种情况，也就可以使用对象了。&nbsp;&nbsp;<span style=\"font-weight: bold;\"><br><\/span><\/div><p><br><\/p><h3><span style=\"font-weight: bold;\">#vue生命周期<\/span><\/h3><div><span>\/\/&nbsp;实例化初始化后，在数据检测和event\/watcher事件配置之前被调用<\/span><\/div><div><span>beforeCreate<\/span><span>()&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'beforeCreate'<\/span><span>)<\/span><\/div><div><span>},<\/span><\/div><div><span>\/\/&nbsp;实例创建后被调用，在这一步，实例已经完成以下的配置：数据检测（data&nbsp;observer）【所以可以访问到this.data】，属性和方法的运算，watch\/event事件回调<\/span><\/div><div><span>\/\/&nbsp;然而挂载还没开始，所以$el不可见<\/span><\/div><div><span>created<\/span><span>()&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'created'<\/span><span>)<\/span><\/div><div><span>},<\/span><\/div><div><span>\/\/&nbsp;挂载前被调用，相关的渲染函数首次被调用<\/span><\/div><div><span>\/\/&nbsp;查找是否要挂载的el元素选项，没有的话停止下一步操作，等待手动调用$mount('#app')<\/span><\/div><div><span>\/\/&nbsp;有没有template模板选项，没有的话将el的外部html作为template编译，有的话将template编译成render函数<\/span><\/div><div><span>beforeMount<\/span><span>()&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'beforeMount'<\/span><span>)<\/span><\/div><div><span>},<\/span><\/div><div><span>\/\/&nbsp;el被新创建的vm.$el替换，挂载成功<\/span><\/div><div><span>mounted<\/span><span>()&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'mounted'<\/span><span>)<\/span><\/div><div><span>},<\/span><\/div><div><span>\/\/&nbsp;数据更新视图前调用【这时你获取this.data是更新后的，但dom还没更新】<\/span><\/div><div><span>beforeUpdate<\/span><span>()&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'beforeUpdate'<\/span><span>)<\/span><\/div><div><span>},<\/span><\/div><div><span>\/\/&nbsp;数据更新视图后调用【dom已更新】<\/span><\/div><div><span>updated<\/span><span>()&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'updated'<\/span><span>)<\/span><\/div><div><span>},<\/span><\/div><div><span>\/\/&nbsp;实例销毁之前调用。在这一步，实例仍然完全可用。<\/span><\/div><div><span>beforeDestroy<\/span><span>()&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'beforeDestroy'<\/span><span>)<\/span><\/div><div><span>},<\/span><\/div><div><span>\/\/&nbsp;实例销毁后调用。该钩子被调用后，对应&nbsp;Vue&nbsp;实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。<\/span><\/div><div><span>destroyed<\/span><span>()&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'destroyed'<\/span><span>)<\/span><\/div><div><span>},<\/span><\/div><div><span>\/\/&nbsp;被keep-alive缓存的组件停用时调用。<\/span><\/div><div><span>deactivated<\/span><span>()&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'deactivated'<\/span><span>)<\/span><\/div><div><span>},<\/span><\/div><div><span>\/\/&nbsp;被keep-alive缓存的组件激活时调用。<\/span><\/div><div><span>activated<\/span><span>()&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>'activated'<\/span><span>)<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>},<\/span><\/div><p><br><\/p><h3>#vue的render原理<\/h3><p><img src=\"https:\/\/user-gold-cdn.xitu.io\/2019\/5\/13\/16ab18cb48ac83cb?imageslim\" style=\"max-width:100%;\"><br><\/p><p>Vue的编译器在编译模板之后，会把这些模板编译成一个渲染函数。而函数被调用的时候就会渲染并且返回一个<b>虚拟DOM的树<\/b>。 当我们有了这个虚拟的树之后，再交给一个<b>Patch函数<\/b>，通过diff对比新旧虚拟DOM用最少的代价真正施加到真实的DOM改动上。&nbsp;<\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/3\/12 10:19:49",
"updatetime":"2020\/5\/19 17:19:56"
},
{
"id":60,
"title":"面面面",
"content":"<p>1.要想好自我介绍【和职位的匹配度，做过什么牛X的项目，有多难，如何攻克，收获什么，甚至这个项目做完，该项目对团队、部门甚至公司而言，带来哪方面的提高。】<br>2.vue源码<br>3.es6原理<br>4.<span style=\"color: rgb(194, 79, 74);\">性能优化和工程化调优<\/span><\/p><p>5.<span style=\"color: rgb(194, 79, 74);\">浏览器渲染原理<br><\/span>6.熟透项目<br><br><\/p><h2 id=\"activity-name\">满分回答教你如何应对面试中项目经验这一难关<\/h2><p>https:\/\/mp.weixin.qq.com\/s\/yTpp95JxGnz233dx11rTcA<\/p><p><a href=\"https:\/\/juejin.im\/post\/5e5309ece51d4526e03f9e53\">https:\/\/juejin.im\/post\/5e5309ece51d4526e03f9e53<\/a>&nbsp;&nbsp;<br><\/p><p><br>浏览器内核有哪些？渲染原理有了解吗<br>http协议1.0与1.1与2.0区别<br>es6常用哪些<br>用es5实现promise的难点<br>移动适配除了rem还有哪些方案<br>css预处理器的优势和劣势<br>垂直居中的各种方案<br>ERP项目实现什么功能<br>客户端渲染和服务端渲染区别<br>seo优化前端能做什么<br>性能优化，前端可以从哪些方面入手<br>改变this指向有哪些方式<br>多了解项目业务<br>node了解多少？看哪些书<br>识别数据结构有哪些<br><\/p><p><br><\/p><p>别人家的博客【<a href=\"https:\/\/www.muyiy.cn\/\" style=\"background-color: rgb(255, 255, 255);\">木易杨前端进阶<\/a>】<a href=\"https:\/\/www.muyiy.cn\/blog\/\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/www.muyiy.cn\/blog\/<\/a>。<\/p><p><br><\/p><p><span style=\"font-weight: bold;\">有啥问我的？【豪横 = =】<\/span><\/p><p>技术团队规模？如果被luyong了，接下来进去要做什么？进去之后的晋升机制是怎样的？会经常有技术交流的活动么？&nbsp;&nbsp;<br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/3\/17 15:25:20",
"updatetime":"2020\/4\/17 17:50:04"
},
{
"id":61,
"title":"es6扩展",
"content":"<p><span style=\"font-weight: bold;\">1：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？&nbsp;<\/span>&nbsp;<br><\/p><p>Set<br>一种叫<span style=\"color: rgb(194, 79, 74);\">集合<\/span>的数据结构，类似于数组，成员都是<span style=\"color: rgb(194, 79, 74);\">唯一,无序且不重复<\/span><\/p><p>可以遍历，方法有：add、delete、has<br>WeakSet<br>成员只能是对象引用，而且是<span style=\"color: rgb(194, 79, 74);\">弱引用<\/span>，可以被垃圾回收机制回收，<span style=\"color: rgb(194, 79, 74);\">不容易造成内存泄漏<\/span><br><span style=\"color: rgb(194, 79, 74);\">不能遍历<\/span>，方法有add、delete、has，<span style=\"color: rgb(194, 79, 74);\">没有size和clear<\/span><br>Map<br>一种叫做字典的数据结构，本质上是键值对的集合，类似对象<br>可以遍历，方法很多可以跟各种数据格式转换<br>WeakMap<br>只接受对象作为键名（null除外），不接受其他类型的值作为键名<br>键名是<span style=\"color: rgb(194, 79, 74);\">弱引用<\/span>，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的<br><span style=\"color: rgb(194, 79, 74);\">不能遍历<\/span>，方法有get、set、has、delete，<span style=\"color: rgb(194, 79, 74);\">没有size和clear<\/span><\/p><p><a href=\"https:\/\/www.jianshu.com\/p\/c99dd69a8f2c\" target=\"_blank\">通过JavaScript垃圾回收机制来理解WeakSet\/WeakMap中对象的弱引用<\/a><span style=\"color: rgb(194, 79, 74);\"><br><\/span><\/p><div><div><p>那么什么情况下会用到这样的数据结构呢？<\/p>\n<p>当我们对对象有个主存储区，当且仅当对象激活（在内存）时才需要保存信息就会用到，不会造成内存泄漏。<\/p>\n<p>比如：记录用户的访问次数、给DOM注册监听事件、部署私有属性等。<\/p><\/div><pre><code><p>#记录用户的访问次数<\/p>let jack = { name: \"jack\" };\nconst vistedCount = new WeakMap();\nvistedCount.set(jack, 123);\n\n\/\/ 当 jack 离开，就不需要保存其访问记录\njohn = null;\n\n\/\/ 除了 vistedCount 没有其他引用了\n\/\/ 所以这个对象会自动的从内存和 vistedCount 中删除，不会造成内存泄漏<\/code><\/pre><pre><code><p>#注册监听事件：<\/p>const listener = new WeakMap()\n\nlistener\n  .set(ele1, func1)\n  .set(ele2, func2)\n\nele1.addEventListener('click', listener.get(ele1), false)\nele2.addEventListener('click', listener.get(ele2), false)\n<p>监听函数放在WeakMap中，一旦DOM移除，监听函数也随之从内存移除，不会造成内存泄漏。<\/p>\n<\/code><\/pre><\/div><p><br><\/p><p><span style=\"font-weight: bold;\">2.垃圾回收机制<\/span><\/p><p>在 JavaScript引擎中有一个被称作垃圾回收器的东西在后台执行。它监控着所有对象的状态，并删除掉那些已经不可达的，释放掉内存。<br><\/p><p><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/3\/18 10:46:15",
"updatetime":"2020\/4\/17 15:09:43"
},
{
"id":62,
"title":"Vue&React的各种高级玩法",
"content":"<h3><a href=\"https:\/\/juejin.im\/post\/5c106485e51d450e657571a6\" target=\"_blank\">加快Vue项目的开发速度<\/a>&nbsp;&nbsp;<span style=\"font-weight: bold;\"><br><\/span><\/h3><h3><span style=\"font-weight: bold;\">#插槽玩法<\/span><\/h3><div>\/\/ 父组件<span style=\"font-weight: bold;\"><br><\/span><\/div><div><span>&lt;<\/span><span>HelloWorld<\/span>&gt;<\/div><div>&nbsp; &nbsp; &nbsp; HelloWorld<\/div><p>&nbsp; &nbsp;<span style=\"color: rgb(194, 79, 74);\"> <\/span><span style=\"color: rgb(77, 128, 191);\">&nbsp;\/\/ vue 2.6之前写法<\/span><\/p><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;<\/span><span>template<\/span><span>&nbsp;<\/span><span style=\"color: rgb(194, 79, 74);\"><span>slot<\/span><span>=<\/span><span>\"footer\"<\/span><span>&nbsp;<\/span><span>slot-scope<\/span><span>=<\/span><span>\"slotProp\"<\/span><\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;<\/span><span>p<\/span><span>&gt;<\/span><span>i&nbsp;am&nbsp;<\/span>\n\nfooter:<span>{{<\/span><span>slotProp<\/span><span>.<\/span>foot<span>}}<\/span><span>&lt;\/<\/span><span>p<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;\/<\/span><span>template<\/span><span>&gt;<\/span><\/div><div>&nbsp; &nbsp; <span style=\"color: rgb(77, 128, 191);\">&nbsp;\/\/ vue 2.6+写法&nbsp;&nbsp;<\/span><br><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;<\/span><span>template<\/span><span>&nbsp;<\/span><span style=\"color: rgb(194, 79, 74);\"><span>v-slot:footer=\"<\/span>slotProp\"<\/span>&gt;<\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;<\/span><span>p<\/span><span>&gt;<\/span><span>i&nbsp;am&nbsp;footer:{{<\/span>slotProp.foot}}&lt;\/p&gt;<\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;\/<\/span><span>template<\/span><span>&gt;<\/span><\/div><div><div>&nbsp; &nbsp; &nbsp;<span style=\"color: rgb(77, 128, 191);\">\/\/ 或者&nbsp;<\/span><br><\/div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;template&nbsp;<span style=\"color: rgb(194, 79, 74);\">v-slot:footer=\"{foot}\"<\/span>&gt;<\/div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;i&nbsp;am&nbsp;footer:{{foot}}&lt;\/p&gt;<\/div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;\/template&gt;<\/div><\/div><div>&nbsp; &nbsp; &nbsp;<span style=\"color: rgb(77, 128, 191);\">\/\/ 还可以再简写<\/span><br><\/div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;template<span style=\"color: rgb(194, 79, 74);\">&nbsp;#footer=\"{foot}\"<\/span>&gt;<\/div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;i&nbsp;am&nbsp;footer:{{foot}}&lt;\/p&gt;<\/div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;\/template&gt;<\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>&lt;\/<\/span><span>HelloWorld<\/span><span>&gt;<\/span><\/div><div>\/\/ 子组件HelloWorld<span><br><\/span><\/div><div><span>&lt;<\/span><span>div<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;<\/span><span>header<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;<\/span><span>slot<\/span><span>&nbsp;<\/span><span>name<\/span><span>=<\/span><span>\"header\"<\/span><span>&nbsp;:<\/span>head<span>=<\/span><span>\"<\/span><span>headName<\/span><span>\"<\/span><span>&gt;&lt;\/<\/span><span>slot<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;\/<\/span><span>header<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;<\/span><span>main<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;<\/span><span>slot<\/span><span>&gt;&lt;\/<\/span><span>slot<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;\/<\/span><span>main<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;<\/span><span>footer<\/span><span>&gt;<\/span><\/div><div><span>&nbsp; &nbsp; &nbsp; &nbsp;<\/span><span>&lt;<\/span><span>slot<\/span><span>&nbsp;<\/span><span>name<\/span><span>=<\/span><span>\"footer\"<\/span>&nbsp;:foot=\"footName\"&gt;&lt;\/slot&gt;<\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;\/<\/span><span>footer<\/span><span>&gt;<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>&nbsp;&nbsp;<\/span><span>&lt;\/<\/span><span>div<\/span><span>&gt;<\/span><\/div><div><span>data(){<\/span><\/div><div><span>&nbsp; &nbsp; &nbsp; &nbsp;return{&nbsp; &nbsp;<\/span>headName:'xxxx',&nbsp; &nbsp; footName:'xxxxx'&nbsp; &nbsp; }<\/div><div><span>}<\/span><\/div><div><span><br><\/span><\/div><div><span style=\"font-weight: bold;\">#$attrs+$listeners<\/span><\/div><div><a href=\"https:\/\/juejin.im\/post\/5ae4288a5188256712784787\">https:\/\/juejin.im\/post\/5ae4288a5188256712784787<\/a>&nbsp;&nbsp;<span><br><\/span><\/div><div><span><br><\/span><\/div>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/3\/27 16:23:55",
"updatetime":"2020\/5\/19 17:06:52"
},
{
"id":63,
"title":"#URL从输入到页面渲染全流程  ",
"content":"<p><a href=\"https:\/\/juejin.im\/post\/5cc573c85188252e741ccbb6\">https:\/\/juejin.im\/post\/5cc573c85188252e741ccbb6<\/a>&nbsp;&nbsp;<br><\/p><p>总体来说一个完整的流程分为以下几部分:<\/p><ol><li><p><span style=\"font-weight: bold;\">DNS解析域名<\/span><\/p><\/li><li><p><span style=\"font-weight: bold;\">建立TCP连接，三次握手<\/span><\/p><\/li><li><p><span style=\"font-weight: bold;\">发送HTTP请求<\/span><\/p><\/li><li><p><span style=\"font-weight: bold;\">服务器处理请求并返回HTTP报文<\/span><\/p><\/li><li><p><span style=\"font-weight: bold;\">关闭TCP连接，四次挥手<\/span><\/p><\/li><li><p><span style=\"font-weight: bold;\">浏览器解析渲染页面<\/span><\/p><\/li><\/ol><p><br><\/p><h2>1.域名解析<\/h2><p>当输入url按下回车后，就开始域名解析。域名解析会先读取是否有缓存：<\/p><p><a href=\"https:\/\/image-static.segmentfault.com\/161\/828\/1618288278-57f00bf9444dd_articlex\">https:\/\/image-static.segmentfault.com\/161\/828\/1618288278-57f00bf9444dd_articlex<\/a>&nbsp;&nbsp;<\/p><p>DNS( Domain Name System)是“域名系统”的英文缩写&nbsp;&nbsp;&nbsp;&nbsp;<br><\/p><p><img src=\"https:\/\/image-static.segmentfault.com\/161\/828\/1618288278-57f00bf9444dd_articlex\" style=\"max-width:100%;\"><br><\/p><ol><li><p>浏览器搜索自己的 DNS 缓存（浏览器维护一张域名与 IP 地址的对应表）；如果没有命中，进入下一步；<\/p><\/li><li><p>搜索操作系统中的 DNS 缓存；如果没有命中，进入下一步；<\/p><\/li><li><p>搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；如果没有命中，进入下一步；<\/p><ol><li><h5>操作系统将域名发送至 LDNS （<span style=\"color: rgb(194, 79, 74);\">本地域名服务器<\/span>），LDNS 查询自己的 DNS 缓存（一般命中率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求：<br>LDNS向 Root Name Server（<span style=\"color: rgb(194, 79, 74);\">根域名服务器<\/span>，如com、net、im 等的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 im 域的顶级域名服务器的地址；<br>LDNS 向com 域的<span style=\"color: rgb(194, 79, 74);\">顶级域名服务器<\/span>发起请求，返回&nbsp;\n\ngoogle.com <span style=\"color: rgb(194, 79, 74);\">权威域名服务器<\/span>地址；<\/h5><h5>LDNS 向<span style=\"color: rgb(194, 79, 74);\">google.com 权威域名服务器<\/span>发起请求，得到&nbsp;\n\ngoogle.com 的 IP 地址；<\/h5><h5>LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来。<\/h5><\/li><\/ol><\/li><\/ol><p>【从上述过程中，可以看出网址的解析是一个从右向左的过程: .【根域名服务器】 -&gt; com -&gt; google.com -&gt; www.google.com】<\/p><p>HTTP缓存中<strong>s-maxage<\/strong>（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。<strong>s-maxage的优先级高于max-age<\/strong>。如果存在s-maxage，则会覆盖掉max-age和Expires header<\/p><p><br><\/p><h2>2.TCP连接【传输层协议】<\/h2><p>首先，判断是不是https的，如果是，则HTTPS其实是HTTP + SSL \/ TLS 两部分组成，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。&nbsp;&nbsp;<br><\/p><p><img src=\"http:\/\/pics7.baidu.com\/feed\/9a504fc2d5628535aa383cf5769b01c0a5ef6381.jpeg?token=fdd0889c8bd6183296b087e3849cf57d\" style=\"max-width:100%;\"><br><\/p><p><span style=\"font-weight: bold;\">【控制位】<\/span><\/p><p>SYC：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。&nbsp;&nbsp;<span style=\"font-weight: bold;\"><br><\/span><\/p><p>ACK：该位为 1 时，「确认应答」的字段变为有效，是期望对方继续发送的那个数据包的序列号。&nbsp;<span style=\"color: rgb(194, 79, 74);\"> seq<\/span>是数据包本身的序列号<\/p><p>FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段。<\/p><p>RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。&nbsp;&nbsp;<\/p><div><figure><div><h4>三次握手<\/h4>\n<h5>第一次握手：<\/h5>\n<p>客户端发送<span style=\"color: rgb(77, 128, 191);\">syn<\/span>包(<span style=\"color: rgb(77, 128, 191);\">Seq<\/span>=x)到服务器，并进入SYN_SEND状态，等待服务器确认；<\/p>\n<h5>第二次握手：<\/h5>\n<p>服务器收到syn包，然后确认客户的SYN（ack=x+1），同时自己也发送一个<span style=\"color: rgb(77, 128, 191);\">syn<\/span>包（<span style=\"color: rgb(77, 128, 191);\">Seq<\/span>=y），即<span style=\"color: rgb(77, 128, 191);\">SYN+ACK<\/span>包，此时服务器进入SYN_RECV状态；<\/p>\n<h5>第三次握手：<\/h5>\n<p>客户端收到服务器的SYN＋ACK包，向服务器发送确认包<span style=\"color: rgb(77, 128, 191);\">ACK<\/span>(<span style=\"color: rgb(77, 128, 191);\">ack<\/span>=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<\/p>\n<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。<\/p><\/div><img src=\"https:\/\/ss0.bdstatic.com\/70cFuHSh_Q1YnxGkpoWK1HF6hhy\/it\/u=3079100011,2545297405&amp;fm=26&amp;gp=0.jpg\" style=\"max-width:100%;\"><br><\/figure><figure><div><h5>为什么会采用三次握手，若采用二次握手可以吗？ 四次呢？<\/h5>\n<p>建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。<\/p>\n<p>采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。<\/p>\n<p>采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况。而在三次握手中， client和server都有一个发syn和收ack的过程， 双方都是发后能收， 表明通信则准备工作OK.<\/p>\n<p>为什么不是四次握手呢？ 大家应该知道通信中著名的蓝军红军约定， 这个例子说明， 通信不可能100%可靠， 而上面的三次握手已经做好了通信的准备工作， 再增加握手， 并不能显著提高可靠性， 而且也没有必要。<\/p>\n<h4>四次挥手<\/h4>\n<p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，假设客户端主动关闭，服务器被动关闭。<\/p><\/div><\/figure><figure><img src=\"https:\/\/timgsa.baidu.com\/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1586857200085&amp;di=0984ce32d447080c14f761ef04aa0dbb&amp;imgtype=0&amp;src=http%3A%2F%2Fimg2.imgtn.bdimg.com%2Fit%2Fu%3D2934224852%2C1207714096%26fm%3D214%26gp%3D0.jpg\" style=\"max-width:100%;\"><br><\/figure><figure><h5>第一次挥手：<\/h5>\n<p>客户端发送一个FIN，用来关闭客户端到服务器的数据传送，<span style=\"color: rgb(194, 79, 74);\">FIN=1<\/span>，其序列号为seq=x（等于前面已经传送过来的数据的最后一个字节的序号加1）ACK为z，此时，客户端进入<span style=\"color: rgb(194, 79, 74);\">FIN-WAIT-1（终止等待1）<\/span>状态。表示主机1没有数据要发送给主机2了&nbsp; 。<\/p>\n<h5>第二次挥手：<\/h5>\n<p>服务器收到FIN包后，发送一个ACK【x+1】给对方并且带上自己的序列号seq【z】<\/p>\n<p>此时，客户端就进入<span style=\"color: rgb(194, 79, 74);\">FIN-WAIT-2（终止等待2）<\/span>状态，表示我\"同意\"你的关闭请求<\/p>\n<h5>第三次挥手：<\/h5>\n<p>服务器发送一个FIN，用来关闭服务器到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发数据了。加上ACK【x+1】seq【y】。此时，服务器就进入了<span style=\"color: rgb(194, 79, 74);\">LAST-ACK（最后确认）<\/span>状态，等待客户端的确认。<\/p>\n<h5>第四次挥手：<\/h5>\n<p>主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<\/p>\n<p>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。<\/p>\n<p>至此，完成四次挥手。<\/p>\n<h5>为什么客户端最后还要等待2MSL？<\/h5>\n<p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。<\/p>\n<h6>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。<\/h6>\n<h6>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。<\/h6>\n<h4>为什么建立连接是三次握手，关闭连接确是四次挥手呢？<\/h4>\n<p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。\n而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。<\/p><h2>35 张图解被问千百遍的 TCP 三次握手和四次挥手面试题<\/h2><p><a href=\"https:\/\/baijiahao.baidu.com\/s?id=1663133611194990028&amp;wfr=spider&amp;for=pc\">https:\/\/baijiahao.baidu.com\/s?id=1663133611194990028&amp;wfr=spider&amp;for=pc<\/a>&nbsp;&nbsp;<br><br><\/p><\/figure><\/div><p><br><\/p><h2>3.发送HTTP请求<\/h2><p>发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80\/8080, HTTPS协议443)。HTTP请求报文是由三部分组成:&nbsp;<strong>请求行<\/strong>,&nbsp;<strong>请求报头<\/strong>和<strong>请求正文<\/strong>。&nbsp;<\/p><h5><span style=\"font-weight: bold;\">请求行&nbsp;<\/span><\/h5><p>包含【请求方法，请求链接，HTTP版本等】eg: GET index.html HTTP\/1.1<\/p><h5>请求报头<\/h5><p>前端可编辑的header Content-type cookie user-agent等等<br><\/p><h5>请求正文<\/h5><p>像post请求戴的json参数数据等&nbsp;<br><\/p><p><br><\/p><h2>4.服务器处理请求并返回HTTP报文<\/h2><p>服务器接受到请求，就解析请求头，如果头部有缓存相关信息如if-none-match与if-modified-since，则验证缓存是否有效，若有效则返回状态码为304，若无效则重新返回资源，状态码为200，返回http响应报文。\n\nHTTP响应报文也是由三部分组成&nbsp; :&nbsp;<strong>状态码<\/strong>,&nbsp;<strong>响应报头<\/strong>和<strong>响应报文<\/strong>。<\/p><h5><strong>状态码<\/strong>&nbsp;&nbsp;<\/h5><p>状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:<\/p><ul><li><p>1xx：指示信息–表示请求已接收，继续处理。<\/p><\/li><li><p>2xx：成功–表示请求已被成功接收、理解、接受。<\/p><\/li><li><p>3xx：重定向–要完成请求必须进行更进一步的操作。<\/p><\/li><li><p>4xx：客户端错误–请求有语法错误或请求无法实现。<\/p><\/li><li><p>5xx：服务器端错误–服务器未能实现合法的请求。<br>平时遇到比较常见的状态码有:<span style=\"color: rgb(194, 79, 74);\">200<\/span>【请求成功】,<span style=\"color: rgb(194, 79, 74);\"> 204<\/span>【服务器成功处理了请求，但没有返回任何内容】, 301【永久重定向】, 302【临时重定向】, 304【命中协商缓存，未修改】, 400【错误请求，服务器不理解请求的语法】, 401【未授权，请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。】, 403【服务器拒绝请求】, 404【服务器找不到请求的网页】, 422【请求格式正确，但是由于含有语义错误，无法响应】, 500【服务器遇到错误，无法完成请求】<\/p><\/li><\/ul><p>TODO:<\/p><ul><li><p><span style=\"color: rgb(194, 79, 74);\">301和302有什么区别？<\/span>【<strong>301是永久重定向，而302是临时重定向<\/strong>】【301比较常用的场景是使用域名跳转。比如，我们访问&nbsp;<strong>http<\/strong>:\/\/www.baidu.com 会跳转到&nbsp;<strong>https<\/strong>:\/\/www.baidu.com，发送请求之后，就会返回301状态码，然后返回一个location，提示新的地址，浏览器就会拿着这个新的地址去访问。&nbsp;<strong>注意： 301请求是可以缓存的， 即通过看status code，可以发现后面写着from cache。<\/strong>】【<strong>302用来做临时跳转&nbsp; &nbsp;<\/strong>比如未登陆的用户访问用户中心重定向到登录页面。访问404页面会重新定向到首页。 <span style=\"font-weight: bold;\">【302重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，而301重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址。】<\/span><\/p><\/li><li><p>##niginx 301\/302配置&nbsp;<\/p><\/li><li><pre>\/\/把来自veryyoung.me的请求301跳到 www.veryyoung.me\nif ($host != 'veryyoung.me') {\n    rewrite ^\/(.*)$ http:\/\/www.veryyoung.me\/$1 permanent;&nbsp;<\/pre><p><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">}<\/span><\/p><\/li><li><p>接上redirect就代表302跳<\/p><div><pre>\/\/把来自veryyoung.me的请求302跳到 www.veryyoung.me\nif ($host != 'veryyoung.me') {\n    redirect ^\/(.*)$ http:<span style=\"font-size: 1em;\">\/\/<\/span><span style=\"font-size: 1em;\">www.veryyoung.me\/$1 redirect;<\/span><span style=\"font-size: 1em;\">&nbsp;<\/span><br><\/pre><\/div><p><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">}<\/span>】<\/p><\/li><\/ul><p><br><\/p><h5><strong>响应报头<\/strong>&nbsp;&nbsp;<br><\/h5><p>header： 像跨域CORS处理的Access-Control-Allow-Origin，gzip压缩返回的Content-Encoding:gzip，缓存的cache-control，Etag等<\/p><h5><strong>响应报文<\/strong>&nbsp;&nbsp;<br><\/h5><p>服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。&nbsp;&nbsp;<br><\/p><p><br><\/p><h2>渲染原理<\/h2><p>#进程和线程的区别<\/p><p>浏览器是多进程的，一个网页对应一个进程，相互独立。<\/p><p>一个进程有多个线程，线程之间共享资源和内存空间。多个线程在进程中协作完成任务<\/p><p><br><\/p><p>#浏览器有哪些进程<\/p><p>1. 第三方插件进程&nbsp; 2.GPU进程：最多一个，用于3D绘制等 3.浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）4.网络进程。默认每个Tab页面一个进程，互不影响。主要作用为页面渲染，脚本执行，事件处理等<\/p><p><br><\/p><p># 一个渲染进程有多个线程<\/p><p>分为：GUI渲染线程，JS引擎线程，事件线程，定时触发器线程，异步http请求线程<\/p><p><img src=\"https:\/\/user-gold-cdn.xitu.io\/2020\/1\/7\/16f7ee2d5b4df806?imageslim\"><\/p><p>#渲染流程<\/p><p>浏览器组件大体上分为网络层，渲染引擎，浏览器引擎，js解释器，UI后端层，数据存储持久层等<br><\/p><div>用户请求的HTML文本(text\/html)通过浏览器的<span style=\"font-weight: bold; color: rgb(194, 79, 74);\">网络层<\/span>到达<span style=\"color: rgb(194, 79, 74); font-weight: bold;\">渲染引擎<\/span>后，渲染工作开始&nbsp;&nbsp;<\/div><p>渲染流程有四个主要步骤：<\/p><div><div><li>1.解析HTML形成DOM树<\/li>\n<li>2.解析CSS形成CSSOM 树<\/li>\n<li>3.合并DOM树和CSSOM树形成渲染树<\/li>\n<li>4.浏览器开始渲染并绘制页面\n这个过程涉及两个比较重要的概念<strong>回流【reflow】<\/strong>和<strong>重绘【repaint】<span style=\"color: rgb(194, 79, 74);\">【<\/span><\/strong><span style=\"color: rgb(194, 79, 74);\">&nbsp;更新属性时只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘&nbsp;&nbsp;<strong>】<\/strong><\/span>，DOM结点都是以盒模型形式存在，需要浏览器去计算位置和宽度等，这个过程就是回流。等到页面的宽高，大小，颜色等属性确定下来后，浏览器开始绘制内容，这个过程叫做重绘。浏览器刚打开页面一定要经过这两个过程的，但是这个过程非常非常非常消耗性能，所以我们应该尽量减少页面的回流和重绘。<\/li><\/div><\/div><ol><li><p><span style=\"font-weight: bold;\">Tip<\/span>:没有js的理想情况下，html与css会并行解析，分别生成DOM与CSSOM，然后合并成Render Tree，进入Rendering Pipeline；但如果有js，css加载会阻塞后面js语句的执行，而（同步）<span style=\"color: rgb(194, 79, 74);\">js脚本执行会阻塞其后的DOM解析<\/span>（所以通常会把css放在头部，js放在body尾）<br><\/p><\/li><\/ol><p><span style=\"color: rgb(194, 79, 74);\">css加载不会阻塞DOM树解析，但是会阻塞DOM树渲染.&nbsp;css加载会阻塞后面js语句的执行<\/span><br><\/p><p><br><\/p><h4>【回流】<\/h4><p>当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。例如：浏览器窗口大小发生改变，尺寸位置发生变化，添加或者删除可见的DOM元素...<\/p><h4>【重绘】<\/h4><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。<\/p><p><span style=\"font-weight: bold;\">重绘不一定导致回流，回流一定会导致重绘。&nbsp;&nbsp;<\/span><br><\/p><p><span style=\"font-weight: bold;\">【减少回流重绘的优化】<\/span><\/p><ul><li>避免使用table布局。<\/li><li>将动画效果应用到position属性为absolute或fixed的元素上。<\/li><li>避免频繁操作dom，可以用文档碎片代替<\/li><\/ul><p><br><\/p><p>按照渲染的时间顺序，流水线可分为如下几个子阶段：<code>构建 DOM 树<\/code>、<code>样式计算<\/code>、<code>布局阶段<\/code>、<code>分层<\/code>、<code>栅格化<\/code>和<code>显示<\/code>。<br><\/p><ol><li><p><span style=\"font-weight: bold;\">渲染进程将 HTML 内容转换为能够读懂DOM 树结构。<\/span><\/p><\/li><li><p><span style=\"font-weight: bold;\">渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。<\/span><\/p><\/li><li><p><span style=\"font-weight: bold;\">创建布局树，并计算元素的布局信息。<\/span><\/p><\/li><li><p><span style=\"font-weight: bold;\">对布局树进行分层，并生成分层树。<\/span><\/p><\/li><li><p><span style=\"font-weight: bold;\">为每个图层生成绘制列表，并将其提交到合成线程。合成线程将<span style=\"color: rgb(194, 79, 74);\">图层<\/span>分<span style=\"color: rgb(194, 79, 74);\">图块<\/span>，并栅格化将<span style=\"color: rgb(194, 79, 74);\">图块<\/span>转换成<span style=\"color: rgb(194, 79, 74);\">位图<\/span>。<\/span><\/p><\/li><li><p><span style=\"font-weight: bold;\">合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。<\/span><\/p><\/li><\/ol><p>浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程将字节解析为DOM树,先将HTML的原始字节数据转换为文件指定编码的字符,然后浏览器会根据HTML规范来将字符串转换成各种令牌标签，如html、body等。最终解析成一个树状的对象模型，就是dom树；<\/p><p>获取css，获取style标签内的css、或者内嵌的css,或者当HTML代码遇见标签时，浏览器会发送请求获得该标签中标记的CSS，当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的styleSheets<\/p><p>创建布局树，遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。最后计算 DOM 元素的布局信息，使其都保存在布局树中。<code>布局完成过程中，如果有js操作或者其他操作，对元素的颜色，背景等作出改变就会引起重绘，如果有对元素的大小、定位等有改变则会引起回流。<\/code><\/p><p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。<\/p><p>渲染引擎实现图层的绘制，把一个图层的绘制拆分成很多小的绘制指令然后再把这些指令按照顺序组成一个待绘制列表，当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程，合成线程会将图层划分为图块，然后按照视口附近的图块来优先生成位图(实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图)<\/p><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令，然后将该命令提交给浏览器进程,浏览器最后进行显示。<\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/3\/30 17:16:15",
"updatetime":"2020\/4\/21 10:46:49"
},
{
"id":64,
"title":"vue源码分析",
"content":"<p><span style=\"font-weight: bold;\">#vue版本的runtime only和runtime+compiler的区别？<\/span><\/p><p>在我们使用vue-cli的时候，会提示你安装的版本，可以看到有两种版本： Runtime Only 版本 和 Runtime+Compiler 版本。<\/p><p>&nbsp;Runtime Only是运行不带编译的，编译是离线时候做的。需要借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript。因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更轻量。【我们默认import Vue就是runtimeOnly版本】<\/p><p>Runtime+Compiler在运行时带编译的，如果写 template 属性，则需要编译成 render 函数，这个编译过程对性能会有一定损耗。 这个版本的vue文件相比仅包含runtime的版本体积要大，而且运行时的compiler转换会消耗性能，compiler过程其实可以放到构建过程中进行。<\/p><p><br><\/p><p><span style=\"font-weight: bold;\">#执行import Vue from 'vue'的时候<\/span><\/p><p>添加原型属性和方法，对vue做大量的扩展，全局添加属性和静态方法<span style=\"font-weight: bold;\"><br><\/span><\/p><p><br><\/p><p><span style=\"font-weight: bold;\">#new Vue发生了什么？<\/span><\/p><p>调用init方法，进行一系列的初始化工作，合并配置，初始化生命周期，初始化事件中心，初始化渲染，<span style=\"color: rgb(194, 79, 74);\">调用生命周期钩子beforeCreate<\/span>，这时候获取this.data为undefined，初始化data，prop，method，watch，computed啊，<span style=\"color: rgb(194, 79, 74);\">调用生命周期钩子created<\/span>,这时候就可以拿到data了，然后如果配置里有el这个参数的话，内部就调用$mount(el)。没有的话就等外部实例调用$mount<\/p><p><span style=\"color: rgb(194, 79, 74);\">调用$mount后，<\/span>看是否有render，没有的话看是否有template，再没有的话把el转为html作为template。然后把template编译为render方法。<span style=\"color: rgb(194, 79, 74);\">调用生命周期钩子beforeMount<\/span>，接下来创建渲染watcher初始化，没有传lazy为true，会立即调用更新组件方法，这个更新方法传入调用render函数返回的vnode，内部核心是patch函数，patch函数会<span style=\"color: rgb(194, 79, 74);\">对比新旧vnode<\/span>把vnode转为真实dom。<span style=\"color: rgb(194, 79, 74);\">调用生命周期钩子mounted<\/span><\/p><p><br><\/p><p><span style=\"font-weight: bold;\">#生命周期可以做的事<\/span><br><\/p><p>created实例已经创建完成，可以ajax请求<\/p><p>mounted实例已经挂载完成，可以操作DOM<\/p><p>beforeUpdated可以在这个钩子中进一步操作状态，这不会触发附加的重新渲染<\/p><p>updated可以执行依赖于dom的操作。然而大多数情况要避免操作状态，以防无限更新循环<\/p><p>destroyed可以执行一些优化操作，清除定时器啊，解除绑定事件【eventbus的$on或原生的事件绑定】等【路由切换会销毁，会调用beforeDestroy和destroyed】<\/p><p><br><\/p><p><span style=\"font-weight: bold;\">#visual dom<\/span><\/p><p>是一个原生js对象，是对真实 DOM 的一种抽象描述。创建一个vnode比创建一个真实dom的代价小很多。<\/p><h5>引入 vdom 之后：<\/h5><ul><li><section>数据 + 模板生成虚拟&nbsp;<code>DOM<\/code><\/section><\/li><li><section>虚拟&nbsp;<code>DOM<\/code>&nbsp;生成真实&nbsp;<code>DOM<\/code><\/section><\/li><li><section>数据发生改变<\/section><\/li><li><section>新的数据 + 模板生成新的虚拟&nbsp;<code>DOM<\/code>&nbsp;而不是真实&nbsp;<code>DOM<\/code><\/section><\/li><li><section>用新的虚拟&nbsp;<code>DOM<\/code>&nbsp;和原来的虚拟&nbsp;<code>DOM<\/code>&nbsp;作对比（<code>diff<\/code>&nbsp;算法，后面会详细介绍）【性能&nbsp;<code>up↑<\/code>】<\/section><\/li><li><section>找出发生改变的元素<\/section><\/li><li><section>直接修改原来的真实&nbsp;<code>DOM<\/code>【性能&nbsp;<code>up↑<\/code>】<\/section><\/li><\/ul><div><div>JavaScript操作DOM进行重绘整个视图层是相当消耗性能的，所以Vue.js将DOM抽象成一个以JavaScript对象为节点的虚拟DOM树，以VNode节点模拟真实DOM，可以对这颗抽象树进行创建节点、删除节点以及修改节点等操作，<span style=\"color: rgb(194, 79, 74);\">在这过程中都不需要操作真实DOM，只需要操作JavaScript对象，大大提升了性能<\/span>。修改以后经过diff算法得出一些需要修改的最小单位，再将这些小单位的视图进行更新。这样做减少了很多不需要的DOM操作，大大提高了性能。<\/div><\/div><p><br><\/p><p><span style=\"font-weight: bold;\">#patch函数<\/span><\/p><p>patch的核心diff算法，diff算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有O(n)，是一种相当高效的算法。 只有两个新旧节点是相同节点的时候，才会去比较他们各自的子节点<\/p><ol><li>新的 data 进行<code>_render<\/code>操作，得到新的vnode<\/li><li>对比前后vnode，也就是patch过程<\/li><li>对于同一层级的节点，会进行<code>updateChildren<\/code>操作（diff），进行最小的变动<\/li><\/ol><p>&nbsp;<br><\/p><p><br><\/p><p><span style=\"font-weight: bold;\">#vue是怎么监测数组更新的？<\/span><\/p><p>源码中看作者重写了数组的<span style=\"color: rgb(194, 79, 74);\">7<\/span>种原型方法，当遍历监测时，如果判断是数组的话，就把改动后的原型方法指向这个数组上。当vue调用其中一个数组方法时，就会进入重写方法的逻辑中，先调用原生的数组方法获取结果，调用<span style=\"color: rgb(194, 79, 74);\">dep.notify()通知所有watcher更新数据，<\/span>&nbsp;<span style=\"color: rgb(194, 79, 74);\">如果是push，unshift，splice方法的话判断是否为对象，是的话对对象observe观察。<\/span>&nbsp; &nbsp; &nbsp; &nbsp; })】。<\/p><p><br><\/p><p><span style=\"font-weight: bold;\">#vue为什么要异步渲染?<\/span><br><\/p><p>节省性能开销，要是更改一次就更新一次，性能肯定消耗很大，所以为了性能考虑，vue是本轮数据更新后再异步更新视图。<\/p><p>当数据发生变化后，会调用dep.notify的方法通知watcher去更新，watcher会调用update方法，但它不会立即执行，而是放到叫做queueWatcher队列里面，这个queueWatcher会过滤相同的watcher，最后再放到nextTick里面异步执行。执行时会先调用生命周期钩子beforeUpdate方法，然后调用<span style=\"font-weight: bold; color: rgb(194, 79, 74);\">run<\/span>方法<span style=\"color: rgb(194, 79, 74);\">【初始渲染watcher的updateComponent，把调用render函数获取的最新vnode，转为真实】<\/span>，渲染页面完成后，调用生命周期钩子updated。<\/p><p><br><\/p><p><span style=\"font-weight: bold;\">#nextTick原理<\/span><br><\/p><p>通过调用nextTick传入回调，回调会存放到一个数组，内部有个timerFunc方法，它的作用是遍历回调函数依次执行。内部处理会把timerFunc方法尝试采用promise回调，不行的话用mutationObserver回调，再不行的用setImmediate回调，实在不行的话用setTimeout方法回调。采用这一系列降级异步回调处理。<\/p><p><br><\/p><p><br><\/p><p>#<span style=\"font-weight: bold;\">computed和watch的区别<\/span><br><\/p><p>默认computed也是一个watcher是具备缓存的，只有依赖的属性发生变化才会更新视图<\/p><p>computed的watcher默认lazy为true，所以初始化watcher时不会调用computed的函数，只有页面渲染时才调用。<\/p><p>computed的watcher默认dirty为true，dirty为true才可以调用计算函数，调完变false，直到依赖的属性变化后才变true。这就实现缓存效果了。<\/p><p>computed函数不能异步操作，否则返回undefined<\/p><p>watch是没有缓存的，内部也是watcher，监听的属性一变化就调用watcher的update属性<br><\/p><p><br><\/p><p><span style=\"font-weight: bold;\">#vue模板编译原理<br><\/span><\/p><p>template =&gt; ast抽象语法树 =&gt; render函数 =&gt; 内部调用createElement =&gt; 虚拟dom<\/p><div><div><p>模板解析这种事，本质是将数据转化为一段 html ，最开始出现在后端，经过各种处理吐给前端。随着各种 mv* 的兴起，模板解析交由前端处理。<br>\n总的来说，Vue complier 是将 template 转化成一个 render 字符串。<br>\n可以简单理解成以下步骤：<\/p>\n<ul>\n<li>parse 过程，将 template 利用正则转化成 AST 抽象语法树。<\/li>\n<li>optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。<\/li>\n<li>generate 过程，生成 render 字符串。<\/li><\/ul><\/div><\/div><p><span style=\"font-weight: bold;\"><br><\/span><\/p><p><span style=\"font-weight: bold;\">#vue加key和不加key的区别<br><\/span><\/p><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>&lt;<\/span><span>span<\/span><span> <\/span><span>v-for<\/span><span>=<\/span><span>\"<\/span><span>(<\/span><span>item<\/span><span>,<\/span><span>index<\/span><span>) <\/span><span>in<\/span><span> <\/span><span>c<\/span><span>\"<\/span><span> <\/span><span>:key<\/span><span>=<\/span><span>\"<\/span><span>item<\/span><span>.<\/span><span>id<\/span><span>\"<\/span><span>&gt;&lt;<\/span><span>input<\/span><span> <\/span><span>type<\/span><span>=<\/span><span>\"checkbox\"<\/span><span>&gt;<\/span><span>{{<\/span><span>item<\/span><span>.<\/span><span>text<\/span><span>}}<\/span><span>&lt;\/<\/span><span>span<\/span><span>&gt;<\/span><\/div><div><span>c:<\/span><span>[<\/span>{id:1,text:'one'},{id:2,text:'two'},{id:3,text:'three'}],<\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>&lt;<\/span><span>button<\/span><span> <\/span><span>@click<\/span><span>=<\/span><span>\"<\/span><span>deleteOne<\/span><span>\"<\/span><span>&gt;<\/span>deleteOne<span>&lt;\/<\/span><span>button<\/span><span>&gt;<\/span><\/div><div>&lt;button&nbsp;@click=\"alterOrder\"&gt;alterOrder&lt;\/button&gt;&nbsp;&nbsp;<span><br><\/span><\/div><div><span>deleteOne<\/span><span>(){&nbsp;&nbsp;<\/span>this.c.shift() }<\/div><p>alterOrder(){&nbsp; this.c = [{id:3,text:'three'},{id:1,text:'one'},{id:2,text:'two'}]&nbsp; }&nbsp;<\/p><p>key是识别的标志，key和标签名相同的情况会复用。【key相同标签名不同不会复用】<\/p><p>例如上面alterOrder的场景，只是把数据最后一项移动最前面，没有key的情况看到是相同标签，就直接就地复用，直接改变里面内容，这样会多次操作dom，而加了key的值，例如把id作为key，通过key识别哪些是可以复用的，就只是把最后一项移到最前面，只操作一次dom。<\/p><p><span style=\"font-weight: bold;\"><br><\/span><\/p><p><span style=\"font-weight: bold;\">#组件渲染和更新<\/span><br><\/p><p>h=&gt;h(App)&nbsp; &nbsp; 初始化调用render函数，返回createElement函数处理后的vnode，当第一个参数为组件时，调用createComponent。把js对象理由vue.extend转换为组件构造函数，并添加内部钩子，init【初始化组件调用，new Ctor构造函数】，patch，insert，destory【删除组件调用】，最后转为vnode<\/p><p><br><\/p><p><span style=\"font-weight: bold;\">#为什么组件data返回的是一个函数<\/span><br><\/p><p>function VueComponent(){}<\/p><p>VueComponent.prototype.data = {&nbsp; a:1&nbsp; }<\/p><p>let v = new VueComponent()<\/p><p>let w = new VueComponent()<\/p><p>v.a = 2<\/p><p>w.a&nbsp; &nbsp; &nbsp; \/\/ 2<\/p><p>同个组件被复用多次，会创建多个实例。这些实例用的是同一个构建函数，如果data是一个对象的话，那么所有组件都共享这个对象。为了保证组件的独立性，每个组件必须通过data函数返回一个对象。<\/p><p><br><\/p><p><span style=\"font-weight: bold;\">#组件和原生添加事件<\/span><br><\/p><p>&lt;div @click=\"say\"&gt;say&lt;\/div&gt;<\/p><p>&lt;test @click=\"()=&gt;{}\"&nbsp; &nbsp;@click.native=\"()=&gt;{}\"&gt;<\/p><p>组件上的@click=\"()=&gt;{}\" 就是直接给组件加个$on监听方法，test.$on('click',()=&gt;{})&nbsp; &nbsp; 发布订阅模式处理<\/p><p>div的@click 和组件的@click.native=\"()=&gt;{}\"都是原生添加addEventListener('click',()=&gt;{})<\/p><p><span style=\"color: rgb(194, 79, 74);\">所以<\/span><\/p><p>&lt;ul&gt;<\/p><p>&lt;li v-for=\"i in 100\" @click=\"()=&gt;{}\"&gt;&lt;\/li&gt;<\/p><p>&lt;ul&gt;<\/p><p>性能是不好的，添加100次addEventListener<\/p><p>优化方式采用事件代理模式<\/p><p>&lt;ul @click=\"\"&gt;<\/p><p>&lt;li v-for=\"i in 100\"&gt;&lt;\/li&gt;<\/p><p>&lt;ul&gt;<\/p><p><br><\/p><p><span style=\"font-weight: bold;\">#v-model的实现原理和自定义v-model<\/span><br><\/p><p>组件v-model默认是value+input的语法糖<\/p><p>&lt;el-input v-model=\"isShow\"\/&gt;&nbsp;&nbsp;<br><\/p><p>是&lt;el-input :value=\"isShow\" @input=\"alterIsShow\"\/&gt;的语法糖<\/p><p>alterIsShow(e){&nbsp; this.isShow = e&nbsp; &nbsp;}&nbsp;<\/p><p>源码内部会对input的类型判断，如果是checkbox，v-model就变成checked+change的语法糖。<\/p><p><span style=\"font-weight: bold;\">自定义组件v-model&nbsp;&nbsp;<\/span><br><\/p><div><span>Vue<\/span><span>.<\/span><span>component<\/span><span>(<\/span><span>'el-checkbox'<\/span><span>,{<\/span><\/div><div><span>  <\/span><span>template:<\/span><span> <\/span><span>`&lt;input type=\"checkbox\" :checked=\"checked\" @change=\"$emit('change',$event.target.checked)\"&gt;`<\/span><span>,<\/span><\/div><div><span>  <\/span><span>model:<\/span><span>{<\/span><\/div><div><span>    <\/span><span>prop:<\/span><span>'checked'<\/span><span>,   <\/span><span>\/\/ 默认value<\/span><\/div><div><span>    <\/span><span>event:<\/span><span> <\/span><span>'change'<\/span><span>   <\/span><span>\/\/ 默认input<\/span><\/div><div><span>  },<\/span><\/div><div><span>  <\/span><span>props:<\/span><span>{<\/span><\/div><div><span>    <\/span><span>checked:<\/span><span> <\/span><span>Boolean<\/span><\/div><div><span>  }<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>})<\/span><\/div><div><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><div>&lt;el-checkbox&nbsp;v-model=\"isChecked\"\/&gt;<\/div><\/divcourier><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>是&lt;<\/span><span>el-checkbox<\/span><span> <\/span><span>:checked<\/span><span>=<\/span><span>\"<\/span>isChecked<span>\"<\/span><span> <\/span><span>@change<\/span><span>=<\/span><span>\"<\/span><span>alterCheckStatus<\/span><span>\"<\/span><span>\/&gt;的语法糖<\/span><\/div><div>alterCheckStatus(e){&nbsp; &nbsp;this.isChecked= e&nbsp; }&nbsp;<\/div><p><br><\/p><p><span style=\"font-weight: bold;\">#v-html可能会导致什么问题<br><\/span><\/p><p>可能会导致xss攻击<\/p><p>&lt;input type=\"text\" v-model=\"msg\"\/&gt;<\/p><p>&lt;div v-html=\"msg\"&gt;&lt;\/div&gt;<\/p><p>输入&lt;img src=\"\" onerror=\"alert(1)\"&gt;<\/p><p><br><\/p><p><span style=\"font-weight: bold;\">#mixin<\/span><br><\/p><p>定义mixin.<\/p><pre><code>let <span style=\"font-size: 1em;\">mixin<\/span><span style=\"font-size: 1em;\"> = {<\/span><br>   data() {\n       return {\n           name: 'mixin'\n       }\n   },\n   created() {\n       console.log('mixin...', this.name);\n   },\n   mounted() {},\n   methods: {}\n};\nexport default <span style=\"font-size: 1em;\">mixin<\/span><span style=\"font-size: 1em;\">;<\/span><br><\/code><\/pre><pre><code>\/\/全局引用\nimport mixin from '.\/mixin'\nVue.mixin(mixin)\n\n\/\/在vue文件中引用\nimport '@\/mixin'; \/\/ 引入mixin文件\nexport default {\n   mixins: [mixin],\n<p>   data() {<br>       return {<br>           name: 'component'<br>       }<br>   },<\/p>   <span style=\"font-size: 1em;\">created() {<\/span><p>       console.log('component...', this.name);<br>   },<br>   mounted() {},<br>   methods: {}<\/p>}<\/code><\/pre><p>mixins里面的option会覆盖组件的其他option<\/p><p>mixin钩子函数在组件里的钩子函数之前调用【但这时data和methods已经合并完成咯】&nbsp; &nbsp;&nbsp;<br><\/p><p>'mixin...'&nbsp; 'component'<\/p><p>'component...'&nbsp; 'component'&nbsp;<br><\/p><p><br><\/p><p><br><\/p><p><span style=\"font-weight: bold;\">#普通插槽和作用域插槽的区别<\/span><br><\/p><p>普通插槽在父组件渲染后直接替换到子组件<\/p><p>作用域插槽是子组件渲染<\/p><p>&lt;little&gt;<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp;&lt;div slot=\"header\" slot-scope=\"slotProp\"&gt;{{slotProp.headName}}&lt;\/div&gt;<\/p><p>&lt;\/little&gt;<\/p><p><br><\/p><p><br><\/p><p><span style=\"font-weight: bold;\">#keep-alive原理<\/span><br><\/p><p>keep-alive可以实现组件的缓存，在组件切换时不会对当前组件卸载。keep-alive本身就是一个组件。他初始化时声明一个cache对象，第一次渲染时会把要缓存的组件vnode存在这个对象中，等之后再切换到这个组件就直接可以从cache对象中拿。<\/p><ul><li><code>include<\/code>&nbsp;- 字符串或正则表达式。只有名称匹配的组件会被缓存。<\/li><li><code>exclude<\/code>&nbsp;- 字符串或正则表达式。任何名称匹配的组件都不会被缓存。<\/li><li><code>max<\/code>&nbsp;- 数字。最多可以缓存多少组件实例。<\/li><\/ul><p>切换时生命周期<\/p><p>父beforeUpdate<\/p><p>子deactivated&nbsp; &nbsp; 前组件name<\/p><p>子activated&nbsp; &nbsp; 后组件name&nbsp;<\/p><p>父updated<br><\/p><p>LRU算法【cache=｛key:value｝每切换一次把新展示组件的key放到最后面，当渲染组件数量超过max时，删除第一个key】<\/p><p><br><\/p><p><br><\/p><p><br><\/p><p><br><\/p><p><br><\/p><p><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/4\/3 14:21:16",
"updatetime":"2020\/5\/18 16:54:41"
},
{
"id":65,
"title":"前端埋点&&性能监控&&异常监控",
"content":"<h3><span style=\"font-weight: bold;\">#埋点<\/span><\/h3><p>为了解决前端埋点的准确性、及时性、开发效率等问题，业内各家公司从不同角度，提出了多种技术方案，这些方案大体上可以归为三类：<\/p><ol><li><p>第一类是代码埋点，即在需要埋点的节点调用接口直接上传埋点数据，友盟、百度统计等第三方数据统计服务商大都采用这种方案；<\/p><\/li><li><p>第二类是可视化埋点，即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，从而实现所谓的“无痕埋点”， 代表方案是已经开源的<a href=\"https:\/\/link.zhihu.com\/?target=https%3A\/\/github.com\/mixpanel\" target=\"_blank\" rel=\"nofollow noreferrer\">Mixpane<\/a><img src=\"http:\/\/upload-images.jianshu.io\/upload_images\/46858-f940e667c6921bdf.png?imageMogr2\/auto-orient\/strip|imageView2\/2\/w\/864\/format\/webp\" style=\"max-width: 100%;\"><\/p><\/li><li><p><a href=\"https:\/\/link.zhihu.com\/?target=https%3A\/\/github.com\/mixpanel\" target=\"_blank\" rel=\"nofollow noreferrer\">l<\/a>；<\/p><\/li><li><p>第三类是“无埋点”，\n\n无埋点方式是通过全局监听或AOP技术添加埋点的一种实现方案，开发者不需要在每个需要埋点的地方添加代码，只需要根据服务器分发的配置，获取相应的埋点数据即可。一方面代码耦合度低，同时灵活度也高，埋点数据直接由服务器控制。缺点就是没有侵入式埋点精准。&nbsp; ，代表方案是国内的GrowingIO。<\/p><\/li><\/ol><p><br><\/p><p><br><\/p><p>性能监控：<\/p><p><a href=\"https:\/\/github.com\/forthealllight\/blog\/issues\/38\">https:\/\/github.com\/forthealllight\/blog\/issues\/38<\/a>&nbsp;&nbsp;<br><\/p><p><br><\/p><p>内存泄漏监测：<\/p><p><a href=\"https:\/\/mp.weixin.qq.com\/s?__biz=MzI2NTk2NzUxNg==&amp;mid=2247484393&amp;idx=1&amp;sn=434d7fa168e83db21912a814d51ca68a&amp;scene=21#wechat_redirect\">https:\/\/mp.weixin.qq.com\/s?__biz=MzI2NTk2NzUxNg==&amp;mid=2247484393&amp;idx=1&amp;sn=434d7fa168e83db21912a814d51ca68a&amp;scene=21#wechat_redirect<\/a>&nbsp;&nbsp;<br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/4\/8 11:45:28",
"updatetime":"2020\/4\/18 09:36:37"
},
{
"id":66,
"title":"小程序~",
"content":"<h3>#<span style=\"font-weight: bold;\">原生小程序<\/span><\/h3><p><span style=\"font-weight: bold;\">应用生命周期，全局只调用一次<\/span><\/p><pre><code>App({\n  onLaunch (options) {\n    \/\/ Do something initial when launch.\n  },\n  onShow (options) {\n    \/\/ Do something when show.\n  },\n  onHide () {\n    \/\/ Do something when hide.\n  },\n  onError (msg) {\n    console.log(msg)\n  },\n  globalData: 'I am global data'\n})<\/code><\/pre><p><span style=\"font-weight: bold;\">页面生命周期<\/span><\/p><pre><code>Page({\n  data: {\n    text: \"This is page data.\"\n  },\n  onLoad: function(options) {\n    \/\/ <span style=\"font-size: 1em;\">监听页面加载<\/span>\n  },\n  onShow: function() {\n    \/\/ <span style=\"font-size: 1em;\">监听页面显示<\/span>\n  },\n  onReady: function() {\n    \/\/ <span style=\"font-size: 1em;\">监听页面初次渲染完成<\/span>\n  },\n  onHide: function() {\n    \/\/ <span style=\"font-size: 1em;\">监听页面隐藏<\/span>\n  },\n  onUnload: function() {\n    \/\/ <span style=\"font-size: 1em;\">监听页面卸载<\/span>\n  },\n  onPullDownRefresh: function() {\n    \/\/ Do something when pull down.\n  },\n  onReachBottom: function() {\n    \/\/ Do something when page reach bottom.\n  },\n  onShareAppMessage: function () {\n    \/\/ return custom share data when user share.\n  },\n  onPageScroll: function() {\n    \/\/ Do something when page scroll\n  },\n  onResize: function() {\n    \/\/ Do something when page resize\n  },\n  onTabItemTap(item) {\n    console.log(item.index)\n    console.log(item.pagePath)\n    console.log(item.text)\n  }\n})<\/code><\/pre><p><span style=\"font-weight: bold;\"><h1article-title\">#为什么不选择<\/h1article-title\">小程序原生开发?<\/span><\/p><p><h1article-title\">原生开发对Node、预编译器、webpack支持不好，影响开发效率和工程构建流程&nbsp;&nbsp;<br><\/h1article-title\"><\/p><p><span style=\"font-weight: bold;\"><h1article-title\">#开发小程序遇到的坑<\/h1article-title\">?<\/span><\/p><h3>1、原生组件的层级问题<\/h3><p><h1article-title\"><code>video、canvas、camera<\/code>等<a target=\"_blank\" href=\"https:\/\/developers.weixin.qq.com\/miniprogram\/dev\/component\/native-component.html\" rel=\"nofollow noopener noreferrer\">原生组件<\/a>层级最高，其他组件无论<code>z-index<\/code>为多少，都无法覆盖在原生组件上&nbsp;。<\/h1article-title\"><\/p><p><strong>解决办法<\/strong>：利用&nbsp;<a target=\"_blank\" href=\"https:\/\/developers.weixin.qq.com\/miniprogram\/dev\/component\/cover-view.html\" rel=\"nofollow noopener noreferrer\" style=\"background-color: rgb(255, 255, 255);\">cover-view<\/a>&nbsp;组件，原生组件只支持嵌套<code style=\"font-size: 12px;\">cover-view<\/code>和<code style=\"font-size: 12px;\">cover-image<\/code>组件，且<code style=\"font-size: 12px;\">cover-view<\/code>内可以使用<code style=\"font-size: 12px;\">button<\/code><\/p><h3>2、ios和android部分组件表现的差异<\/h3><h3>ios存在的问题：<\/h3><p><strong><code>video<\/code><\/strong>：微信最小化后正在播放的<code>video<\/code>会暂停，需要再次点击播放按钮，如果视频设置的是不可控，没有开始播放按钮，视频暂停了就无法继续播放了，android没有该问题。&nbsp;<\/p><p>&lt;video id=\"video\" src=\"{{videoUrl}}\" loop autoplay controls=\"{{false}}\"&gt;\n&lt;\/video&gt;<\/p><p><strong>解决办法<\/strong>：创建<code style=\"font-size: 12px;\">video<\/code>上下文<code style=\"font-size: 12px;\">VideoContext<\/code>&nbsp;对象，页面每次onShow的时候执行相应操作。<\/p><div><div>onReady: function () {\n    this.videoContext = wx.createVideoContext('video')\n},\n\nonShow: function () {\n    if (this.videoContext) {\n        this.videoContext.play()\n    }\n},<\/div><\/div><p><br><\/p><p><span style=\"font-weight: bold;\">#原生小程序性能优化<\/span><\/p><p>图片懒加载，控制包大小，图片放在cdn<\/p><p>善用缓存：对一些变动频率很低的异步数据进行缓存，下次启动时可以直接利用；&nbsp;&nbsp;<br><\/p><p><span style=\"color: rgb(194, 79, 74);\">分包，<\/span>根据业务场景，将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载；&nbsp;<\/p><p>可以按需将某些具有一定功能独立性的页面配置到独立分包中。当小程序从普通的分包页面启动时，需要首先下载主包；而<span style=\"color: rgb(194, 79, 74);\">独立分包<\/span>不依赖主包即可运行，可以很大程度上提升分包页面的启动速度。&nbsp;<br><\/p><p>onLoad 阶段就可以发起请求，不用等ready&nbsp;&nbsp;<\/p><p>减少setData或合并setData&nbsp;&nbsp;<br><\/p><p><h1article-title\"><br><\/h1article-title\"><\/p><p><h1article-title\">小程序开发：用原生还是选框架（wepy\/mpvue\/uni-app\/taro）？&nbsp;<\/h1article-title\"><a href=\"https:\/\/juejin.im\/post\/5cfdcf056fb9a07ecd3d5068\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/juejin.im\/post\/5cfdcf056fb9a07ecd3d5068<\/a><\/p><p>uni-app小程序手把手项目实战<a href=\"https:\/\/juejin.im\/post\/5dcb77e9f265da4d260447c8#heading-3\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/juejin.im\/post\/5dcb77e9f265da4d260447c8#heading-3<\/a>&nbsp;<\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/4\/16 09:09:43",
"updatetime":"2020\/4\/16 12:04:30"
},
{
"id":67,
"title":"babel-loader相关知识",
"content":"<p><a href=\"https:\/\/astexplorer.net\/\">https:\/\/astexplorer.net\/<\/a>&nbsp;&nbsp;<br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/4\/27 15:26:16",
"updatetime":"2020\/6\/12 15:03:22"
},
{
"id":68,
"title":"设计模式",
"content":"<h3><a href=\"https:\/\/juejin.im\/post\/5afe6430518825428630bc4d\">https:\/\/juejin.im\/post\/5afe6430518825428630bc4d<\/a>&nbsp;&nbsp;<br><\/h3><p>单例模式 策略模式 观察者模式 发布者订阅者模式 代理模式等<\/p><p>适配者模式<\/p><h3>#单例模式<\/h3><p>1.确保一个类只有一个实例<\/p><p>2.供全局使用<\/p><div><a href=\"https:\/\/github.com\/MuYunyun\/blog\/blob\/master\/BasicSkill\/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.md\" target=\"_blank\">demo1<\/a><br><\/div><div><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><div>&lt;div&gt;<\/div><div>&lt;button&gt;btn&lt;\/button&gt;<\/div><div>&lt;button&gt;btn1&lt;\/button&gt;<\/div><div>&lt;\/div&gt;<\/div><\/divcourier><\/div><div>&lt;script&gt;<\/div><div>const getSingle = function(fn){<\/div><div>let&nbsp;result<\/div><div>return&nbsp;function(){<\/div><div>return&nbsp;result&nbsp;|| (result&nbsp;=&nbsp;fn.apply(this,arguments))<\/div><div>}<\/div><div>}<\/div><div>var&nbsp;popup&nbsp;=&nbsp;function(){<\/div><div>var&nbsp;div&nbsp;=&nbsp;document.createElement('div')<\/div><div>div.innerHTML&nbsp;=&nbsp;'我是一个div'<\/div><div>div.style.display&nbsp;=&nbsp;'none'<\/div><div>document.body.appendChild(div)<\/div><div>return&nbsp;div<\/div><div>}<\/div><div>var&nbsp;popup1&nbsp;=&nbsp;function(){<\/div><div>div&nbsp;=&nbsp;document.createElement('iframe')<\/div><div>div.innerHTML&nbsp;=&nbsp;'我是一个iframe'<\/div><div>div.style.display&nbsp;=&nbsp;'none'<\/div><div>document.body.appendChild(div)<\/div><div>return&nbsp;div<\/div><div>}<\/div><div>var&nbsp;popupFactory&nbsp;=&nbsp;getSingle(popup)<\/div><div>var&nbsp;popupFactory1&nbsp;=&nbsp;getSingle(popup1)<\/div><div>document.querySelector('.J-popup').onclick&nbsp;=&nbsp;function(){<\/div><div>var&nbsp;popupInstance&nbsp;=&nbsp;popupFactory()<\/div><div>popupInstance.style.display&nbsp;=&nbsp;'block'<\/div><div>}<\/div><div>document.querySelector('.J-popup1').onclick&nbsp;=&nbsp;function(){<\/div><div>var&nbsp;popupInstance&nbsp;=&nbsp;popupFactory1()<\/div><div>popupInstance.style.display&nbsp;=&nbsp;'block'<\/div><div>}<\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div>&lt;\/script&gt;<\/div><div><a href=\"https:\/\/juejin.im\/post\/5b74cf5ae51d4560f178cff2\" target=\"_blank\">demo2<\/a><br><\/div><div><ol><li>保证一个类仅有一个实例&nbsp;<code>new createModal()<\/code><\/li><li>并且提供一个访问它的全局访问点&nbsp;<code>createModal.getInstance【类的静态方法】<\/code>&nbsp;方法访问<\/li><\/ol><div><div><div>function createModal () {&nbsp;<\/div><div>const div = document.createElement('div'); div.className = 'modal'; document.body.appendChild(div);&nbsp;<\/div><div>}&nbsp;<\/div><div>createModal.getInstance = function () {&nbsp;<\/div><div>if (this.instace) { return this.instace; }&nbsp;<\/div><div>else { this.instace = new createModal(); return this.instace; }&nbsp;<\/div><div>};&nbsp;<\/div><div>const a = createModal.getInstance()&nbsp;<\/div><div>const b = createModal.getInstance() \/\/ 调用两次 实例一次<\/div><div>console.log(a === b) \/\/ true<\/div><\/div><\/div><\/div><h3>#策略模式<\/h3><p><a href=\"https:\/\/juejin.im\/post\/5b90bb20e51d450e5519c2c7\">https:\/\/juejin.im\/post\/5b90bb20e51d450e5519c2c7<\/a>&nbsp;<br><\/p><p>可以简单的认为指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法&nbsp;&nbsp;<br><\/p><ul><li>策略模式符合开放-封闭原则<\/li><li>如果代码里需要写大量的<code>if-else<\/code>语句，那么考虑使用策略模式<\/li><li>如果多个组件（类）之间的区别仅在于它们的行为，考虑采用策略模式<\/li><\/ul><p>优点：可复用性，可以有效的避免多种条件选择语句<\/p><h3>#观察者模式<\/h3><p>1.vue双向绑定原理<\/p><p>2.promise<\/p><h3>#发布者订阅者模式<\/h3><p>1.eventBus<\/p><p><a href=\"https:\/\/github.com\/MuYunyun\/waterfall\/blob\/0f229c1a2881d26166b92aa746b7f892af59c28f\/waterfall.js#L8\">https:\/\/github.com\/MuYunyun\/waterfall\/blob\/0f229c1a2881d26166b92aa746b7f892af59c28f\/waterfall.js#L8<\/a>&nbsp;&nbsp;<\/p><h3>#代理模式<\/h3><p><a href=\"https:\/\/github.com\/MuYunyun\/blog\/blob\/master\/BasicSkill\/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.md\" target=\"_blank\">图片预加载<\/a><br><\/p><h3>#适配者模式<\/h3><p><a href=\"https:\/\/github.com\/MuYunyun\/blog\/blob\/master\/BasicSkill\/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\/%E9%80%82%E9%85%8D%E8%80%85%E6%A8%A1%E5%BC%8F.md\" target=\"_blank\">接口不同<\/a>【主要用于解决两个接口之间不匹配的问题。】<\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/5\/5 09:37:11",
"updatetime":"2020\/5\/20 22:47:47"
},
{
"id":69,
"title":"异步方案对比深入理解",
"content":"<p>遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。&nbsp;&nbsp;<br><\/p><p>一个数据结构只要具有<code>Symbol.iterator<\/code>属性，就可以认为是“可遍历的”（iterable）。&nbsp;<\/p><pre><code>const obj = {\n  [Symbol.iterator] : function () {\n    return {\n      next: function () {\n        return {\n          value: 1,\n          done: true\n        };\n      }\n    };\n  }&nbsp;\n}<\/code><\/pre><p><code>Symbol.iterator<\/code>属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有<code>next<\/code>方法。每次调用<code>next<\/code>方法，都会返回一个代表当前成员的信息对象，具有<code>value<\/code>和<code>done<\/code>两个属性。&nbsp;&nbsp;<br><\/p><p>&nbsp;<code style=\"font-size: 12px;\">Symbol.iterator<\/code>方法的最简单实现，还是使用Generator 函数【generator就是一个遍历器生成函数】。<\/p><p>const obj = {&nbsp;<\/p><p>&nbsp;* [Symbol.iterator]() {\n    yield 1;\n  }&nbsp;<\/p><p>};&nbsp;<\/p><h2><span style=\"font-weight: bold;\">#generator<\/span><\/h2><p>function* f() {<br>  console.log('执行了！')<br>}<br>var generator = f();<br>setTimeout(function () {<br>  generator.next()<br>}, 2000);<\/p><p>上面代码中，函数<code>f<\/code>如果是普通函数，在为变量<code>generator<\/code>赋值时就会执行。但是，函数<code>f<\/code>是一个 Generator 函数，就变成只有调用<code>next<\/code>方法时，函数<code>f<\/code>才会执行。&nbsp;&nbsp;<br><\/p><pre><code>function* foo(x) {\n  var y = 2 * (yield (x + 1));\n  var z = yield (y \/ 3);\n  return (x + y + z);\n}\n\nvar a = foo(5);\na.next()<span spellcheck=\"true\"> \/\/ Object{value:6, done:false}\n<\/span>a.next()<span spellcheck=\"true\"> \/\/ Object{value:NaN, done:false}\n<\/span>a.next()<span spellcheck=\"true\"> \/\/ Object{value:NaN, done:true}\n<\/span>\nvar b = foo(5);\nb.next()<span spellcheck=\"true\"> \/\/ { value:6, done:false }\n<\/span>b.next(12)<span spellcheck=\"true\"> \/\/ { value:8, done:false }\n<\/span>b.next(13)<span spellcheck=\"true\"> \/\/ { value:42, done:true }<\/span><\/code><\/pre><p><code>next<\/code>方法的参数表示上一个<code>yield<\/code>表达式的返回值，所以在第一次使用<code>next<\/code>方法时，传递参数是无效的。&nbsp;&nbsp;<br><\/p><p><code>async<\/code>函数对 Generator 函数的改进，体现在以下四点。<\/p><p>（1）内置执行器。Generator 函数的执行必须靠执行器，所以才有了<code style=\"font-size: 12px;\">co<\/code>模块，而<code style=\"font-size: 12px;\">async<\/code>函数自带执行器。也就是说，<code style=\"font-size: 12px;\">async<\/code>函数的执行，与普通函数一模一样<\/p><p>（2）返回值是 Promise。&nbsp; 不像generator，返回的是遍历器对象<br><\/p><p><strong>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。<\/strong>&nbsp;&nbsp;<br><\/p><pre><code>async function fn(args){\n <span spellcheck=\"true\"> \/\/ ...\n<\/span>}\n<span spellcheck=\"true\">\n\/\/ 等同于\n<\/span>\nfunction fn(args){ \n  return spawn(function*() {\n   <span spellcheck=\"true\"> \/\/ ...\n<\/span>  }); \n}<\/code><\/pre><p>所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。<\/p><p>下面给出 spawn 函数的实现，基本就是前文自动执行器的翻版。<\/p><pre><code><br>function spawn(genF) {\n  return new Promise(function(resolve, reject) {\n    var gen = genF();\n    function step(nextF) {\n      try {\n        var next = nextF();\n      } catch(e) {\n        return reject(e); \n      }\n      if(next.done) {\n        return resolve(next.value);\n      } \n      Promise.resolve(next.value).then(function(v) {\n        step(function() { return gen.next(v); });      \n      }, function(e) {\n        step(function() { return gen.throw(e); });\n      });\n    }\n    step(function() { return gen.next(undefined); });\n  });\n}<\/code><\/pre><p>唔写的执行器<\/p><div><pre><code>export function generatorExecuter(func){<br>return new Promise((resolve,reject)=&gt;{<br>let g = func()<br>function recursion(preValue){<br>const next = g.next(preValue)<br>const value = next.value<br>const done = next.done<br>if(done){<br>resolve(value)<br>}else{<br>if(value.then){<br>value.then(function(res){<br>recursion(res)<br>})<br>}else{<br>recursion(value)<br>}<br>}<br>}<br>return recursion()<br>})<br><br>}<\/code><\/pre><p><br><\/p><\/div><div><span>###20行解决<\/span><\/div><div><pre><code>function asyncToGenerator(generatorFunc) {<br>\/\/ 返回的是一个新的函数<br>return function() {<br>\/\/ 先调用generator函数 生成迭代器<br>\/\/ 对应 var gen = testG()<br>const gen = generatorFunc.apply(this, arguments)<br>\/\/ 返回一个promise 因为外部是用.then的方式 或者await的方式去使用这个函数的返回值的<br>\/\/ var test = asyncToGenerator(testG)<br>\/\/ test().then(res =&gt; console.log(res))<br>return new Promise((resolve, reject) =&gt; {<br>\/\/ 内部定义一个step函数 用来一步一步的跨过yield的阻碍<br>\/\/ key有next和throw两种取值，分别对应了gen的next和throw方法<br>\/\/ arg参数则是用来把promise resolve出来的值交给下一个yield<br>function step(key, arg) {<br>let generatorResult<br>\/\/ 这个方法需要包裹在try catch中<br>\/\/ 如果报错了 就把promise给reject掉 外部通过.catch可以获取到错误<br>try {<br>generatorResult = gen[key](arg)<br>} catch (error) {<br>return reject(error)<br>}<br>\/\/ gen.next() 得到的结果是一个 { value, done } 的结构<br>const { value, done } = generatorResult<br>if (done) {<br>\/\/ 如果已经完成了 就直接resolve这个promise<br>\/\/ 这个done是在最后一次调用next后才会为true<br>\/\/ 以本文的例子来说 此时的结果是 { done: true, value: 'success' }<br>\/\/ 这个value也就是generator函数最后的返回值<br>return resolve(value)<br>} else {<br>\/\/ 除了最后结束的时候外，每次调用gen.next()<br>\/\/ 其实是返回 { value: Promise, done: false } 的结构，<br>\/\/ 这里要注意的是Promise.resolve可以接受一个promise为参数<br>\/\/ 并且这个promise参数被resolve的时候，这个then才会被调用<br>return Promise.resolve(<br>\/\/ 这个value对应的是yield后面的promise<br>value<br>).then(<br>\/\/ value这个promise被resove的时候，就会执行next<br>\/\/ 并且只要done不是true的时候 就会递归的往下解开promise<br>\/\/ 对应gen.next().value.then(value =&gt; {<br>\/\/ gen.next(value).value.then(value2 =&gt; {<br>\/\/ gen.next() <br>\/\/<br>\/\/ \/\/ 此时done为true了 整个promise被resolve了 <br>\/\/ \/\/ 最外部的test().then(res =&gt; console.log(res))的then就开始执行了<br>\/\/ })<br>\/\/ })<br>function onResolve(val) {<br>step(\"next\", val)<br>},<br>\/\/ 如果promise被reject了 就再次进入step函数<br>\/\/ 不同的是，这次的try catch中调用的是gen.throw(err)<br>\/\/ 那么自然就被catch到 然后把promise给reject掉啦<br>function onReject(err) {<br>step(\"throw\", err)<br>},<br>)<br>}<br>}<br>step(\"next\")<br>})<br>}<br>}<\/code><\/pre><\/div><p>async 函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器 Babel 和 regenerator 都已经支持，转码后就能使用。&nbsp;&nbsp;<br><\/p><p>function aha(){<br>    return new Promise((resolve,reject)=&gt;{<br>          setTimeout(()=&gt;{<br>                resolve(2)<br>          },1000)<br>    })<br>}<\/p><div><div tabindex=\"-1\"><div><div tabindex=\"-1\"><div><div><div role=\"presentation\"><div role=\"presentation\"><div role=\"presentation\"><div><pre role=\"presentation\"><span role=\"presentation\">function *aaa(){<\/span><\/pre><\/div><pre role=\"presentation\"><span role=\"presentation\"> &nbsp; &nbsp; let d = yield aha()<\/span><\/pre><pre role=\"presentation\"><span role=\"presentation\"> &nbsp; &nbsp; console.log(d)<\/span><\/pre><pre role=\"presentation\"><span role=\"presentation\">}<\/span><\/pre><pre role=\"presentation\"><span role=\"presentation\">aaa().next()      \/\/     {  value: Promise, done: false}    【aha返回什么value就是什么】<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div><\/div><\/div><\/div><\/div><\/div><div><div><pre role=\"presentation\"><span role=\"presentation\">async function aaa(){<\/span><\/pre><\/div><pre role=\"presentation\"><span role=\"presentation\"> &nbsp; &nbsp; let d = await aha()<\/span><\/pre><pre role=\"presentation\"><span role=\"presentation\"> &nbsp; &nbsp; console.log(d)<\/span><\/pre><pre role=\"presentation\"><span role=\"presentation\">}<\/span><\/pre><pre role=\"presentation\"><span role=\"presentation\">aaa()        \/\/    2       【拿的是promise的resolve值,要是await后面不是promise，也会包成Promise.resolve(xxx)】<\/span><\/pre><\/div><p><br><\/p><p><br><\/p><p><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/5\/9 20:00:39",
"updatetime":"2020\/5\/11 17:30:26"
},
{
"id":70,
"title":"webpack原理",
"content":"<p>webpack配置解说&nbsp;<a href=\"https:\/\/www.aiheart.top\/eblog\/#\/blog\/detail\/23?type=1\">https:\/\/www.aiheart.top\/eblog\/#\/blog\/detail\/23?type=1<\/a>&nbsp;&nbsp;<br><\/p><p><h1cur_title\">webpack构建极限优化~&nbsp;<\/h1cur_title\"><a href=\"https:\/\/www.aiheart.top\/eblog\/#\/blog\/detail\/53?type=\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/www.aiheart.top\/eblog\/#\/blog\/detail\/53?type=<\/a>&nbsp;<\/p><p>参考<a href=\"https:\/\/segmentfault.com\/a\/1190000015088834\">https:\/\/segmentfault.com\/a\/1190000015088834<\/a>&nbsp;<\/p><p>&nbsp;<br><\/p><p><span style=\"font-weight: bold;\">#webpack的构建打包流程<\/span><\/p><p>1.<span style=\"font-weight: bold;\">初始化<\/span>&nbsp; 启动构建，读取和合并配置参数，初始化各种plugin，在实例化compiler后【compiler负责文件监听和编译】，依次调用插件的apply方法，让插件可以监听后续的所有事件节点，同时给插件引入compiler实例的引用，以方便插件通过compiler调用webpack提供的api来改变输出结果<\/p><p>2.<span style=\"font-weight: bold;\">编译<\/span>&nbsp;执行compiler的run方法。从入口文件出发，调用所有配置的loader对模块进行翻译，再找出该模块依赖的模块，再递归进行编译处理。在所有的模块都编译完成后，得到所有模块的最终内容和模块之间的依赖关系<\/p><p>3.<span style=\"font-weight: bold;\">输出&nbsp;<\/span>\n\n根据入口和模块的依赖关系，根据配置组装成一个个包含多个模块的chunk，输出到指定的位置。<\/p><p><br><\/p><p>在webpack执行构建流程时，webpack会在特定的时机广播对应的事件，插件在监听到事件后，会执行特定的逻辑来修改模块的内容。&nbsp;&nbsp;<br><\/p><p><img src=\"https:\/\/user-gold-cdn.xitu.io\/2019\/8\/7\/16c6a9f62ed444e5?imageView2\/0\/w\/1280\/h\/960\/format\/webp\/ignore-error\/1\" style=\"max-width:100%;\"><br><\/p><p>run：开始编译<br>make：从entry开始递归分析依赖并对依赖进行build<br>build-moodule：使用loader加载文件并build模块<br>normal-module-loader：对loader加载的文件用acorn编译，生成抽象语法树AST<br>program：开始对AST进行遍历，当遇到require时触发call require事件<br>seal：所有依赖build完成，开始对chunk进行优化（抽取公共模块、加hash等）<br>optimize-chunk-assets：压缩代码<br>emit：把各个chunk输出到结果文件<br>通过对节点的监听，从而找到合适的节点对文件做适当的处理。&nbsp;&nbsp;<br><\/p><p><br><\/p><p><strong>Compiler 对象包含了 Webpack 环境所有的的配置信息<\/strong>，包含 options，loaders，plugins 这些信息。这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例；<br><\/p><p><code>compilation<\/code>&nbsp;继承于<code>compiler<\/code>&nbsp;，一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件。每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。&nbsp;&nbsp;<\/p><h4>Compiler 和 Compilation 的区别在于：<\/h4><p>Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译。<\/p><p><br><\/p><p><span style=\"font-weight: bold;\">#compiler常见钩子<\/span><\/p><div><div><li><code>entryOption<\/code>&nbsp;: 在 webpack 选项中的 <code>entry<\/code> 配置项 处理过之后，执行插件。<\/li>\n<li><code>afterPlugins<\/code>&nbsp;:&nbsp;设置完初始插件之后，执行插件。<\/li>\n<li><code>compilation<\/code>&nbsp;:&nbsp;编译创建之后，生成文件之前，执行插件。。<\/li>\n<li><code>emit<\/code>&nbsp;:&nbsp;生成资源到 <code>output<\/code> 目录之前。<\/li><li><code>afterEmit<\/code>&nbsp;:&nbsp;&nbsp; 生成资源到 output 目录之后。&nbsp;&nbsp;<br><\/li>\n<li><code>done<\/code>&nbsp;:&nbsp;编译完成。<\/li><\/div><br><\/div><div><div>class HelloWorldPlugin {&nbsp;<\/div><div>&nbsp; &nbsp; apply(compiler) {<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; compiler.hooks.done.tap('Hello World Plugin', (\n      stats \/* 在 hook 被触及时，会将 stats 作为参数传入。 *\/\n    ) =&gt; {<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.log('Hello World!');\n    });&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; })<\/div><div>&nbsp; &nbsp; }&nbsp;<\/div><div>}<\/div><div>module.exports = HelloWorldPlugin;<\/div><br><\/div><p><span style=\"font-weight: bold;\">#编写一个不缓存js的插件<\/span>&nbsp;<\/p><p><a href=\"https:\/\/juejin.im\/post\/5e5309ece51d4526e03f9e53\" style=\"background-color: rgb(255, 255, 255);\">https:\/\/juejin.im\/post\/5e5309ece51d4526e03f9e53<\/a><\/p><div><div>\/\/ SetScriptTimestampPlugin.js&nbsp;<\/div><div>class SetScriptTimestampPlugin {&nbsp;<\/div><div>&nbsp;apply(compiler) {&nbsp;<\/div><div>&nbsp;<span style=\"font-weight: bold;\">compiler.hooks.compilation.tap<\/span>('SetScriptTimestampPlugin', \n      (compilation, callback) =&gt; {&nbsp;<\/div><div>&nbsp; \/\/ 插件逻辑 调用compilation提供的plugin方法&nbsp;<\/div><div>&nbsp; <span style=\"font-weight: bold;\">compilation.plugin<\/span>(\n          \"html-webpack-plugin-before-html-processing\",\n          function(htmlPluginData, callback) {&nbsp;<\/div><div>&nbsp;            \/\/ 读取并修改 script 上 src 列表&nbsp;<\/div><div>&nbsp;            let jsScr = htmlPluginData.assets.js[0];\n            htmlPluginData.assets.js = [];\n            let result = `\n                &lt;script&gt;\n                    let scriptDOM = document.createElement(\"script\");\n                    let jsScr = \".\/${jsScr}\";\n                    scriptDOM.src = jsScr + \"?\" + new Date().getTime();\n                    document.body.appendChild(scriptDOM)\n                &lt;\/script&gt;\n            `;\n            let resultHTML = htmlPluginData.html.replace(\n              \"&lt;!--SetScriptTimestampPlugin inset script--&gt;\", result\n            );&nbsp;<\/div><div>&nbsp;            \/\/ 返回修改后的结果&nbsp;<\/div><div>&nbsp;htmlPluginData.html = resultHTML;&nbsp;<\/div><div>&nbsp;}\n        );\n      }\n    );\n  }\n}&nbsp;<\/div><div>module.exports = SetScriptTimestampPlugin;<\/div><div><strong>执行&nbsp;<strong><code>compilation.plugin<\/code><\/strong>&nbsp; 方法，并传入两个参数：插件事件和回调方法。<\/strong><\/div><\/div><p>“插件事件”即插件所提供的一些事件，用于监听插件状态，像&nbsp;<code>html-webpack-plugin<\/code>&nbsp;提供的事件（完整可查看《<a target=\"_blank\" href=\"https:\/\/www.npmjs.com\/package\/html-webpack-plugin\" rel=\"nofollow noopener noreferrer\">html-webpack-plugin<\/a>》）<br><\/p><p>在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。&nbsp;&nbsp;<br><\/p><p><br><\/p><p><br><\/p><p>一个 Loader 其实就是一个 Node.js 模块，只需要关心输入和输出。loader导出的函数的工作就是获得处理前的原内容，对原内容执行处理后，返回处理后的内容。&nbsp;&nbsp;<br><\/p><p>编写自己的Webpack Loader&nbsp;<a href=\"https:\/\/juejin.im\/post\/59df06e6f265da430d5701d0\">https:\/\/juejin.im\/post\/59df06e6f265da430d5701d0<\/a>&nbsp;&nbsp;<br><\/p><p>webpack输出文件分析以及编写一个loader&nbsp;<a href=\"https:\/\/juejin.im\/post\/5d4a4644f265da03ab423767\">https:\/\/juejin.im\/post\/5d4a4644f265da03ab423767<\/a>&nbsp;&nbsp;<br><\/p><div><span>const<\/span><span> <\/span><span>loaderUtils<\/span><span> <\/span><span>=<\/span><span> <\/span><span>require<\/span><span>(<\/span><span>'loader-utils'<\/span><span>);<\/span><\/div><div><span>module<\/span><span>.<\/span><span>exports<\/span><span> <\/span><span>=<\/span><span> <\/span><span>function<\/span><span>(<\/span><span>source<\/span><span>) {<\/span><\/div><div><span>    <\/span><span>console<\/span><span>.<\/span><span>log<\/span><span>(<\/span><span>source<\/span><span>)&nbsp; &nbsp; &nbsp;\/\/&nbsp; 获取字符串或buffer<\/span><\/div><div><span>    <\/span><span>\/\/ 获取用户为当前Loader传入的options<\/span><\/div><div><span>    <\/span><span>\/\/ console.log(loaderUtils.getOptions(this));<\/span><\/div><div><span>    <\/span><span>return<\/span><span> <\/span><span>source<\/span><span>;<\/span><\/div><div><span>\/\/ return&nbsp;<\/span>this.callback(\n  err: Error | null,\n  content: string | Buffer,\n  sourceMap?: SourceMap,\n  meta?: any\n);<\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>}<\/span><\/div><div><span><br><\/span><\/div><p><br><\/p><p>vue-cli3的loader和插件写法<\/p><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span style=\"font-weight: bold;\">chainWebpack<\/span>:config =&gt;{<\/div><div>config.module<\/div><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><div>            .rule('options')<\/div><div>            .test(\/.js$\/)<\/div><div>            .use('.\/loaders\/getOptionsLoader.js')<\/div><div>            .loader('.\/loaders\/getOptionsLoader.js')<\/div><div>            .options({<\/div><div>                a:1<\/div><div>            })<\/div><\/divcourier><div><span>},<\/span><\/div><div><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><div style=\"\"><span style=\"font-weight: bold;\">configureWebpack<\/span>:config=&gt;{<\/div><div style=\"\"><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"><div>config.plugins = [...config.plugins,new&nbsp;SetScriptTimestampPlugin()]<\/div><\/divcourier><\/div><div style=\"\">}<\/div><\/divcourier><\/div><p><br><\/p><p><br><\/p><p><br><\/p><p><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/5\/13 09:40:35",
"updatetime":"2020\/5\/13 21:47:47"
},
{
"id":72,
"title":"前端规范",
"content":"<ul><li><a target=\"_blank\" href=\"https:\/\/guide.aotu.io\/docs\/index.html\" rel=\"nofollow noopener noreferrer\">京东凹凸实验室代码规范<\/a><\/li><li><a target=\"_blank\" href=\"https:\/\/github.com\/ryanmcdermott\/clean-code-javascript?utm_source=gold_browser_extension\" rel=\"nofollow noopener noreferrer\">clean-code-javascript<\/a><\/li><li><a target=\"_blank\" href=\"https:\/\/github.com\/airbnb\/javascript\" rel=\"nofollow noopener noreferrer\">Airbnb团队<\/a><\/li><li><a target=\"_blank\" href=\"https:\/\/github.com\/fex-team\/styleguide\" rel=\"nofollow noopener noreferrer\">百度fex团队<\/a><\/li><\/ul><p>前端工程化那些事&nbsp;<a href=\"https:\/\/juejin.im\/post\/5e999cecf265da47cd357a24\">https:\/\/juejin.im\/post\/5e999cecf265da47cd357a24<\/a>&nbsp;&nbsp;<br><\/p><p><br><\/p><p>github:&nbsp;<a href=\"https:\/\/github.com\/lingxiaoyi\/standard\">https:\/\/github.com\/lingxiaoyi\/standard<\/a>&nbsp;&nbsp;<br><\/p><p><a href=\"https:\/\/mp.weixin.qq.com\/s\/OE0zAs78VEj3yNY3d_rVJw\">https:\/\/mp.weixin.qq.com\/s\/OE0zAs78VEj3yNY3d_rVJw<\/a>&nbsp;&nbsp;<br><\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; {value:&nbsp;'特性',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'特性:&nbsp;&nbsp;&nbsp;&nbsp;一个新的特性'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'修复',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'修复:&nbsp;&nbsp;&nbsp;&nbsp;修复一个Bug'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'文档',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'文档:&nbsp;&nbsp;&nbsp;&nbsp;变更的只有文档'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'格式',&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'格式:&nbsp;&nbsp;&nbsp;&nbsp;空格,&nbsp;分号等格式修复'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'重构',&nbsp;name:&nbsp;'重构:&nbsp;&nbsp;&nbsp;&nbsp;代码重构，注意和特性、修复区分开'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'性能',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'性能:&nbsp;&nbsp;&nbsp;&nbsp;提升性能'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'测试',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'测试:&nbsp;&nbsp;&nbsp;&nbsp;添加一个测试'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'工具',&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'工具:&nbsp;&nbsp;&nbsp;&nbsp;开发工具变动(构建、脚手架工具等)'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'回滚',&nbsp;&nbsp;&nbsp;name:&nbsp;'回滚:&nbsp;&nbsp;&nbsp;&nbsp;代码回退'}&nbsp;&nbsp;<br><\/p><p><br><\/p><p>{value:&nbsp;'feat',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'feat:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;new&nbsp;feature'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'fix',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'fix:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;bug&nbsp;fix'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'docs',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'docs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Documentation&nbsp;only&nbsp;changes'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'style',&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'style:&nbsp;&nbsp;&nbsp;&nbsp;Changes&nbsp;that&nbsp;do&nbsp;not&nbsp;affect&nbsp;the&nbsp;meaning&nbsp;of&nbsp;the&nbsp;code\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(white-space,&nbsp;formatting,&nbsp;missing&nbsp;semi-colons,&nbsp;etc)'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'refactor',&nbsp;name:&nbsp;'refactor:&nbsp;A&nbsp;code&nbsp;change&nbsp;that&nbsp;neither&nbsp;fixes&nbsp;a&nbsp;bug&nbsp;nor&nbsp;adds&nbsp;a&nbsp;feature'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'perf',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'perf:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;code&nbsp;change&nbsp;that&nbsp;improves&nbsp;performance'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'test',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'test:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adding&nbsp;missing&nbsp;tests'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'chore',&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'chore:&nbsp;&nbsp;&nbsp;&nbsp;Changes&nbsp;to&nbsp;the&nbsp;build&nbsp;process&nbsp;or&nbsp;auxiliary&nbsp;tools\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;libraries&nbsp;such&nbsp;as&nbsp;documentation&nbsp;generation'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'revert',&nbsp;&nbsp;&nbsp;name:&nbsp;'revert:&nbsp;&nbsp;&nbsp;Revert&nbsp;to&nbsp;a&nbsp;commit'},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{value:&nbsp;'WIP',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name:&nbsp;'WIP:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Work&nbsp;in&nbsp;progress'}&nbsp;&nbsp;<br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/6\/7 16:52:18",
"updatetime":"2020\/7\/1 15:30:24"
},
{
"id":2020,
"title":"高级函数~yeh",
"content":"<h3>debounce和throttle的对比<\/h3><h2><a href=\"http:\/\/demo.nimius.net\/debounce_throttle\/\">http:\/\/demo.nimius.net\/debounce_throttle\/<\/a>&nbsp;&nbsp;<\/h2><h2><\/h2><h4><span style=\"color: rgb(194, 79, 74); font-weight: normal;\">现成库有lodash~<\/span><\/h4><span style=\"font-weight: bold; color: rgb(139, 170, 74);\">\/\/ 防抖<\/span><div><span style=\"color: rgb(77, 128, 191); font-weight: bold;\">#场景介绍：有一个按钮（或输入框），我们不希望每次点击按钮（或每次输入）都会发起网络请求，而是用户持续点击（或输入）一段时间后没有再次点击（或输入）才发请求<\/span><\/div><div><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">#原理：当持续触发事件时，一定时间内没有再触发事件，事件处理函数才会执行一次。在设定的时间到来前又一次触发事件，就重新开始延时。<\/span><\/div><div><h3>应用：【input输入搜索，resize】<\/h3><\/div><p><span style=\"color: rgb(77, 128, 191);\">#简单版：<\/span><\/p><p><span style=\"color: rgb(77, 128, 191);\">【最后一次触发】<\/span><\/p><p>function debounce(fn,wait=500){<br>&nbsp; &nbsp; &nbsp;let timer = null<br>&nbsp; &nbsp; &nbsp;return function(){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clearTimeout(timer)<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timer = setTimeout(()=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fn.apply(this,arguments)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },\n\nwait)<br>&nbsp; &nbsp; &nbsp; }<br>}<\/p><p><span style=\"color: rgb(77, 128, 191);\">【首次触发】<\/span><\/p><p>function debounce(fn,wait=500){<br>&nbsp; &nbsp; &nbsp;let timer = null<\/p><p>&nbsp; &nbsp; &nbsp;let isOk = true<\/p><p>&nbsp; &nbsp; &nbsp;return function () {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clearTimeout(timer)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timer = setTimeout(() =&gt; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isOk = true<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }, wait)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!isOk) return<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isOk = false<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fn.apply(this, arguments)<br>&nbsp; &nbsp; &nbsp; }<\/p><p>}<\/p><p><span style=\"color: rgb(123, 91, 161);\">#如何用：<\/span><\/p><p>let btn = document.getElementById('btn')&nbsp;&nbsp;<span style=\"color: rgb(123, 91, 161);\"><br><\/span><\/p><p>function tick(e){console.log(e)}<\/p><p><span style=\"color: rgb(194, 79, 74);\">#error<\/span><\/p><p>btn.onclick = function(){ debounce(tick)(1) }&nbsp; &nbsp; &nbsp;\/\/ 这种每次都重新生成定时函数。没达到防抖效果<br><\/p><p><span style=\"color: rgb(139, 170, 74);\">#right<\/span><\/p><p>let ajax =&nbsp; debounce(tick)<\/p><p>btn.onclick = function(){ ajax(1) }&nbsp;&nbsp;<\/p><p><span style=\"color: rgb(194, 79, 74);\">#复杂版(可设置是否立即触发事件)【摘自<\/span><a href=\"https:\/\/www.cnblogs.com\/fsjohnhuang\/p\/4147810.html\" target=\"_blank\">underscore<\/a><span style=\"color: rgb(194, 79, 74);\">】：<\/span><\/p><p>function debounce(func, wait, immediate) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ immediate默认为false<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var timeout, args, context, timestamp, result;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var later = function() {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ 当wait指定的时间间隔期间多次调用_.debounce返回的函数，则会不断更新timestamp的值，导致last &lt; wait &amp;&amp; last &gt;= 0一直为true，从而不断启动新的计时器延时执行func<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var last = Date.now() - timestamp;<br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (last &lt; wait &amp;&amp; last &gt;= 0) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeout = setTimeout(later, wait - last);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} else {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeout = null;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!immediate) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = func.apply(context, args);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!timeout) context = args = null;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;};<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return function() {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context = this;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; args = arguments;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timestamp = Date.now();<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/ 第一次调用该方法时，且immediate为true，则调用func函数<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var callNow = immediate &amp;&amp; !timeout;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/ 在wait指定的时间间隔内首次调用该方法，则启动计时器定时调用func函数<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!timeout) timeout = setTimeout(later, wait);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (callNow) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = func.apply(context, args);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context = args = null;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return result;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;};<br>  };<\/p><h2><span style=\"color: rgb(139, 170, 74);\">\/\/ 节流【滚动加载，防止】<\/span><\/h2><div><span style=\"color: rgb(77, 128, 191); font-weight: bold;\">#场景介绍：滚动事件会发起网络请求，我们不希望用户在滚动过程中一直发请求，而是隔一段时间发一次，达到节流的效果。<\/span><span style=\"color: rgb(139, 170, 74);\"><br><\/span><\/div><div><span style=\"color: rgb(194, 79, 74);\">#原理：当持续触发事件时，保证一定时间内只触发一次事件处理函数。&nbsp;&nbsp;<\/span><span style=\"color: rgb(77, 128, 191); font-weight: bold;\"><br><\/span><\/div><div><span style=\"color: rgb(194, 79, 74);\">应用：<\/span>滚动加载，防止大幅度滚动加载过多<\/div><p><span style=\"color: rgb(77, 128, 191);\">#简单版：<\/span><\/p><p>function throttle(fn,wait=500){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let isOk = true<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return function(){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(!isOk)return<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;isOk = false<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;setTimeout(()=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fn.apply(this,\n\narguments&nbsp; )<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;isOk = true<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },wait)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>}<\/p><p><span style=\"color: rgb(194, 79, 74);\">#复杂版(可设置是否立即触发事件)【摘自<\/span><a href=\"https:\/\/www.cnblogs.com\/fsjohnhuang\/p\/4147810.html\" target=\"_blank\">underscore<\/a><span style=\"color: rgb(194, 79, 74);\">】：<\/span><\/p><p>function throttle(func, wait, options) {<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/* options的默认值<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *  表示首次调用返回值方法时，会马上调用func；否则仅会记录当前时刻，当第二次调用的时间间隔超过wait时，才调用func。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *  options.leading = true;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * 表示当调用方法时，未到达wait指定的时间间隔，则启动计时器延迟调用func函数，若后续在既未达到wait指定的时间间隔和func函数又未被调用的情况下调用返回值方法，则被调用请求将被丢弃。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *  options.trailing = true; <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * 注意：当options.trailing = false时，效果与上面的简单实现效果相同<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *\/<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var context, args, result;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var timeout = null;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var previous = 0;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!options) options = {};<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var later = function() {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;previous = options.leading === false ? 0 : Date.now();<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;timeout = null;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result = func.apply(context, args);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (!timeout) context = args = null;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;};<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return function() {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var now = Date.now();<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (!previous &amp;&amp; options.leading === false) previous = now;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ 计算剩余时间<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var remaining = wait - (now - previous);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;context = this;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;args = arguments;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ 当到达wait指定的时间间隔，则调用func函数<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ 精彩之处：按理来说remaining &lt;= 0已经足够证明已经到达wait的时间间隔，但这里还考虑到假如客户端修改了系统时间则马上执行func函数。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (remaining &lt;= 0 || remaining &gt; wait) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ 由于setTimeout存在最小时间精度问题，因此会存在到达wait的时间间隔，但之前设置的setTimeout操作还没被执行，因此为保险起见，这里先清理setTimeout操作<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (timeout) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;clearTimeout(timeout);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;timeout = null;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;previous = now;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result = func.apply(context, args);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (!timeout) context = args = null;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} else if (!timeout &amp;&amp; options.trailing !== false) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/ options.trailing=true时，延时执行func函数<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeout = setTimeout(later, remaining);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return result;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;};<br>  };<\/p><p><br><\/p><p><br><\/p><h2><span style=\"color: rgb(139, 170, 74);\">\/\/&nbsp;柯里化函数<\/span><\/h2><div><span style=\"color: rgb(194, 79, 74);\">#原理：柯里化是一个逐步接收参数的过程。参数还没用完，返回一个接受参数的函数&nbsp;&nbsp;<\/span><\/div><div>function add(a,b,c){<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return a+b+c<\/div><div>}<\/div><p>let curryAdd&nbsp; = curry(add,1)<\/p><p>curryAdd(2,3)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ 6<\/p><p>curryAdd(2)(3)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/ 6<br><\/p><p>curry(add)(1,2,3)&nbsp; &nbsp; &nbsp; &nbsp;\/\/ 6<\/p><p>function curry(fn,...args){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; if(fn.length&lt;=args.length){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return fn.apply(this,args)<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; }<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; return function(...args1){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return curry(fn,...args,...args1)<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; }<\/p><p>}&nbsp;<br><\/p><p>ES6骚写法：<\/p><p>let curry = (fn,...args)=&gt;args.length&gt;=fn.length?fn(...args):(...args1)=&gt;curry(fn,...args,...args1)<\/p><p><br><\/p><p>求实现一个函数，满足以下需求<\/p><p>fn(1)&nbsp; &nbsp;\/\/ 1<\/p><p>fn(2)(3)&nbsp; &nbsp; \/\/ 6<\/p><p>fn(1)(2)(3)&nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; 6<\/p><p>不固定参数的<\/p><p>const curry = (fn,...args)=&gt;{<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let result = (...args1)=&gt;{<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return&nbsp;\n\ncurry(fn,...[...args,...args1])<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result.toString = ()=&gt;fn.apply(this,args)<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return result<\/p><p>}<\/p><p>const multiply = (...args)=&gt;args.reduce((a,b)=&gt;a*b,1)<\/p><p>const curryMultiply = curry(multiply)<\/p><p>curryMultiply(2)&nbsp; &nbsp; &nbsp; &nbsp;\/\/ 2<br><\/p><p>curryMultiply(2)(3)&nbsp; &nbsp; \/\/ 6<br><\/p><p>curryMultiply(2)(3)(2)&nbsp; &nbsp; \/\/ 12&nbsp;&nbsp;<br><\/p><p><br><\/p><p><br>\/\/链式函数调用<br>add(1)(2)(3);         \/\/ 6<br>add(1)(2)(3)(4);      \/\/ 10<br>add(1)(2)(3)(4)(5);   \/\/ 15<br>let add = i =&gt; {<br>     let result = j =&gt; add(i+j)<br>     result.toString = ()=&gt;i<br>     return result<br>}<br>add(1)(2,3)           \/\/ 6<br>add(1,2)(3,4)         \/\/ 10<br>add(1)(2,3)(4,5,6)    \/\/ 21<br>let add = (...args0)=&gt;{<br>     let sum = args0.reduce((a,b)=&gt;a+b,0)<br>     let result = (...args1)=&gt;add(...(args0.concat(args1)))<br>     result.toString = ()=&gt;sum<br>     return result<br>}<\/p><p><br><\/p><h1><span style=\"color: rgb(139, 170, 74);\">\/\/ 深拷贝&nbsp; &nbsp;<\/span><\/h1><h4>工作上还是用<span style=\"font-size: 12px;\">&nbsp;<\/span><a target=\"_blank\" href=\"https:\/\/lodash.com\/docs#cloneDeep\" rel=\"nofollow noopener noreferrer\" style=\"font-size: 12px; background-color: rgb(255, 255, 255);\">lodash 的深拷贝函数<\/a><\/h4><div><span style=\"color: rgb(194, 79, 74);\">#浅深拷贝：（浅拷贝【只解决了第一层的问题】）新建一个对象，如果原对象的属性为基本类型,拷贝的是属性的值。如果属性是引用类型，拷贝的是指针地址。如果一个对象改变了这个地址，会影响到新对象。（深拷贝）将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。<\/span><\/div><div><span style=\"color: rgb(77, 128, 191);\">#简单版：&nbsp;&nbsp;<\/span><span style=\"color: rgb(194, 79, 74);\"><br><\/span><\/div><div><span style=\"color: rgb(77, 128, 191);\">1.<\/span><\/div><div><span style=\"font-weight: bold;\">JSON.parse(JSON.stringify(obj))<\/span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ 【不能拷贝函数，循环引用，直接忽略undefined，symbol，正则】<\/div><p><span style=\"font-weight: bold;\">MessageChannel<\/span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/ 【不能拷贝函数，symbol，可以<span style=\"color: rgb(194, 79, 74);\">循环引用<\/span>和其他】<\/p><p>function structuralClone(obj) {&nbsp;<\/p><p>&nbsp; &nbsp;return new Promise(resolve =&gt; {&nbsp;<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const { port1, port2 } = new MessageChannel()&nbsp;<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port2.onmessage = ev =&gt; resolve(ev.data)&nbsp;<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port1.postMessage(obj)&nbsp;<\/p><p>&nbsp; &nbsp;})&nbsp;<\/p><p>}&nbsp;<\/p><p>var obj = {\n  a: 1,\n  b: {\n    c: 2\n  }\n}&nbsp;<\/p><p>obj.b.d = obj.b\n\n\/\/ 注意该方法是异步的\n\/\/ 可以处理 undefined 和循环引用对象&nbsp;<\/p><p>const test = async () =&gt; {\n  const clone = await structuralClone(obj)&nbsp;<\/p><p>console.log(clone)\n}&nbsp;<\/p><p>test()&nbsp;<br><\/p><div><span style=\"color: rgb(77, 128, 191);\">2.<\/span><\/div><p>function deepCopy(obj){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let result = Array.isArray(obj)?[]: {}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for(let i in obj){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(obj.hasOwnProperty(i)){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let type = Object.prototype.toString.call(obj[i]).slice(8,-1)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(type ==='Array'||type ==='Object'){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result[i] = deepCopy(obj[i])<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }else{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result[i] = obj[i]<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return result<br>}<\/p><div><p>\/\/ 不能拷贝循环引用<\/p><p><span style=\"color: rgb(77, 128, 191);\">#升级版：&nbsp;&nbsp;<\/span><span style=\"color: rgb(194, 79, 74);\">能拷贝循环引用(此处用WeakMap而不是Map是，因为前者对于设置对象是弱引用关系，后者为强引用关系，具体例如：<\/span><\/p><p><span style=\"font-size: small;\"><span style=\"color: rgb(194, 79, 74);\">let obj = {a:1}&nbsp; &nbsp;<\/span><span style=\"color: rgb(194, 79, 74);\">const map&nbsp; = new Map()&nbsp; &nbsp; map.set(obj,'strong')&nbsp; &nbsp; &nbsp;obj = null&nbsp; &nbsp; \/\/&nbsp;&nbsp;虽然我们手动将<code style=\"font-family: 微软雅黑;\">obj<\/code>，进行释放，然是<code style=\"font-family: 微软雅黑;\">target<\/code>依然对<code style=\"font-family: 微软雅黑;\">obj<\/code>存在强引用关系，所以这部分内存依然无法被释放。<\/span><\/span><\/p><p><span style=\"color: rgb(194, 79, 74);\"><span style=\"font-size: small;\">let obj = {a:1}&nbsp; &nbsp;const map&nbsp; = new WeakMap()&nbsp; &nbsp; map.set(obj,'strong')&nbsp; &nbsp; &nbsp;obj = null&nbsp; &nbsp; \/\/&nbsp;&nbsp;如果是<code style=\"font-family: 微软雅黑;\">WeakMap<\/code>的话，<code style=\"font-family: 微软雅黑;\">target<\/code>和<code style=\"font-family: 微软雅黑;\">obj<\/code>存在的就是弱引用关系，当下一次垃圾回收机制执行时，这块内存就会被释放掉。<\/span><br><\/span><\/p><p><span style=\"color: rgb(194, 79, 74);\">)<\/span><\/p><p>function deepCopy(obj,map=new WeakMap()){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let result = Array.isArray(obj)?[]: {}<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(map.get(obj)){&nbsp;<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return map.get(obj)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;map.set(obj,result)<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for(let i in obj){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(obj.hasOwnProperty(i)){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let type = Object.prototype.toString.call(obj[i]).slice(8,-1)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(type ==='Array'||type ==='Object'){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result[i] = deepCopy(obj[i],map)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }else{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;result[i] = obj[i]<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return result<br>}&nbsp;&nbsp;<br><\/p><p>let obj = {<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a:1, b:{bb:2},c:[5,6,7]<\/p><p>}<\/p><p>obj.obj=obj<\/p><p>let d = deepCopy(obj)<\/p><p><span style=\"color: rgb(194, 79, 74);\">但不能拷贝map，set:<\/span><\/p><p>const map = new Map();<br>map.set('key', 'value');<br><br>const set = new Set();<br>set.add('eric');<\/p><p>let obj = {map,set}<\/p><p>let d = deepCopy(obj)<\/p><p>obj.map.set('key','new value')<\/p><p>obj.set.add('doris')<\/p><p>console.log(obj)<\/p><p><br><\/p><h2><span style=\"font-weight: bold; color: rgb(139, 170, 74);\">\/\/ Promise\/A+规范<\/span><\/h2><p><\/p><h5><a href=\"https:\/\/www.aiheart.top\/eblog\/assets\/html\/Promise.html\" target=\"_blank\">手写Promise<\/a><\/h5><p>promise缺点：不能取消<\/p><p><br><\/p><h1><\/h1><h5><br><\/h5><div><span style=\"font-weight: normal;\"><\/span><br><\/div><div><br><\/div><\/div>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2019\/11\/25 11:14:10",
"updatetime":"2020\/3\/18 11:24:56"
},
{
"id":2021,
"title":"前端基础知识~[顶]",
"content":"<p>原始类型有：<\/p><p>undefined,null,boolean,string,number,symbol<\/p><p>对象类型有：<\/p><p>object, array,function<\/p><p><span style=\"color: rgb(194, 79, 74);\">区别在于原始类型存储的是值，对象类型存储的是指针地址<\/span><\/p><p>typeof返回类型有7种：<br><\/p><p><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\"><codemicrosoft yahei'=\"\" !important;=\"\" border:=\"\" 0px=\"\" background:=\"\" rgb(243,=\"\" 241,=\"\" 241);\"=\"\">\"number<\/codemicrosoft><\/codemicrosoft>\",\"string\",\"boolean\",\"undefined\",\"object\",\"function\",\"symbol\"<\/p><blockquote>typeof null&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp;<span style=\"background-color: rgb(255, 255, 255);\">\"<\/span>object<span style=\"background-color: rgb(255, 255, 255);\">\"<\/span><\/blockquote><blockquote>typeof NaN&nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; \"number\"<\/blockquote><p>typeof \/^eric$\/&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; \"object\"&nbsp;&nbsp;&nbsp;&nbsp;<br><\/p><p>typeof arguments&nbsp; &nbsp; &nbsp;\/\/&nbsp; \"object\"&nbsp;&nbsp;<br><\/p><p>function <span style=\"color: rgb(194, 79, 74);\">specificTypeOf<\/span>(e){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; return Object.prototype.toString.apply(e).slice(8,-1)<br><\/p><p>}<br><\/p><p><span style=\"color: rgb(194, 79, 74);\">specificTypeOf<\/span>(Symbol())&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp;\"Symbol\"<\/p><p><br><\/p><h2>##易错点：<\/h2><p>console.log(true+1-false)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/ 2<\/p><p>console.log(true+'abc')&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/ 'trueabc'<\/p><p>console.log(1+'2'+false)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/ '12false'<\/p><p>console.log('5'-2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ 3<\/p><p>console.log(-2+'5')&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/ '-25'&nbsp;&nbsp;<br><\/p><p>console.log('5' * '2')&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ 10<\/p><p>console.log('1'&gt;true)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ false<\/p><p>console.log('2' + ['koala',1])&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/ 2koala,1&nbsp;<\/p><p><span style=\"color: rgb(194, 79, 74);\">console.log(null+'1')&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<\/span><\/p><p><span style=\"color: rgb(194, 79, 74);\">console.log(undefined+'1')&nbsp;<\/span> &nbsp; &nbsp; &nbsp; &nbsp;<\/p><p><span style=\"color: rgb(194, 79, 74);\">console.log(null+1)<\/span><\/p><p><span style=\"color: rgb(194, 79, 74);\">console.log(undefined+1)&nbsp;&nbsp;<\/span><\/p><p>let obj = {a:1}<\/p><p>console.log(obj+'')&nbsp;<\/p><p>对象转原始类型<\/p><p>let obj = {<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; valueOf(){&nbsp; return 1 },<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; toString(){&nbsp; return '2'},<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; [Symbol.toPrimitive](){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return 3<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<\/p><p>}<br><\/p><p>【如果是转字符串类型的呢（String(obj)）就调用toString，不是字符串类型的话就先调用&nbsp;<code style=\"font-size: 12px;\">valueOf<\/code>，结果不是基础类型的话再调用&nbsp;<code style=\"font-size: 12px;\">toString.<\/code>[Symbol.toPrimitive]优先级最高，有它在，轮不到其他】<\/p><p>例如：<\/p><p>let a= {<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; i:1,<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; valueOf(){&nbsp; return this.i++ },<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; toString(){&nbsp; return this.i++}<\/p><p>}<\/p><p>a==1&amp;&amp;a==2<\/p><p>a=='1'&amp;&amp;a=='2'<\/p><p>\/\/ 两个都为true，而且都是直接调用valueOf<\/p><p><span style=\"font-weight: bold; color: rgb(194, 79, 74);\">另外方法：试试Object.defineProperty<\/span><\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br><\/p><div><div><span style=\"font-weight: bold;\">\/\/作用域和NaN 这里不具体讲作用域，意在说明NaN<\/span><\/div><div>var b=1;&nbsp;<\/div><div>function outer(){&nbsp;<\/div><div>&nbsp; &nbsp; var b=2;&nbsp;<\/div><div>&nbsp; &nbsp; function inner(){&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b++;&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.log(b);&nbsp;<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var b=3;&nbsp;<\/div><div>&nbsp; &nbsp; }&nbsp;<\/div><div>&nbsp; &nbsp; inner();<\/div><div>}&nbsp;<\/div><div>outer();<\/div><div><span style=\"font-weight: bold;\">\/\/ 再看看别的例子<\/span><\/div><div>console.log(a++)&nbsp; &nbsp; &nbsp; \/\/&nbsp; Uncaught ReferenceError: a is not defined<br><\/div><div><span style=\"font-weight: bold;\">\/\/ 下面呢？<\/span><\/div><div>console.log(a++)<\/div><div>if(false){<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp;var a = 1<\/div><div>}<\/div><div><span style=\"font-weight: bold;\">\/\/ 再举个栗子&nbsp;&nbsp;<\/span><br><\/div><div>console.log('a' in window)&nbsp; &nbsp; &nbsp; &nbsp; \/\/ false<\/div><div><span style=\"font-weight: bold;\">\/\/ 下面呢？&nbsp;&nbsp;<\/span><br><\/div><div>console.log('a' in window)&nbsp; &nbsp; &nbsp; &nbsp; \/\/ true<\/div><div><div>if(false){<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp;var a = 1<\/div><div>}<\/div><\/div><div><div><span style=\"font-weight: bold;\">\/\/&nbsp;\n\n再举个栗子？&nbsp;&nbsp;<\/span><br><\/div><div>console.log(a)&nbsp; &nbsp; &nbsp; &nbsp; \/\/ ƒ a(){}<br><\/div><div>function a(){}<\/div><div><div><span style=\"font-weight: bold;\">\/\/ 下面呢？&nbsp; <span style=\"color: rgb(194, 79, 74);\">【<\/span><\/span><span style=\"color: rgb(194, 79, 74);\">如果是变量提升，是不存在块级作用域的，但是函数提升是存在的<span style=\"font-weight: bold;\">】<\/span><\/span><\/div><div>console.log(a, 'a' in window)&nbsp; &nbsp; &nbsp; &nbsp; \/\/ undefined&nbsp; &nbsp; true<\/div><\/div><div><div>if(true){<br>&nbsp; &nbsp; &nbsp; &nbsp;console.log(a)&nbsp; &nbsp; &nbsp; &nbsp; \/\/ ƒ a(){}<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp;function a(){}<\/div><div>}<\/div><\/div><\/div><div>预解析为：<\/div><div>var a&nbsp; &nbsp; \/\/&nbsp;&nbsp;函数&nbsp;a&nbsp;的<span style=\"color: rgb(194, 79, 74);\">声明<\/span><\/div><div><div><div>console.log(a, 'a' in window)&nbsp; &nbsp; &nbsp; &nbsp; \/\/ undefined&nbsp; &nbsp; true<\/div><\/div><div><div>if(true){<\/div><div>&nbsp; &nbsp; &nbsp; &nbsp;function a(){}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n\n\/\/&nbsp;&nbsp;函数&nbsp;a&nbsp;的<span style=\"color: rgb(194, 79, 74);\">定义<\/span><br>&nbsp; &nbsp; &nbsp; &nbsp;console.log(a)&nbsp; &nbsp; &nbsp; &nbsp; \/\/ ƒ a(){}<\/div><div>}<\/div><\/div><\/div><div><span style=\"color: rgb(194, 79, 74);\">【其实函数 function a(){} 在经过预解析之后，将函数声明提到函数级作用域最前面，然后将函数定义提升到块级作用域最前面。注意：这里的函数定义是提升到块级作用域最前面。】<\/span><\/div><div><br><\/div><span style=\"font-weight: bold;\">\/\/作用域&nbsp;<\/span><br><\/div><div>if(!('a' in window)){<\/div><p>&nbsp; &nbsp; &nbsp; &nbsp; var a = 1<\/p><div>}<\/div><p>console.log(a)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ undefined<\/p><p><span style=\"color: rgb(194, 79, 74);\">另外：【let和var的区别除了var会变量提升，let声明前不能用变量【暂时性死区】】，还有：<\/span><\/p><p>let变量不会挂载在window上<\/p><p>let a = 1;<\/p><p>var b = 2;<\/p><p>console.log(window.a,window.b)&nbsp; &nbsp;\/\/&nbsp; &nbsp; undefined 2&nbsp; &nbsp; &nbsp;&nbsp;<\/p><p>console.log(a,b)&nbsp; &nbsp;\/\/&nbsp; &nbsp; 1 2&nbsp;&nbsp;<br><\/p><p><span style=\"font-weight: bold;\">#变量提升的副作用【demo】<\/span><\/p><div>var&nbsp;tmp&nbsp;=&nbsp;new&nbsp;Date();<\/div><div>function&nbsp;f()&nbsp;{<\/div><div>&nbsp;&nbsp;console.log(tmp);<\/div><div>&nbsp;&nbsp;if&nbsp;(false)&nbsp;{<\/div><div>&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;tmp&nbsp;=&nbsp;'hello&nbsp;world';<\/div><div>&nbsp;&nbsp;}<\/div><div>}<\/div><div>f();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/ undefined&nbsp; &nbsp; &nbsp; 【访问不到时间，如果改作let就可以访问到了】<\/div><p><br><\/p><p><br><\/p><p><span style=\"font-weight: bold;\">\/\/说明原因<\/span><\/p><p>function fn(a){<br>&nbsp; &nbsp; &nbsp; console.log(a)<br>&nbsp; &nbsp; &nbsp; var a = 100;<br>&nbsp; &nbsp; &nbsp; function a(){}<br>&nbsp; &nbsp; &nbsp; console.log(a)<br>}<br>fn(1)<\/p><p><span style=\"text-decoration-line: line-through;\"><span style=\"color: rgb(194, 79, 74);\">#同名的变量声明比函数声明更优先&nbsp;<\/span>&nbsp;<\/span><\/p><p>相当于<\/p><p><span style=\"color: rgb(194, 79, 74);\">function a(){}<\/span><\/p><p><span style=\"color: rgb(194, 79, 74);\">var a<\/span><\/p><p>console.log(a)<\/p><p>var a = 100<\/p><p>console.log(a)<br><\/p><p><span style=\"color: rgb(194, 79, 74);\">#同名的函数声明比变量声明更优先&nbsp; &nbsp;<\/span>&nbsp;<\/p><p>你可以再试试 var a = 3; var a;&nbsp; 【var a; 和var a = undefined是有区别的】<\/p><p><br><\/p><p><span style=\"font-weight: bold;\">来测试：<\/span><\/p><p>var&nbsp;a&nbsp;=&nbsp;0;<br>if(true){<br>&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;1;<br>&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;a(){}<br>&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;21;<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"里面\",a);<br>}<br>console.log(\"外部\",a);&nbsp;&nbsp;<br><\/p><p><br><\/p><p>\/\/ 解析：<\/p><p>var&nbsp;a&nbsp;=&nbsp;0;<br>if(true){<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(a,window.a);\/\/&nbsp;函数提升，是块级作用域，输出&nbsp;function&nbsp;a&nbsp;和&nbsp;0<br>&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;1;&nbsp;&nbsp;\/\/&nbsp;取作用域最近的块级作用域的 function a ,且被重置为 1了，本质又是一个&nbsp;变量的赋值。<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(a,window.a);\/\/&nbsp;a&nbsp;是指向块级作用域的&nbsp;a,&nbsp;输出&nbsp;1&nbsp;和&nbsp;0&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;a(){}&nbsp;\/\/&nbsp;函数的声明，将执行函数的变量的定义同步到函数级的作用域。<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(a,window.a);\/\/&nbsp;输出&nbsp;1&nbsp;和&nbsp;1<br>&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;21;&nbsp;\/\/&nbsp;仍然是函数定义块级作用域的&nbsp;a&nbsp;,重置为&nbsp;21<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(a,window.a);&nbsp;\/\/&nbsp;输出为函数提升的块级作用域的&nbsp;a,&nbsp;输出&nbsp;21，1<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(\"里面\",a);<br>}<br>console.log(\"外部\",a);&nbsp;&nbsp;<br><\/p><p><br><\/p><p><span style=\"font-weight: bold;\">\/\/引用传递<\/span><\/p><pre>function changeObjProperty(o) {\n  o.siteUrl = \"http:\/\/www.baidu.com\"\n  o = new Object()\n  o.siteUrl = \"http:\/\/www.google.com\"<\/pre><pre>  a = new Object()<p>  a.siteUrl = \"http:\/\/www.google.com\"<\/p>} \nlet webSite = new Object();\nchangeObjProperty(webSite);&nbsp;<\/pre><p><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">console<\/span><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">.<\/span><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">log<\/span><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">(<\/span><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">webSite<\/span><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">.<\/span><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">siteUrl<\/span><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">);<\/span>&nbsp;<br><\/p><p>console.log(o,a)<\/p><p>【对象作为参数，传递进去的是这个对象的引用地址，o.siteUrl是给这个对象赋值，o = new Object，把o指向另一个新对象，所以此时改动不影响第一个o。两个o指向对象的引用地址不同】<\/p><p><br><\/p><p><\/p><h2><span style=\"font-weight: bold;\">##异步运行机制：<\/span><\/h2>1.所有同步任务都在主线程上执行，形成一个执行栈。<br>2.主线程之外，还存在一个 任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件。<br>3.一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看里面有哪些任务。这些任务又分为微任务【Promise，process.nextTick】和宏任务【包括整体代码script，setTimeout，setInterval】。先把微任务放到执行栈执行，然后再执行宏任务。<br>4.主线程不断重复上面的第三步。<br><br>&lt;button onclick=\"updateSync()\"&gt;同步&lt;\/button&gt;<br>&lt;button onclick=\"updateAsync()\"&gt;异步&lt;\/button&gt;<br>&lt;div id=\"output\"&gt;&lt;\/div&gt;<br><br>&lt;script&gt;<br>function updateSync(){<br>&nbsp; &nbsp; &nbsp; &nbsp;for(let i = 0;i&lt;1000000;i++){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;document.getElementById('output').innerHTML = i;<br>&nbsp; &nbsp; &nbsp; &nbsp;}<br>}<br>function updateAsync(){<br>&nbsp; &nbsp; &nbsp; &nbsp; let i = 0;<br>&nbsp; &nbsp; &nbsp; &nbsp; function updateLater(){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; document.getElementById('output').innerHTML = i++;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(i&lt;1000000){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;setTimeout(updateLater,0)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;updateLater()<br>}<br>&lt;\/script&gt;<br>从上面的例子中可以明显的看出，异步编程对于 JavaScript来说是多么多么的重要。<br>同步js运行过程中 UI更新被阻塞，只有当它结束退出后才会更新 UI。反之，当异步的时候，会明显的看到 Dom在逐步更新的过程。<br><h3><br><\/h3><h2>##实现js动画最好的是requestAnimationFrame[<span style=\"color: rgb(194, 79, 74);\">请求动画帧<\/span>]:<\/h2>requestAnimationFrame 比起 setTimeout、setInterval的优势主要有两点：<br>1、<span style=\"color: rgb(194, 79, 74);\"><span style=\"font-weight: bold;\">紧跟浏览器刷新频率，不丢帧不卡顿<\/span>&nbsp;<\/span> requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。<br>2、\n\n<span style=\"color: rgb(194, 79, 74);\"><strong>CPU节能<\/strong>&nbsp;<\/span> 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。\n\n使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。<div>3.&nbsp;&nbsp;<span style=\"font-weight: bold; color: rgb(194, 79, 74);\">函数节流<\/span><strong>：<\/strong>在高频率事件(resize,scroll等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。<div>4.&nbsp; 定时器实现动画不可靠，回调不一定在规定时间后执行。<\/div><p>5. 大部分动画效果采用css就能解决，但像顺滑的回到顶部等css做不到这时需要用requestAnimationFrame&nbsp;<\/p><div>例如：<\/div><div><div><div>let startTime = new Date().getTime();&nbsp;<\/div><div>setTimeout(()=&gt;{\n  let endTime = new Date().getTime();\n  console.log(endTime - startTime);\n},50)&nbsp;<\/div><div>for(let i=0;i&lt;20000;i++) {\n  console.log(1);\n}<\/div><div><span style=\"color: rgb(194, 79, 74);\">实现调用的时间不是50ms&nbsp; &nbsp; = =!!<\/span><\/div><\/div><div><br><\/div><span style=\"font-weight: bold;\">#\n\nrequestAnimationFrame用法&nbsp;<\/span><br>var ele = document.getElementById(\"test\");<br>var progress  = 0;<br>\/\/回调函数<br>function render(timestamp) {<br>&nbsp; &nbsp; &nbsp; &nbsp;progress +=1;<br>&nbsp; &nbsp; &nbsp; &nbsp;ele.style.width = progress + \"%\";<br>&nbsp; &nbsp; &nbsp; &nbsp;ele.innerHTML=progress + \"%\";<br>&nbsp; &nbsp; &nbsp; &nbsp;\/\/修改图像的位置<br>&nbsp; &nbsp; &nbsp; &nbsp;if(progress &lt;100){   <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/在动画没有结束前，递归渲染<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;requestAnimationFrame(render);<br>&nbsp; &nbsp; &nbsp; &nbsp;}<br>}<br>\/\/第一帧渲染<br>requestAnimationFrame(render);<p><br><\/p><p><\/p><h2>##如何理解 JS 中的this关键字？<\/h2><div><div>this表示当前对象<br>\n全局环境下，this表示window对象<br>\n局部环境：<br>\n1.在全局作用域下直接调用函数，this指向window。<br>\n2.对象函数调用，哪个对象调用就指向哪个对象。<br>\n3.使用new实例化对象，在构造函数中的this指向实例化对象。<br>\n4.使用call或apply改变this的指向。<\/div><\/div>var a = 0<br>var obj = {<br>&nbsp; &nbsp; &nbsp; a: 1,<br>&nbsp; &nbsp; &nbsp; func:function(){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; console.log(this.a)<br>&nbsp; &nbsp; &nbsp; }<br>}<br>console.log(obj.func())        \/\/ 1<br>var b = obj.func <br>console.log(b())               \/\/ 0<p><\/p><p><br><\/p><p><\/p><h2><span style=\"font-weight: bold;\">##new的实现原理<\/span><\/h2>1.先创建一个空对象<br>2.将这个对象的__proto__指向构造函数的原型prototype<\/div><div>3.执行构造函数方法，并把this指向到新建的对象，判断返回的结果，如果是对象类型，则直接返回，如果不是，则返回新建的对象。<br>function _new(){<br>&nbsp; &nbsp; &nbsp;let target = {}<br>&nbsp; &nbsp; &nbsp;let [constructor,...args] = [...arguments]<br>&nbsp; &nbsp; &nbsp;target.__proto__ = constructor.prototype<br>&nbsp; &nbsp; &nbsp;let result = constructor.apply(target,args)<br>&nbsp; &nbsp; &nbsp;if(result&amp;&amp;(typeof(result)=='object'||typeof(result)=='function')){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return result&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; <span style=\"color: rgb(194, 79, 74);\">#为什么返回有对象就返回对象呢？&nbsp;&nbsp;<\/span><br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; return target<br>}<\/div><div><span style=\"color: rgb(194, 79, 74);\">#为什么返回有对象就返回对象呢？<\/span><\/div><div><p><span style=\"color: rgb(77, 128, 191);\">class Aha{<br>&nbsp; &nbsp; &nbsp; &nbsp; constructor(){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return {g:2}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;aa(){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;console.log(this.a)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>}<\/span><\/p><p><span style=\"color: rgb(77, 128, 191);\">let ddd = new Aha()<\/span><\/p><p><span style=\"color: rgb(77, 128, 191);\">ddd&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; &nbsp;{g:2}<\/span><\/p><p><span style=\"color: rgb(77, 128, 191);\">ddd.aa&nbsp; &nbsp; &nbsp; \/\/ undefined<\/span><\/p><br>function Func(name,age){<br>&nbsp; &nbsp; &nbsp; this.name = name<br>&nbsp; &nbsp; &nbsp; this.age = age<br>}<br>Func.prototype.say = function(){<br>&nbsp; &nbsp; &nbsp; &nbsp;console.log(`i am the `+this.name)<br>}<br>let tony = _new(Func,'Iron Man',54)<br>console.log(tony.name,tony.age,tony.say())            \/\/  'Iron Man'   54    'i am the Iron Man'<br><br><span style=\"color: rgb(194, 79, 74);\">在掘金上看到更高级的写法<\/span><br>function _new(constructor,...args){<br>&nbsp; &nbsp; &nbsp; &nbsp; let obj = {}<br>&nbsp; &nbsp; &nbsp; &nbsp; Object.setPrototypeOf(obj,constructor.prototype)<br>&nbsp; &nbsp; &nbsp; &nbsp; let result = constructor.apply(obj,args)<br>&nbsp; &nbsp; &nbsp; &nbsp; return result instanceof Object?result:obj<br>}<\/div><div><br><\/div><p><span style=\"color: rgb(194, 79, 74);\">#先说下instanceof<\/span><\/p><pre>instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。<\/pre><p>let num = 1<br>num instanceof Number \/\/ false<br><br>num = new Number(1)<br><\/p><pre><span style=\"font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, 微软雅黑, Arial, sans-serif;\">num instanceof Number \/\/ true<\/span>&nbsp;<\/pre><p>有些说法是检测目标的<code>__proto__<\/code>与构造函数的<code>prototype<\/code>相同即返回true，这是不严谨的，检测的一定要是对象才行<\/p><pre>let num = 1\nnum.__proto__ === Number.prototype \/\/ true\nnum instanceof Number \/\/ false\n\nnum = new Number(1)\nnum.__proto__ === Number.prototype \/\/ true\nnum instanceof Number \/\/ true\n\nnum.__proto__ === (new Number(1)).__proto__ \/\/ true&nbsp;<\/pre><p>&nbsp;<br><\/p><div><h2>##instanceof的实现原理<\/h2><p>function myInstanceof(a,b){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let prototype = b.prototype<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while(true){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(typeof a !== 'object' || a == null){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return false<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a = a.__proto__<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(prototype === a){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return true<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>}<\/p><br><h2>##call,apply,bind的区别<\/h2>function info(a,b){<br>    console.log(this.age,a,b)<br>}<br>var person = {<br>    age: 20<br>}<br>info.call(person,1,2)             \/\/  20 1 2<br>info.apply(person,[1,2])          \/\/  20 1 2<br>info.bind(person)(1,2)            \/\/  20 1 2<\/div><div>info.bind(person,1,2)() \/\/ 20 1 2&nbsp;&nbsp;<\/div><div>info.bind(person,1)(2) \/\/ 20 1 2&nbsp;&nbsp;&nbsp;&nbsp;<br><div><span style=\"color: rgb(194, 79, 74);\">#直接调用不传参<\/span><br><div><span style=\"color: rgb(194, 79, 74);\">info.call(person) \/\/ 20 undefined undefined<br>info.apply(person) \/\/ 20&nbsp;undefined undefined&nbsp;<\/span><\/div><div><span style=\"color: rgb(194, 79, 74);\">info.bind(person) \/\/ 'info(a,b){console.log(this.age,a,b)}'&nbsp;<\/span><\/div><div><span style=\"color: rgb(194, 79, 74);\"><br><\/span><\/div><div><h2>##call的实现原理<\/h2><\/div><div><p><\/p><p>Function.prototype.myCall = function(context,...args){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(typeof this !=='function'){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new Error('this is not a function')<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;context = context||window<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let key = Symbol()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;context[key] = this<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let result = context[key](...args)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;delete context[key]<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return result<br>}<\/p><h2>##apply的实现原理<\/h2><div><p>Function.prototype.myApply = function(context,args){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(typeof this !=='function'){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new Error('this is not a function')<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;context = context || window<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let key = Symbol()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;context[key] = this<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let result = context[key](...args)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;delete context[key]<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return result<br>}<\/p><h2>##bind的实现原理<\/h2><p>Function.prototype.myBind = function(context,...args){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(typeof this !=='function'){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new Error('this is not a function')<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let fn = this<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return function F(...args1){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return fn.myApply(context,[...args,...args1])<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>}<\/p><p>let a = {}&nbsp;<\/p><p>let fn = function () { console.log(this) }&nbsp;<\/p><p>fn.bind().bind(a)()&nbsp;&nbsp;<\/p><p>【不管我们给函数&nbsp;<code style=\"font-size: 12px;\">bind<\/code>&nbsp;几次，<code style=\"font-size: 12px;\">fn<\/code>&nbsp;中的&nbsp;<code style=\"font-size: 12px;\">this<\/code>&nbsp;永远由第一次&nbsp;<code style=\"font-size: 12px;\">bind<\/code>&nbsp;决定，所以结果永远是&nbsp;<code style=\"font-size: 12px;\">window<\/code>。】<\/p><p><br><\/p><\/div><h2>##事件传播的三个阶段<\/h2><p>捕获 &gt; 目标 &gt; 冒泡&nbsp;<\/p><p>event.stopPropagation()&nbsp; &nbsp;阻止<span style=\"color: rgb(194, 79, 74);\">冒泡<\/span><\/p><p>event.stopDefault()&nbsp; 阻止默认行为（a或button submit）<\/p><p><br><\/p><h2>##forgot点<\/h2><div>#setTimeout第三个参数为函数的传参<\/div><div>function aha(e){console.log(e)}<\/div><div>setTimeout(aha,500,'hahaha')&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/ hahaha<\/div><p>&nbsp;<br><\/p><h2>##概念<\/h2><p>#除了基本对象，其他对象都有原型（译者注：基础对象指原型链终点的对象。基础对象的原型是<code style=\"font-size: 12px;\">null<\/code>。）<\/p><p>#sessionStorage关掉标签页时数据就被清除<\/p><p><br><\/p><h2>##1<\/h2><p>var a = 10;<br>function foo() {<br>    console.log(a); \/\/ ??<br>    let a = 20;<br>}<br>foo(); <br><br>解答区<br>##1<br>Uncaught ReferenceError: a is not defined<br>let和const声明可以让变量受限于其作用域上。只有在执行到达声明时才能访问它们，否则报错未定义<br><br><br><\/p><h2>##奇葩的NaN<\/h2><p>不能用isNaN来检测是否为数字<span style=\"color: rgb(194, 79, 74);\">(Number.NaN 是一个特殊值，说明某些算术运算（如求负数的平方根）的结果不是数字。例如：undefined++)<\/span><\/p><p>isNaN（）在接受一个值后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串“10”或Boolean值。而任何不能被转换为数值的值都会导致这个函数返回true。&nbsp;&nbsp;<span style=\"color: rgb(194, 79, 74);\"><br><\/span><\/p><p>!isNaN(-3)    \/\/  true<br>!isNaN(0)     \/\/  true<br>!isNaN(1)     \/\/  true<br>!isNaN(99)    \/\/  true<br>but:<br>!isNaN('11')    \/\/  true<br>!isNaN('')    \/\/  true<br>!isNaN(false)    \/\/  true<\/p><p>isNaN(NaN);&nbsp;\/\/&nbsp;true----------&gt;Number(NaN)--&gt;&nbsp;NaN<br>isNaN(\"abc\")&nbsp;\/\/&nbsp;true----------&gt;Number(\"abc\")--&gt;&nbsp;NaN<br>isNaN(\"123\")&nbsp;\/\/&nbsp;false---------&gt;Number(\"123\")--&gt;&nbsp;123<br>isNaN(true)&nbsp;\/\/&nbsp;false-----------&gt;Number(true)--&gt;1<br>isNaN(false)&nbsp;\/\/&nbsp;false----------&gt;Number(false)--&gt;0&nbsp;&nbsp;<br><br>typeof NaN     \/\/ number<br>Object.prototype.toString.call(NaN).slice(8,-1).toLowerCase()   \/\/ Number<br><br>最正确的检测数字的方式:<br>function isNumber(e){<br>    return !isNaN(e) &amp;&amp; typeof e === 'number'<br>}<br>检测整数<br>Number.isInteger(e)<\/p><p><span style=\"color: rgb(194, 79, 74);\">'2'-0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/ 2<\/span><\/p><p><span style=\"color: rgb(194, 79, 74);\">'2e'-0&nbsp; &nbsp; &nbsp; &nbsp; \/\/ NaN<\/span><\/p><p><br><\/p><h2>##为什么 0.1 + 0.2 != 0.3？如何解决这个问题？<\/h2><\/div><\/div><\/div><p>0.1+0.2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; 0.30000000000000004<\/p><p>因为 JS 采用 IEEE 754 <span style=\"font-weight: bold; color: rgb(194, 79, 74);\">双精度版本<\/span>（64位），并且只要采用 IEEE 754 的语言都有该问题。&nbsp;<\/p><p>&nbsp;IEEE 754 双精度版本（64位）将 64 位分为了三段<br><\/p><ul><li>第一位用来表示符号<\/li><li>接下去的 11 位用来表示指数<\/li><li>其他的位数用来表示有效位，也就是用二进制表示&nbsp;<code>0.1<\/code>&nbsp;中的&nbsp;<code>10011(0011)<\/code><\/li><\/ul><p><span style=\"color: rgb(194, 79, 74);\">解决方法：&nbsp;<\/span>parseFloat((0.1 + 0.2).toFixed(10)) === 0.3&nbsp; &nbsp;\/\/&nbsp; &nbsp;true<\/p><p><br><\/p><p>##concat<\/p><p>[1,2].concat(3)&nbsp; &nbsp; &nbsp; \/\/&nbsp; [1,2,3]<\/p><p>[1,2].concat([3])&nbsp; &nbsp; \/\/&nbsp; [1,2,3]<\/p><p><br><\/p><p>##splice【影响原数组】<\/p><p>let arr&nbsp; = [1,2,3]<\/p><p>arr.splice(1,1,1.5)&nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp; &nbsp;[1, 1.5, 3]<\/p><p>arr.splice(1)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; &nbsp; &nbsp;[2,3]<\/p><p><br><\/p><p>##substr和substring的区别【都不影响原字符串】<\/p><p>let a = 'string'<\/p><p>a.substr(1)&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; tring<br><\/p><p>a.substr(1,1)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; t<\/p><p>a.substr(2,2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; ri<\/p><p>a.substring(1)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; tring<\/p><p>a.substring(1,2)&nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; t<\/p><p>a.substring(2,4)&nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; ri<br><\/p><p><br><\/p><p>##乱序<\/p><p>function mix(arr){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; return arr.sort(()=&gt;{<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Math.random()-0.5<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; })<\/p><p>}<\/p><p>\/\/ 著名的Fisher–Yates shuffle 洗牌算法&nbsp;&nbsp;<br><\/p><p>function shuffle(arr){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp;let m = arr.length<\/p><p>&nbsp; &nbsp; &nbsp; while(m&gt;1){<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let index = parseInt(Math.random()*m--)<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[arr[index],arr[m]] = [arr[m],arr[index]]<\/p><p>&nbsp; &nbsp; &nbsp; }<\/p><p>&nbsp; &nbsp; &nbsp; return arr<\/p><p>}<\/p><p><br><\/p><p>##JSON.stringify<br><\/p><p>JSON.stringify(1)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; &nbsp; &nbsp;'1'<\/p><p>JSON.stringify('1')&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp; &nbsp;'\"1\"'<\/p><p>JSON.stringify(false)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp; &nbsp;\"false\"<\/p><p>JSON.stringify(null)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp; &nbsp; \"null\"&nbsp;&nbsp;<br><\/p><p>JSON.stringify(undefined)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp; &nbsp; undefined<\/p><p>JSON.stringify(function a(){})&nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; &nbsp; &nbsp; undefined&nbsp;<\/p><p>JSON.stringify(Symbol())&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; &nbsp; &nbsp; undefined&nbsp;<br><\/p><p>JSON.stringify(\/^eric$\/)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \/\/&nbsp; &nbsp; &nbsp; \"{}\"<\/p><p><br><\/p><p>#map,filter【都是生成一个新数组,都接受3个参数（item,index,arr）】<\/p><p>let arr = [1,2,3]<\/p><p>arr.map(parseInt)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; &nbsp; &nbsp;[1,NaN,NaN]<\/p><p>arr.filter(item=&gt;item!=2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\/\/&nbsp; &nbsp; &nbsp; [1, 3]<\/p><p><br><\/p><p><span style=\"color: rgb(194, 79, 74);\">#手写一个ajax<\/span><\/p><p>let ajax = ({url,type='get',data,dataType},cb)=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let xhr = XMLHttpRequest?new XMLHttpRequest():new ActiveXObject(\"Microsoft.XMLHTTP\")<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xhr.open(type,url,true)<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xhr.responseType = dataType || 'json'&nbsp; 【'arraybuffer'是一个包含二进制数据的 JavaScript&nbsp;<a href=\"https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/ArrayBuffer\" style=\"background-color: rgb(255, 255, 255);\"><code>ArrayBuffer<\/code><\/a>&nbsp;。'blob'是一个包含二进制数据的&nbsp;<a href=\"https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/Blob\" style=\"background-color: rgb(255, 255, 255);\"><code>Blob<\/code><\/a>&nbsp;对象 。】<span style=\"color: rgb(194, 79, 74);\">arraybuffer转blob<\/span> var blob = new Blob([res], {type: 'application\/json'});【不设默认为'text'】【axios也是一样哦，请求时responseType设为blob】<\/p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(type=='post'){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xhr.setRequestHeader('content-type','application\/x-www-form-urlencoded')<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let str = ''<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(data!==null&amp;&amp;typeof data ==='object'){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object.keys(data).forEach((item,index)=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;str+=index?'&amp;':''<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;str+=`${item}=${data[item]}`<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; })<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xhr.send(str?str:null)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xhr.onreadystatechange = ()=&gt;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(xhr.readyState==4&amp;&amp;xhr.status==200){<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cb(xhr.responseText)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>}<\/p><p>ajax({<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;url:'https:\/\/www.aiheart.top\/api\/post\/findAroundById',<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;data:{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; id: \"18\"<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;},<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;type:'post'<br>},e=&gt;console.log(e))<br><\/p><p>ajax({<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; url:'https:\/\/jsonbox.io\/box_08848c03e9a5a7f8d39f'<br>},e=&gt;console.log(e))<\/p><p><br><\/p><h2>##cookie、localStorage和sessionStorage 三者之间的区别<\/h2><h3>#生命周期<\/h3><div>cookie: 可设置失效时间，如果没设置的话，默认关闭浏览器后失效<\/div><div>localStorage: 除非手动清除，否则永久存在<\/div><div>sessionStorage: 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。<\/div><div><h3>#存放数据大小<\/h3><\/div><div>cookie: 4kb左右<\/div><div>localStorage和sessionStorage：可以保存5MB的信息<br><\/div><div><h3>#http请求：<\/h3><\/div><div><p>cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题<\/p><p>localStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信<\/p><\/div><h3>【http请求每次都会戴上cookie，所以正常情况下请用storage方式存储】<\/h3><h2><br><\/h2><h2>##遍历循环<\/h2><div>reduce和forEach不能用break和continue，for in和for of都可以<\/div><h2>&nbsp;##判断空对象<\/h2><h3>判断是否有属性，<code>for<\/code>循环一旦执行，就说明有属性，此时返回<code>false<\/code>&nbsp;<\/h3><pre>function isEmptyObject( obj ) {\n        var name;\n        for ( name in obj ) {\n            return false;\n        }\n        return true;\n}\n\nconsole.log(isEmptyObject({})); \/\/ true\nconsole.log(isEmptyObject([])); \/\/ true\nconsole.log(isEmptyObject(null)); \/\/ true\nconsole.log(isEmptyObject(undefined)); \/\/ true\nconsole.log(isEmptyObject(1)); \/\/ true\nconsole.log(isEmptyObject('')); \/\/ true&nbsp;<\/pre><h3><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">console<\/span><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">.<\/span><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">log<\/span><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">(<\/span><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">isEmptyObject<\/span><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">(<\/span><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">true<\/span><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">)); <\/span><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\">\/\/<\/span><span style=\"font-family: Consolas, Menlo, Courier, monospace; font-size: 1em;\"> true<\/span>&nbsp;<br><\/h3><\/div><p><br><\/p><p><br><\/p><p>#forEach, map,for of, for in的区别<\/p><p>[2,3,4,6,8,2].forEach(item=&gt;{<br>     if(item&gt;4)return<br>     console.log(item)<br>})<\/p><p>\/\/ 2 3 4 2&nbsp; &nbsp;<span style=\"color: rgb(194, 79, 74);\">&nbsp;forEach【return相当于continue】【不能用break】<\/span><\/p><p><span style=\"color: rgb(194, 79, 74);\">\/\/ 比较相同项并返回<\/span><\/p><p>let arr = [2,3,2,4,6]<\/p><div><span>for<\/span><span>&nbsp;(<\/span><span>let<\/span><span>&nbsp;[<\/span><span>index<\/span><span>,&nbsp;<\/span><span>item<\/span><span>]&nbsp;<\/span><span>of<\/span><span>&nbsp;<\/span><span>arr<\/span><span>.<\/span><span>entries<\/span><span>())&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>let<\/span><span>&nbsp;<\/span><span>slicedArr<\/span><span>&nbsp;=&nbsp;<\/span><span>arr<\/span><span>.<\/span><span>slice<\/span><span>(<\/span><span>index<\/span><span>&nbsp;+&nbsp;<\/span><span>1<\/span><span>)<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>let<\/span><span>&nbsp;<\/span><span>slicedIndex<\/span><span>&nbsp;=&nbsp;<\/span><span>slicedArr<\/span><span>.<\/span><span>indexOf<\/span><span>(<\/span><span>item<\/span><span>)<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>if<\/span><span>&nbsp;(<\/span><span>slicedIndex<\/span><span>&nbsp;&gt;&nbsp;-<\/span><span>1<\/span><span>)&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>isSameArr<\/span><span>&nbsp;=&nbsp;[<\/span><span>index<\/span><span>,&nbsp;<\/span><span>index<\/span><span>&nbsp;+&nbsp;<\/span><span>slicedIndex<\/span><span>&nbsp;+&nbsp;<\/span><span>1<\/span><span>]<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>break<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 15px;line-height:=\"\" 20px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>}<\/span><\/div><p>\/\/ [0,2]&nbsp; &nbsp; &nbsp;<span style=\"color: rgb(194, 79, 74);\"> for of【用break退出循环】【不能用return】<\/span><\/p><p><br><\/p><p><br><\/p><p><br><\/p><p><br><\/p><p><br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2030\/1\/1 10:58:31",
"updatetime":"2020\/8\/19 19:50:50"
},
{
"id":2022,
"title":"npm&nvm",
"content":"<p>#nvm切换node和npm版本<br>Github： https:\/\/github.com\/coreybutler\/nvm-windows\/releases<br>在安装 Nvm 之前，先将之前安装的 node 进行卸载。否则可能会出现无法切换 node 版本的问题<br>将之前安装的全局插件删除掉，否则可能会导致 nvm 命令不起作用。文件目录如下<br>C:UsersAdministratorAppDataRoaming\npm<br>C:UsersAdministratorAppDataRoaming\npm-cache<br><br>安装后要把nvm和nodejs放在同个路径下，且不能放在有空格的文件夹里<br>如：<br>root: D:Node\nvm<br>path: D:Node\nodejs<br><br>nvm 在下载NPM的时候速度相对来说较慢，可以修改NVM文件夹的settings.txt文件，追加两行代码，目的是使用国内的镜像下载<br>settings.txt内容如下<br>root: D:Node\nvm<br>path: D:NodeNodeJs<br>\/\/后面这两句是要追加的配置代码<br>node_mirror: https:\/\/npm.taobao.org\/mirrors\/node\/<br>npm_mirror: https:\/\/npm.taobao.org\/mirrors\/npm\/<br><br>nvm install latest：   安装最新的 nodejs 版本<br>nvm install 11.12.0：  安装对应的 nodejs 版本<br>nvm uninstall 11.12.0：卸载对应的 nodejs 版本<br>nvm list available：   列出所有可用的 nodejs 版本<br>nvm list：             查看 nvm 列出已经安装的 nodejs 版本<br>nvm use 11.12.0：      使用对应的 nodejs 版本<br>更多命令在命令行输入 nvm 即可查看<br><br><br>报错：exit status 1<br>原因：我把nvm安装到了有空格的路径上（D:Program Files），导致切换失败<br>解决：把nvm卸载重装到没有空格的路径上（例如：D:\nvm），即可解决问题<br><br>报错：The process cannot access the file because it is being used by another process.<br>解决：重新设置了如下的镜像，完美解决<br>nvm node_mirror  https:\/\/npm.taobao.org\/mirrors\/node\/<br>nvm npm_mirror  https:\/\/npm.taobao.org\/mirrors\/npm\/<br><br>#nrm切换npm下载源<br>npm install nrm -g<br><\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2020\/7\/15 10:44:06",
"updatetime":"2020\/7\/15 10:44:06"
},
{
"id":2024,
"title":"2021新篇章-致四年半经验的你",
"content":null,
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2021\/1\/8 09:25:50",
"updatetime":"2021\/1\/8 09:25:50"
},
{
"id":2025,
"title":"广州外企意向名单",
"content":null,
"name":"Eric",
"uid":1,
"type":"0",
"createtime":"2021\/1\/14 17:37:53",
"updatetime":"2021\/1\/14 17:37:53"
},
{
"id":2026,
"title":"loading",
"content":"<div><span>&lt;<\/span><span>template<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>&lt;<\/span><span>div<\/span><span>&nbsp;<\/span><span>class<\/span><span>=<\/span><span>\"bg\"<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;<\/span><span>div<\/span><span>&nbsp;:<\/span><span>class<\/span><span>=<\/span><span>\"<\/span><span>`<\/span><span>${<\/span><span>position<\/span><span>}<\/span><span>`<\/span><span>\"<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;<\/span><span>svg<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>class<\/span><span>=<\/span><span>\"circular\"<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>viewBox<\/span><span>=<\/span><span>\"25&nbsp;25&nbsp;50&nbsp;50\"<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;<\/span><span>circle<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>class<\/span><span>=<\/span><span>\"path\"<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>cx<\/span><span>=<\/span><span>\"50\"<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>cy<\/span><span>=<\/span><span>\"50\"<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>r<\/span><span>=<\/span><span>\"20\"<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>fill<\/span><span>=<\/span><span>\"none\"<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\/<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;\/<\/span><span>svg<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>&lt;\/<\/span><span>div<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>&lt;\/<\/span><span>div<\/span><span>&gt;<\/span><\/div><div><span>&lt;\/<\/span><span>template<\/span><span>&gt;<\/span><\/div><div><span>&lt;<\/span><span>script<\/span><span>&gt;<\/span><\/div><div><span>export<\/span><span>&nbsp;<\/span><span>default<\/span><span>&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>name:<\/span><span>&nbsp;<\/span><span>'person-picker-loading'<\/span><span>,<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>props:<\/span><span>&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>position:<\/span><span>&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>type:<\/span><span>&nbsp;<\/span><span>String<\/span><span>,<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>default:<\/span><span>&nbsp;<\/span><span>'center'<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;}<\/span><\/div><div><span>&nbsp;&nbsp;}<\/span><\/div><div><span>}<\/span><\/div><div><span>&lt;\/<\/span><span>script<\/span><span>&gt;<\/span><\/div><div><span>&lt;<\/span><span>style<\/span><span>&nbsp;<\/span><span>lang<\/span><span>=<\/span><span>\"less\"<\/span><span>&nbsp;<\/span><span>scoped<\/span><span>&gt;<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>.circular<\/span><span>&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>height<\/span><span>:&nbsp;<\/span><span>42px<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>width<\/span><span>:&nbsp;<\/span><span>42px<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>animation<\/span><span>:&nbsp;<\/span><span>loading-rotate<\/span><span>&nbsp;<\/span><span>2s<\/span><span>&nbsp;<\/span><span>linear<\/span><span>&nbsp;<\/span><span>infinite<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;}<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>.path<\/span><span>&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>animation<\/span><span>:&nbsp;<\/span><span>loading-dash<\/span><span>&nbsp;<\/span><span>1.5s<\/span><span>&nbsp;<\/span><span>ease-in-out<\/span><span>&nbsp;<\/span><span>infinite<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>stroke-dasharray<\/span><span>:&nbsp;<\/span><span>90<\/span><span>,&nbsp;<\/span><span>150<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>stroke-dashoffset<\/span><span>:&nbsp;<\/span><span>0<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>stroke-width<\/span><span>:&nbsp;<\/span><span>2<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>stroke<\/span><span>:&nbsp;<\/span><span>#409EFF<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>stroke-linecap<\/span><span>:&nbsp;<\/span><span>round<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;}<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>@keyframes<\/span><span>&nbsp;<\/span><span>loading-dash<\/span><span>&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>0%<\/span><span>&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>stroke-dasharray<\/span><span>:&nbsp;<\/span><span>1<\/span><span>,&nbsp;<\/span><span>200<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>stroke-dashoffset<\/span><span>:&nbsp;<\/span><span>0<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;}<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>50%<\/span><span>&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>stroke-dasharray<\/span><span>:&nbsp;<\/span><span>90<\/span><span>,&nbsp;<\/span><span>150<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>stroke-dashoffset<\/span><span>:&nbsp;<\/span><span>-40px<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;}<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>100%<\/span><span>&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>stroke-dasharray<\/span><span>:&nbsp;<\/span><span>90<\/span><span>,&nbsp;<\/span><span>150<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>stroke-dashoffset<\/span><span>:&nbsp;<\/span><span>-120px<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;}<\/span><\/div><div><span>&nbsp;&nbsp;}<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>.bg<\/span><span>&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>position<\/span><span>:&nbsp;<\/span><span>absolute<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>z-index<\/span><span>:&nbsp;<\/span><span>2000<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>background-color<\/span><span>:&nbsp;<\/span><span>rgba<\/span><span>(<\/span><span>255<\/span><span>,&nbsp;<\/span><span>255<\/span><span>,&nbsp;<\/span><span>255<\/span><span>,&nbsp;<\/span><span>.4<\/span><span>);<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>margin<\/span><span>:&nbsp;<\/span><span>0<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>top<\/span><span>:&nbsp;<\/span><span>0<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>right<\/span><span>:&nbsp;<\/span><span>0<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>bottom<\/span><span>:&nbsp;<\/span><span>0<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>left<\/span><span>:&nbsp;<\/span><span>0<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>transition<\/span><span>:&nbsp;opacity&nbsp;<\/span><span>0.3s<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;}<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>.center<\/span><span>&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>position<\/span><span>:&nbsp;<\/span><span>absolute<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>top<\/span><span>:&nbsp;<\/span><span>50%<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>left<\/span><span>:&nbsp;<\/span><span>50%<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>transform<\/span><span>:&nbsp;<\/span><span>translate<\/span><span>(<\/span><span>-50%<\/span><span>,&nbsp;<\/span><span>-50%<\/span><span>);<\/span><\/div><div><span>&nbsp;&nbsp;}<\/span><\/div><div><span>&nbsp;&nbsp;<\/span><span>.top<\/span><span>&nbsp;{<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>position<\/span><span>:&nbsp;<\/span><span>absolute<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>top<\/span><span>:&nbsp;<\/span><span>20%<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>left<\/span><span>:&nbsp;<\/span><span>50%<\/span><span>;<\/span><\/div><div><span>&nbsp;&nbsp;&nbsp;&nbsp;<\/span><span>transform<\/span><span>:&nbsp;<\/span><span>translate<\/span><span>(&nbsp;<\/span><span>-50%<\/span><span>,&nbsp;<\/span><span>0<\/span><span>);<\/span><\/div><div><span>&nbsp;&nbsp;}<\/span><\/div><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 15px;line-height:=\"\" 20px;white-space:=\"\" pre;\"=\"\"><\/divcourier><\/p><div><span>&lt;\/<\/span><span>style<\/span><span>&gt;<\/span><\/div>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2021\/2\/8 16:51:49",
"updatetime":"2021\/2\/8 16:51:49"
},
{
"id":2027,
"title":"1",
"content":"<p>2<\/p>",
"name":"Eric",
"uid":1,
"type":"1",
"createtime":"2021\/3\/7 17:12:11",
"updatetime":"2021\/3\/7 17:12:11"
}
]
}